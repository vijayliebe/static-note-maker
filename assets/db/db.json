{
  "users": [
    {
      "id": 1,
      "user": "admin@admin.com",
      "password": "admin"
    }
  ],
  "subjects": [
    {
      "id": 1,
      "name": "Algorithm",
      "key": "algo"
    },
    {
      "id": 2,
      "name": "Javascript",
      "key": "js"
    },
    {
      "id": 3,
      "name": "ES6",
      "key": "es6"
    },
    {
      "id": 4,
      "name": "Nodejs",
      "key": "node"
    },
    {
      "id": 5,
      "name": "Typescript",
      "key": "ts"
    },
    {
      "id": 6,
      "name": "HTML",
      "key": "html"
    },
    {
      "id": 7,
      "name": "CSS",
      "key": "css"
    },
    {
      "id": 8,
      "name": "Angular",
      "key": "ng"
    },
    {
      "id": 9,
      "name": "React",
      "key": "react"
    },
    {
      "id": 10,
      "name": "Redux",
      "key": "redux"
    },
    {
      "id": 11,
      "name": "Performance",
      "key": "performance"
    },
    {
      "id": 12,
      "name": "System Design",
      "key": "sd"
    },
    {
      "id": 13,
      "name": "Shell Scripting",
      "key": "shell"
    },
    {
      "id": 14,
      "name": "GIT",
      "key": "git"
    },
    {
      "id": 15,
      "name": "Python",
      "key": "py"
    },
    {
      "id": 16,
      "name": "Java",
      "key": "java"
    },
    {
      "id": 17,
      "name": "Others",
      "key": "oth"
    },
    {
      "id": 18,
      "name": "English",
      "key": "eng"
    },
    {
      "id": 19,
      "name": "Puzzles",
      "key": "puz"
    },
    {
      "id": 20,
      "name": "Managerial",
      "key": "man"
    },
    {
      "id": 21,
      "name": "Networking",
      "key": "networking"
    },
    {
      "id": 22,
      "name": "Data Science",
      "key": "ds"
    },
    {
      "id": 23,
      "name": "Statistics",
      "key": "stat"
    },
    {
      "id": 24,
      "name": "Probability",
      "key": "prob"
    }
  ],
  "categories": [
    {
      "id": "1",
      "name": "String",
      "key": "str",
      "sub": "algo"
    },
    {
      "id": "2",
      "name": "Array",
      "key": "arr",
      "sub": "algo"
    },
    {
      "id": "3",
      "name": "Object|Hash|Mapping",
      "key": "obj",
      "sub": "algo"
    },
    {
      "id": "4",
      "name": "Search",
      "key": "search",
      "sub": "algo"
    },
    {
      "id": "5",
      "name": "Sorting",
      "key": "sort",
      "sub": "algo"
    },
    {
      "id": "51",
      "name": "Logarithms",
      "key": "log",
      "sub": "algo"
    },
    {
      "id": "6",
      "name": "Greedy",
      "key": "greed",
      "sub": "algo"
    },
    {
      "id": "61",
      "name": "Dynamic",
      "key": "dynamic",
      "sub": "algo"
    },
    {
      "id": "62",
      "name": "Recursion",
      "key": "recursion",
      "sub": "algo"
    },
    {
      "id": "7",
      "name": "Tree",
      "key": "tree",
      "sub": "algo"
    },
    {
      "id": "8",
      "name": "Date & Time",
      "key": "datetime",
      "sub": "algo"
    },
    {
      "id": "9",
      "name": "Queue & Stack",
      "key": "queueStack",
      "sub": "algo"
    },
    {
      "id": "10",
      "name": "Syllabus",
      "key": "syllabus",
      "sub": "algo"
    },
    {
      "id": "11",
      "name": "Disk",
      "key": "disk",
      "sub": "shell"
    },
    {
      "name": "Events",
      "key": "events",
      "sub": "js",
      "id": "K8hwS7H"
    },
    {
      "name": "General",
      "key": "general",
      "sub": "js",
      "id": "fLxAGlD"
    },
    {
      "name": "Async",
      "key": "async",
      "sub": "js",
      "id": "CcPDpap"
    },
    {
      "name": "DOM",
      "key": "dom",
      "sub": "js",
      "id": "VcHWFpK"
    },
    {
      "name": "Code Pattern",
      "key": "code_pattern",
      "sub": "js",
      "id": "QkRqsfU"
    },
    {
      "name": "OOPs",
      "key": "oops",
      "sub": "js",
      "id": "S9Hc3Bu"
    },
    {
      "name": "Linked-list",
      "key": "linked-list",
      "sub": "algo",
      "id": "O-ZdpST"
    },
    {
      "name": "Tree",
      "key": "tree",
      "sub": "algo",
      "id": "3Ss3hC0"
    },
    {
      "name": "Caching",
      "key": "caching",
      "sub": "sd",
      "id": "0bEDgF0"
    },
    {
      "name": "General",
      "key": "general",
      "sub": "sd",
      "id": "-5xn9uI"
    },
    {
      "name": "General",
      "key": "general",
      "sub": "es6",
      "id": "vAzKM_l"
    },
    {
      "name": "Numbers",
      "key": "numbers",
      "sub": "algo",
      "id": "Pfw11Yu"
    },
    {
      "name": "General",
      "key": "general",
      "sub": "git",
      "id": "i0w-jut"
    },
    {
      "name": "Framework",
      "key": "framework",
      "sub": "node",
      "id": "o8_tryU"
    },
    {
      "name": "Node Core",
      "key": "node_core",
      "sub": "node",
      "id": "CF6SBM8"
    },
    {
      "name": "Library",
      "key": "library",
      "sub": "node",
      "id": "NZSriI4"
    },
    {
      "name": "Javascript",
      "key": "javascript",
      "sub": "algo",
      "id": "WCnWkkl"
    }
  ],
  "algo": [
    {
      "subject": "algo",
      "title": null,
      "ques": "First non repeating character in a string",
      "links": [
        {
          "name": "https://www.youtube.com/watch?v=U7rxgP-fp8E"
        }
      ],
      "tags": [
        {
          "name": "ideserve"
        }
      ],
      "ans": "\nconst firstNonRepeat = (str) => {\n   let strMap = {};\n   for(let i = 0; i < str.length; i++){\n       let char = str[i];\n       if(char in strMap){\n           delete strMap[char];\n       } else {\n           strMap[char] = 1;\n       }\n   }\n   return Object.keys(strMap)[0];\n }\n \n const st = \"ADBCGHIEFKJLADTVDERFSWVGHQWCNOPENSMSJWIERTFB\";\n \n console.log(firstNonRepeat(st));",
      "diff": 2,
      "imp": 2,
      "cate": [
        "str"
      ],
      "id": 5
    },
    {
      "subject": "algo",
      "ques": "Anagram Pattern Search",
      "links": [
        {
          "name": "https://www.youtube.com/watch?v=h4MCwdfZZas"
        },
        {
          "name": "https://www.geeksforgeeks.org/anagram-substring-search-search-permutations/"
        }
      ],
      "tags": [
        {
          "name": "ideserve"
        }
      ],
      "ans": "const anyAnagram = (txt, pattern) => {\n       // create map for pattern\n       let pattMap = {};\n       for(let i=0; i<pattern.length; i++){\n           let ch = pattern[i];\n           pattMap[ch] = (ch in pattMap) ? ++pattMap[ch] : 1;\n       }\n \n       // method to compare two maps\n       const compareMap = (m1, m2) => {\n           // console.log(\"compareMap :: m1 : m2 ::::\", m1, \"::\", m2)\n           let keys1 = Object.keys(m1);\n           let keys2 = Object.keys(m2);\n           if(keys1.length != keys2.length){\n               return false;\n           }\n \n           for(let k of keys1){\n               if(m1[k] !== m2[k]){\n               return false;\n               }\n           }\n           return true;\n       }\n \n       let txtMap = {};\n       let insertCount = 0;\n       let firstCharIdx = 0;\n      \n       for(let i=0; i< txt.length; i++){\n           let ch = txt[i];\n           // text map\n           txtMap[ch] = (ch in txtMap) ? ++txtMap[ch] : 1;\n           ++insertCount;\n \n           // If insertion in map == pattern length\n           if(insertCount == pattern.length){\n               // compare map\n               let result = compareMap(pattMap, txtMap);\n               if(result){\n                   return \"Present\";\n               } else {\n                   // remove first ch\n                   let firstChar = txt[firstCharIdx];\n                   if(txtMap[firstChar] == 1){\n                       delete txtMap[firstChar];\n                   } else {\n                       txtMap[firstChar] = txtMap[firstChar] - 1;\n                   }\n                   // reduce insertion count\n                   insertCount = insertCount - 1;\n                   // increase firsr char index\n                   firstCharIdx = firstCharIdx + 1;\n               }\n           }\n       }\n       return \"Not Present\"\n   }\n \n   let Text = \"ideserve\";\n   let Pattern = \"veer\";\n \n   console.log(anyAnagram(Text, Pattern));",
      "diff": 1,
      "imp": 1,
      "cate": [
        "str"
      ],
      "id": 6
    },
    {
      "subject": "algo",
      "title": "In-Place Shuffle",
      "ques": "RANDOMLY Reorder Array in O(N)",
      "links": [
        {
          "name": "https://www.youtube.com/watch?v=CoI4S7z1E1Y&ab_channel=CSDojo"
        }
      ],
      "tags": [
        {
          "name": "Lynda"
        },
        {
          "name": "fisher-yates shuffle"
        },
        {
          "name": "Interview Cake"
        }
      ],
      "ans": "\nconst reorder = (arr) => {\n    for(let i=arr.length; i>0; i--){\n    \tconst randomIdx = Math.floor(Math.random() * i);\n    \t// swap\n    \tlet temp = arr[randomIdx];\n    \tarr[randomIdx] = arr[i-1];\n    \tarr[i-1] = temp;\n    }\n    return arr;\n}\n\nconsole.log(reorder([1,0,3,9,2]));",
      "diff": 1,
      "imp": 3,
      "cate": [
        "arr",
        "greed"
      ],
      "id": 7
    },
    {
      "subject": "algo",
      "title": "Top Scores",
      "ques": "Write a function that takes: an array of unsortedScores & the highestPossibleScore in the game and returns a sorted array of scores in less than O(n lg n) time.",
      "links": [],
      "tags": [
        {
          "name": "Interview Cake"
        }
      ],
      "ans": "\n/*\nconst unsortedScores = [37, 89, 41, 65, 91, 53];\nconst HIGHEST_POSSIBLE_SCORE = 100;\n\nsortScores(unsortedScores, HIGHEST_POSSIBLE_SCORE);\nreturns [91, 89, 65, 53, 41, 37]\n*/\n\nfunction sortScores(unorderedScores, highestPossibleScore) {\n\n    // Array of 0s at indices 0..highestPossibleScore\n    const scoreCounts = new Array(highestPossibleScore + 1).fill(0);\n  \n    // Populate scoreCounts\n    unorderedScores.forEach(score => {\n      scoreCounts[score]++;\n    });\n  \n    // Populate the final sorted array\n    const sortedScores = [];\n  \n    // For each item in scoreCounts\n    for (let score = highestPossibleScore; score >= 0; score--) {\n      const count = scoreCounts[score];\n  \n      // For the number of times the item occurs\n      for (let time = 0; time < count; time++) {\n        sortedScores.push(score);\n      }\n    }\n  \n    return sortedScores;\n  }",
      "diff": 2,
      "imp": 4,
      "cate": [
        "sort"
      ],
      "id": 8
    },
    {
      "subject": "algo",
      "title": "Bracket Validator",
      "ques": "Check for Balanced Brackets in an expression",
      "links": [],
      "tags": [
        {
          "name": "Interview Cake"
        }
      ],
      "ans": "\n/*\nInput: exp = “[()]{}{[()()]()}” \nOutput: true\n\nInput: exp = “[(])” \nOutput: false \n\n*/\nfunction isValid(code) {\n\n    const openersToClosers = {\n      '(': ')',\n      '[': ']',\n      '{': '}',\n    };\n  \n    const openers = new Set(['(', '[', '{']);\n    const closers = new Set([')', ']', '}']);\n  \n    const openersStack = [];\n  \n    for (let i = 0; i < code.length; i++) {\n      const char = code.charAt(i);\n  \n      if (openers.has(char)) {\n        openersStack.push(char);\n      } else if (closers.has(char)) {\n        if (!openersStack.length) {\n          return false;\n        }\n        const lastUnclosedOpener = openersStack.pop();\n  \n        // If this closer doesn't correspond to the most recently\n        // seen unclosed opener, short-circuit, returning false\n        if (openersToClosers[lastUnclosedOpener] !== char) {\n          return false;\n        }\n      }\n    }\n    return openersStack.length === 0;\n  }",
      "diff": 4,
      "imp": 4,
      "cate": [
        "queueStack"
      ],
      "id": 9
    },
    {
      "subject": "algo",
      "title": "Permutation Palindrome",
      "ques": "Write an efficient function that checks whether any permutation of an input string is a palindrome.",
      "links": [],
      "tags": [
        {
          "name": "Interview Cake"
        }
      ],
      "ans": "/**\n * \n * Write an efficient function that checks whether any permutation of an input string is a palindrome. \n\nYou can assume the input string only contains lowercase letters.\n\nExamples:\n\n\"civic\" should return true\n\"ivicc\" should return true\n\"civil\" should return false\n\"livci\" should return false\n */\n  function hasPalindromePermutation(theString) {\n\n    // Track characters we've seen an odd number of times\n    const unpairedCharacters = new Set();\n  \n    for (let char of theString) {\n      if (unpairedCharacters.has(char)) {\n        unpairedCharacters.delete(char);\n      } else {\n        unpairedCharacters.add(char);\n      }\n    }\n  \n    // The string has a palindrome permutation if it\n    // has one or zero characters without a pair\n    return unpairedCharacters.size <= 1; // If str length is odd, there will be 1\n  }",
      "diff": 3,
      "imp": 4,
      "cate": [
        "obj"
      ],
      "id": 10
    },
    {
      "subject": "algo",
      "title": "Reverse String",
      "ques": "Take an array of characters and reverse the letter",
      "links": [],
      "tags": [
        {
          "name": "Interview Cake"
        }
      ],
      "ans": "\nfunction reverse(arrayOfChars) {\n  let leftIndex = 0;\n  let rightIndex = arrayOfChars.length - 1;\n  while (leftIndex < rightIndex) {\n    // Swap characters\n    const temp = arrayOfChars[leftIndex];\n    arrayOfChars[leftIndex] = arrayOfChars[rightIndex];\n    arrayOfChars[rightIndex] = temp;\n    // Move towards middle leftIndex++; rightIndex--;\n  }\n}\n\n\n// OR\n\nconst reverse2 = (arrayOfChars) => {\n   let s = 0;\n   let m = Math.ceil(arrayOfChars.length / 2);\n\n   while(s < m){\n      let e = (arrayOfChars.length - 1) - s;\n      [arrayOfChars[s], arrayOfChars[e]] = [arrayOfChars[e], arrayOfChars[s]];\n      s = s + 1;\n   }\n   return arrayOfChars;\n}",
      "diff": 1,
      "imp": 1,
      "cate": [
        "str"
      ],
      "id": 11
    },
    {
      "subject": "algo",
      "title": "Reverse Words",
      "ques": "Takes a message as an array of characters and reverses the order of the words in place",
      "links": [],
      "tags": [
        {
          "name": "Interview Cake"
        }
      ],
      "ans": "/*\nconst message = [ 'c', 'a', 'k', 'e', ' ', 'p', 'o', 'u', 'n', 'd', ' ',\n's', 't', 'e', 'a', 'l' ]; \n\nreverseWords(message);\n\nconsole.log(message.join('')); \n// Prints: 'steal pound cake'\n*/\n\nfunction reverseWords(message) {\n  // First we reverse all the characters in the entire message reverseCharacters(message, 0, message.length - 1);\n  // This gives us the right word order\n  // but with each word backward\n  // Now we'll make the words forward again // by reversing each word's characters\n  // We hold the index of the *start* of the current word // as we look for the *end* of the current word\n  let currentWordStartIndex = 0;\n  for (let i = 0; i <= message.length; i++) {\n    // Found the end of the current word!\n    if (i === message.length || message[i] === \" \") {\n      // If we haven't exhausted the string our\n      // next word's start is one character ahead reverseCharacters(message, currentWordStartIndex, i - 1); currentWordStartIndex = i + 1;\n    }\n  }\n}\nfunction reverseCharacters(message, leftIndex, rightIndex) {\n  // Walk towards the middle, from both sides\n  while (leftIndex < rightIndex) {\n    // Swap the left char and right char const temp = message[leftIndex]; message[leftIndex] = message[rightIndex]; message[rightIndex] = temp;\n    leftIndex++;\n    rightIndex--;\n  }\n}\n",
      "diff": 1,
      "imp": 1,
      "cate": [
        "str"
      ],
      "id": 12
    },
    {
      "subject": "algo",
      "title": "Merge Sorted Arrays",
      "ques": "We have our lists of orders sorted numerically already, in arrays. Write a function to merge our arrays of orders into one sorted array",
      "links": [],
      "tags": [
        {
          "name": "Interview Cake"
        }
      ],
      "ans": "\n/* const myArray = [3, 4, 6, 10, 11, 15];\nconst alicesArray = [1, 5, 8, 12, 14, 19];\nconsole.log(mergeArrays(myArray, alicesArray));\n// logs [1, 3, 4, 5, 6, 8, 10, 11, 12, 14, 15, 19] \n*/\n\nfunction mergeArrays(myArray, alicesArray) {\n  // Set up our mergedArray const mergedArray = [];\n  let currentIndexAlices = 0;\n  let currentIndexMine = 0;\n  let currentIndexMerged = 0;\n  while (currentIndexMerged < myArray.length + alicesArray.length) {\n    const isMyArrayExhausted = currentIndexMine >= myArray.length;\n    const isAlicesArrayExhausted = currentIndexAlices >= alicesArray.length;\n    // Case: next comes from my array\n    // My array must not be exhausted, and EITHER:\n    // 1) Alice's array IS exhausted, or\n    // 2) The current element in my array is less\n    // than the current element in Alice's array\n    if (\n      !isMyArrayExhausted && (isAlicesArrayExhausted ||\n        myArray[currentIndexMine] < alicesArray[currentIndexAlices])\n    ) {\n      mergedArray[currentIndexMerged] = myArray[currentIndexMine];\n      currentIndexMine++;\n      // Case: next comes from Alice's array \n      \n    } else {\n      mergedArray[currentIndexMerged] = alicesArray[currentIndexAlices];\n      currentIndexAlices++;\n    }\n    currentIndexMerged++;\n  }\n  return mergedArray;\n}\n\n\n// OR\n\nconst mergeArrays = (arr1, arr2) => {\n    let finalArr = [];\n    let arr1Start = 0;\n    let arr2Start = 0;\n    while(arr1Start < arr1.length || arr2Start < arr2.length){\n        if(arr1[arr1Start] && arr2[arr2Start]){\n            if(arr1[arr1Start] < arr2[arr2Start]){\n                finalArr.push(arr1[arr1Start]);\n                arr1Start = arr1Start + 1;\n            } else {\n                finalArr.push(arr2[arr2Start]);\n                arr2Start = arr2Start + 1;\n            } \n        } else if(arr1[arr1Start] && !arr2[arr2Start]){\n                finalArr.push(arr1[arr1Start]);\n                arr1Start = arr1Start + 1;\n        } else if(arr2[arr2Start] && !arr1[arr1Start]){\n            finalArr.push(arr2[arr2Start]);\n            arr2Start = arr2Start + 1;\n        }\n        \n    }\n    return finalArr;\n}",
      "diff": 1,
      "imp": 1,
      "cate": [
        "arr",
        "sort"
      ],
      "id": 13
    },
    {
      "subject": "algo",
      "title": "Cafe Order Checker",
      "ques": "Given all three arrays, write a function to check that my service is first-come, first-served.\nAll food should come out in the same order customer requested it",
      "links": [],
      "tags": [
        {
          "name": "Interview Cake"
        }
      ],
      "ans": "/* As an example,\n   Take Out Orders: [1, 3, 5]\n    Dine In Orders: [2, 4, 6]\n     Served Orders: [1, 2, 4, 6, 5, 3]\nwould not be first-come, first-served, since order 3 was requested before order 5 but order 5 was served first.\n\nBut,\n    T\n    ake Out Orders: [17, 8, 24]\n    Dine In Orders: [12, 19, 2]\n     Served Orders: [17, 8, 12, 19, 24, 2]\n\nwould be first-come, first-served.\n\nNote - Order numbers are arbitrary. They do not have to be in increasing order. */\n\nfunction isFirstComeFirstServed(takeOutOrders, dineInOrders, servedOrders) {\n    var takeOutOrdersIndex = 0;\n    var dineInOrdersIndex = 0;\n    var takeOutOrdersMaxIndex = takeOutOrders.length - 1;\n    var dineInOrdersMaxIndex = dineInOrders.length - 1;\n    for (var i = 0; i < servedOrders.length; i++) {\n        var order = servedOrders[i];\n        // if we still have orders in takeOutOrders\n        // and the current order in takeOutOrders is the same // as the current order in servedOrders\n        if (takeOutOrdersIndex <= takeOutOrdersMaxIndex &&\n            order === takeOutOrders[takeOutOrdersIndex]) {\n            takeOutOrdersIndex++;\n            // if we still have orders in dineInOrders\n            // and the current order in dineInOrders is the same // as the current order in servedOrders\n        } else if (dineInOrdersIndex <= dineInOrdersMaxIndex &&\n            order === dineInOrders[dineInOrdersIndex]) {\n            dineInOrdersIndex++;\n            // if the current order in servedOrders doesn't match the current\n            // order in takeOutOrders or dineInOrders, then we're not serving first-come, // first-served\n        } else {\n            return false;\n        }\n    }\n    // check for any extra orders at the end of takeOutOrders or dineInOrders if (dineInOrdersIndex != dineInOrders.length ||\n    takeOutOrdersIndex != takeOutOrders.length) {\n    return false;\n}\n// all orders in servedOrders have been \"accounted for\" // so we're serving first-come, first-served!\nreturn true;\n}",
      "diff": 1,
      "imp": 1,
      "cate": [
        "arr",
        "sort",
        "greed"
      ],
      "id": 14
    },
    {
      "subject": "algo",
      "title": "Inflight Entertainment",
      "ques": "Write a function that takes an integer (in minutes) and an array of integers movieLengths(in minutes) and returns a boolean indicating whether there are two numbers in movieLengths whose sum equals flightLength",
      "links": [],
      "tags": [
        {
          "name": "Interview Cake"
        }
      ],
      "ans": "\nfunction canTwoMoviesFillFlight(movieLengths, flightLength) {\n    // Movie lengths we've seen so far \n    const movieLengthsSeen = new Set();\n    for (let i = 0; i < movieLengths.length; i++) {\n        const firstMovieLength = movieLengths[i];\n        const matchingSecondMovieLength = flightLength - firstMovieLength;\n        if (movieLengthsSeen.has(matchingSecondMovieLength)) {\n            return true;\n        }\n        movieLengthsSeen.add(firstMovieLength);\n    }\n    // We never found a match, so return false\n    return false;\n}",
      "diff": 1,
      "imp": 1,
      "cate": [
        "obj"
      ],
      "id": 15
    },
    {
      "subject": "algo",
      "title": "Word Cloud Data",
      "ques": "Write code that takes a long string and builds its word cloud data in a map , where the keys are words and the values are the number of times the words occurred.",
      "links": [],
      "tags": [
        {
          "name": "Interview Cake"
        }
      ],
      "ans": "\nclass WordCloudData {\n    constructor(inputString) {\n        this.wordsToCounts = new Map();\n        this.populateWordsToCounts(inputString);\n    }\n    populateWordsToCounts(inputString) {\n        // Iterates over each character in the input string, splitting \n        // words and passing them to this.addWordToMap()\n        let currentWordStartIndex = 0;\n        let currentWordLength = 0;\n        for (let i = 0; i < inputString.length; i++) {\n            const character = inputString.charAt(i);\n            // If we reached the end of the string we check if the last \n            // character is a letter and add the last word to our map \n            if (i === inputString.length - 1) {\n                if (this.isLetter(character)) {\n                    currentWordLength += 1;\n                }\n                if (currentWordLength > 0) {\n                    const word = inputString.slice(currentWordStartIndex, currentWordStartIndex + currentWordLength);\n                    this.addWordToMap(word);\n                }\n                \n            // If we reach a space or emdash we know we're at the end of a word\n            // so we add it to our map and reset our current word\n            } else if (character === ' ' || character === '\\u2014') {\n            if (currentWordLength > 0) {\n                const word = inputString.slice(currentWordStartIndex,\n                    currentWordStartIndex + currentWordLength);\n                this.addWordToMap(word);\n                currentWordLength = 0;\n            }\n            // We want to make sure we split on ellipses so if we get two periods in\n            // a row we add the current word to our map and reset our current word\n        } else if (character === '.') {\n            if (i < inputString.length - 1 && inputString.charAt(i + 1) === '.') {\n                if (currentWordLength > 0) {\n                    const word = inputString.slice(currentWordStartIndex, currentWordStartIndex + currentWordLength);\n                    this.addWordToMap(word);\n                    currentWordLength = 0;\n                    tpircSavaJ\n                }\n            }\n            // If the character is a letter or an apostrophe, we add it to our current word\n        } else if (this.isLetter(character) || character === '\\'') {\n            if (currentWordLength === 0) {\n                currentWordStartIndex = i;\n            }\n            currentWordLength += 1;\n            // If the character is a hyphen, we want to check if it's surrounded by letters\n            // if it is, we add it to our current word\n        } else if (character === '-') {\n            if (i > 0 && this.isLetter(inputString.charAt(i - 1)) && this.isLetter(inputString.charAt(i + 1))) {\n                currentWordLength += 1;\n            } else {\n                if (currentWordLength > 0) {\n                    const word = inputString.slice(currentWordStartIndex, currentWordStartIndex + currentWordLength);\n                    this.addWordToMap(word);\n                    currentWordLength = 0;\n                }\n            }\n        }\n    }\n}\naddWordToMap(word) {\n    let newCount;\n    // If the word is already in the map we increment its count if (this.wordsToCounts.has(word)) {\n    newCount = this.wordsToCounts.get(word) + 1;\n    this.wordsToCounts.set(word, newCount);\n    // If a lowercase version is in the map, we know our input word must be uppercase \n    // but we only include uppercase words if they're always uppercase\n    // so we just increment the lowercase version's count\n} else if (this.wordsToCounts.has(word.toLowerCase())) {\n    newCount = this.wordsToCounts.get(word.toLowerCase()) + 1;\n    this.wordsToCounts.set(word.toLowerCase(), newCount);\n    // If an uppercase version is in the map, we know our input word must be lowercase.\n    // since we only include uppercase words if they're always uppercase, we add the // lowercase version and give it the uppercase version's count\n} else if (this.wordsToCounts.has(this.capitalize(word))) {\n    newCount = this.wordsToCounts.get(this.capitalize(word)) + 1;\n\n    this.wordsToCounts.set(word, newCount);\n    this.wordsToCounts.delete(this.capitalize(word));\n    // Otherwise, the word is not in the map at all, lowercase or uppercase\n    // so we add it to the map\n} else {\n    this.wordsToCounts.set(word, 1);\n}\n}\ncapitalize(word) {\n    return word.charAt(0).toUpperCase() + word.slice(1);\n}\nisLetter(character) {\n    return 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.indexOf(character) >= 0;\n}\n}",
      "diff": 1,
      "imp": 1,
      "cate": [
        "obj"
      ],
      "id": 16
    },
    {
      "subject": "algo",
      "title": "Apple Stocks",
      "ques": "Write an efficient function that takes stock_prices and returns the best profit I could have made from one purchase and one sale of one share of Apple stock yesterday",
      "links": [],
      "tags": [
        {
          "name": "Interview Cake"
        }
      ],
      "ans": "/**\n * .\n\nFor example:\n\n  stock_prices = [10, 7, 5, 8, 11, 9]\n\nget_max_profit(stock_prices)\n# Returns 6 (buying for $5 and selling for $11)\n\nPython 3.6\nNo \"shorting\"—you need to buy before you can sell. Also, you can't buy and sell in the same time step—at least 1 minute has to pass.\n */\n\nfunction getMaxProfit(stockPrices) {\n    let maxProfit = 0;\n  \n    // Go through every time\n    for (let outerTime = 0; outerTime < stockPrices.length; outerTime++) {\n  \n      // For each time, go through every other time\n      for (let innerTime = 0; innerTime < stockPrices.length; innerTime++) {\n  \n        // For each pair, find the earlier and later times\n        const earlierTime = Math.min(outerTime, innerTime);\n        const laterTime = Math.max(outerTime, innerTime);\n  \n        // And use those to find the earlier and later prices\n        const earlierPrice = stockPrices[earlierTime];\n        const laterPrice = stockPrices[laterTime];\n  \n        // See what our profit would be if we bought at the\n        // min price and sold at the current price\n        const potentialProfit = laterPrice - earlierPrice;\n  \n        // Update maxProfit if we can do better\n        maxProfit = Math.max(maxProfit, potentialProfit);\n      }\n    }\n  \n    return maxProfit;\n  }\n\n\n\n\n  ",
      "diff": 1,
      "imp": 1,
      "cate": [
        "greed"
      ],
      "id": 17
    },
    {
      "subject": "algo",
      "title": "Highest Product of 3",
      "ques": "Given an array of integers, find the highest product you can get from three of the integers.",
      "links": [],
      "tags": [
        {
          "name": "Interview Cake"
        }
      ],
      "ans": "function highestProductOf3(arrayOfInts) {\n    if (arrayOfInts.length < 3) {\n        throw new Error(\"Less than 3 items!\");\n    }\n    // We're going to start at the 3rd item (at index 2)\n    // So pre-populate highests and lowests based on the first 2 items\n    // We could also start these as null and check below if they're set\n    // but this is arguably cleaner\n    let highest = Math.max(arrayOfInts[0], arrayOfInts[1]);\n    let lowest = Math.min(arrayOfInts[0], arrayOfInts[1]);\n\n    let highestProductOf2 = arrayOfInts[0] * arrayOfInts[1];\n\n    let lowestProductOf2 = arrayOfInts[0] * arrayOfInts[1];\n    // Except this one--we pre-populate it for the first *3* items\n    // This means in our first pass it'll check against itself, which is fine\n    let highestProductOf3 = arrayOfInts[0] * arrayOfInts[1] * arrayOfInts[2];\n    // Walk through items, starting at index 2\n    for (let i = 2; i < arrayOfInts.length; i++) {\n        const current = arrayOfInts[i];\n        // Do we have a new highest product of 3?\n        // It's either the current highest\n        // or the current times the highest product of two\n        // or the current times the lowest product of two\n        highestProductOf3 = Math.max(\n            highestProductOf3,\n            current * highestProductOf2,\n            current * lowestProductOf2\n        );\n        // Do we have a new highest product of two?\n        highestProductOf2 = Math.max(\n            highestProductOf2,\n            current * highest,\n            current * lowest\n        );\n        // Do we have a new lowest product of two?\n        lowestProductOf2 = Math.min(\n            lowestProductOf2,\n            current * highest,\n            current * lowest\n        );\n        // Do we have a new highest?\n\n        highest = Math.max(highest, current);\n        // Do we have a new lowest?\n        lowest = Math.min(lowest, current);\n    }\n    return highestProductOf3;\n}",
      "diff": 1,
      "imp": 1,
      "cate": [
        "greed"
      ],
      "id": 18
    },
    {
      "subject": "algo",
      "title": "Product of All Other Numbers",
      "ques": "You have an array of integers, and for each index you want to find the product of every integer except the integer at that index",
      "links": [
        {
          "name": "https://www.interviewcake.com/question/javascript/product-of-other-numbers?course=fc1&section=greedy"
        },
        {
          "name": "https://stackblitz.com/edit/js-j6wk5h?file=index.js"
        }
      ],
      "tags": [
        {
          "name": "Interview Cake"
        }
      ],
      "ans": "function getProductsOfAllIntsExceptAtIndex(intArray) {\n    if (intArray.length < 2) {\n        throw new Error('Getting the product of numbers at other indices requires at least 2 numbers');\n    }\n\n    const productsOfAllIntsExceptAtIndex = [];\n\n    // For each integer, we find the product of all the integers\n    // before it, storing the total product so far each time\n    let productSoFar = 1;\n    for (let i = 0; i < intArray.length; i++) {\n        productsOfAllIntsExceptAtIndex[i] = productSoFar;\n        productSoFar *= intArray[i];\n    }\n\n    // For each integer, we find the product of all the integers\n    // after it. since each index in products already has the\n    // product of all the integers before it, now we're storing\n    // the total product of all other integers\n    productSoFar = 1;\n    for (let j = intArray.length - 1; j >= 0; j--) {\n        productsOfAllIntsExceptAtIndex[j] *= productSoFar;\n        productSoFar *= intArray[j];\n    }\n\n    return productsOfAllIntsExceptAtIndex;\n}",
      "diff": 1,
      "imp": 1,
      "cate": [
        "greed"
      ],
      "id": 19
    },
    {
      "subject": "algo",
      "title": "Merging Meeting Times",
      "ques": "Write a function mergeRanges() that takes an array of multiple meeting time ranges and returns an array of condensed ranges.",
      "links": [],
      "tags": [
        {
          "name": "Interview Cake"
        }
      ],
      "ans": "\nfunction mergeRanges(meetings) {\n  // Create a deep copy of the meetings array\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign# \n  const meetingsCopy = JSON.parse(JSON.stringify(meetings));\n  \n  // Sort by start time\n  const sortedMeetings = meetingsCopy.sort((a, b) => {\n    return a.startTime - b.startTime;\n  });\n  \n  // Initialize mergedMeetings with the earliest meeting\n  const mergedMeetings = [sortedMeetings[0]];\n  for (let i = 1; i < sortedMeetings.length; i++) {\n    const currentMeeting = sortedMeetings[i];\n    const lastMergedMeeting = mergedMeetings[mergedMeetings.length - 1];\n    \n    // If the current meeting overlaps with the last merged meeting, use the\n    // later end time of the two\n    if (currentMeeting.startTime <= lastMergedMeeting.endTime) {\n      lastMergedMeeting.endTime = Math.max(\n        lastMergedMeeting.endTime,\n        currentMeeting.endTime\n      );\n    } else {\n      // Add the current meeting since it doesn't overlap\n      mergedMeetings.push(currentMeeting);\n    }\n  }\n  return mergedMeetings;\n}\n",
      "diff": 1,
      "imp": 1,
      "cate": [
        "arr",
        "sort",
        "datetime"
      ],
      "id": 20
    },
    {
      "subject": "algo",
      "title": "Find Rotation Point",
      "ques": "Write a function for finding the index of the \"rotation point",
      "links": [],
      "tags": [
        {
          "name": "Interview Cake"
        }
      ],
      "ans": "/*\nconst words = [\n  'ptolemaic',\n  'retrograde',\n  'supplant',\n  'undulate',\n  'xenoepist',\n  'asymptote',  // <-- rotates here!\n  'babka',\n  'banoffee',\n  'engender',\n  'karpatka',\n  'othellolagkage',\n];\n*/\n\nfunction findRotationPoint(words) {\n  const firstWord = words[0];\n  let floorIndex = 0;\n  let ceilingIndex = words.length - 1;\n  while (floorIndex < ceilingIndex) {\n    // Guess a point halfway between floor and ceiling\n    const guessIndex = Math.floor(floorIndex + (ceilingIndex - floorIndex) / 2);\n    // If guess comes after first word or is the first word\n    if (words[guessIndex] >= firstWord) {\n      // Go right\n      floorIndex = guessIndex;\n    } else {\n      // Go left\n      ceilingIndex = guessIndex;\n    }\n    // If floor and ceiling have converged\n    if (floorIndex + 1 === ceilingIndex) {\n      // Between floor and ceiling is where we flipped to the beginning\n      // so ceiling is alphabetically first\n      break;\n    }\n  }\n  return ceilingIndex;\n}\n",
      "diff": 1,
      "imp": 1,
      "cate": [
        "search"
      ],
      "id": 21
    },
    {
      "subject": "algo",
      "title": "Find Repeat, Space Edition",
      "ques": "Write a function which finds an integer that appears more than once in our array(If there are multiple duplicates, you only need to find one of them)",
      "links": [],
      "tags": [
        {
          "name": "Interview Cake"
        },
        {
          "name": "Duplicate inArray"
        }
      ],
      "ans": "function findRepeat(numbers) {\n  let floor = 1;\n  let ceiling = numbers.length - 1;\n  while (floor < ceiling) {\n    // Divide our range 1..n into an upper range and lower range\n    // (such that they don't overlap)\n    // lower range is floor..midpoint\n    // upper range is midpoint+1..ceiling\n    const midpoint = Math.floor(floor + (ceiling - floor) / 2);\n    const lowerRangeFloor = floor;\n    const lowerRangeCeiling = midpoint;\n    const upperRangeFloor = midpoint + 1;\n    const upperRangeCeiling = ceiling;\n    const distinctPossibleIntegersInLowerRange = lowerRangeCeiling - lowerRangeFloor + 1;\n\n    // Count number of items in lower range\n    let itemsInLowerRange = 0;\n    numbers.forEach((item) => {\n      // Is it in the lower range?\n      if (item >= lowerRangeFloor && item <= lowerRangeCeiling) {\n        itemsInLowerRange += 1;\n      }\n    });\n    if (itemsInLowerRange > distinctPossibleIntegersInLowerRange) {\n      // There must be a duplicate in the lower range\n      // so use the same approach iteratively on that range\n      floor = lowerRangeFloor;\n      ceiling = lowerRangeCeiling;\n    } else {\n      // There must be a duplicate in the upper range\n      // so use the same approach iteratively on that range \n      floor = upperRangeFloor;\n      ceiling = upperRangeCeiling;\n    }\n  }\n  // Floor and ceiling have converged\n  // We found a number that repeats!\n  return floor;\n}\n",
      "diff": 1,
      "imp": 1,
      "cate": [
        "search"
      ],
      "id": 22
    },
    {
      "subject": "algo",
      "title": "Recursive String Permutations",
      "ques": "Write a recursive function for generating all permutations of an input string. Return them as a set.",
      "links": [],
      "tags": [
        {
          "name": "Interview Cake"
        },
        {
          "name": "Permutations"
        }
      ],
      "ans": "function getPermutations(string) {\n  // Base case\n  if (string.length <= 1) {\n    return new Set([string]);\n  }\n  const allCharsExceptLast = string.slice(0, -1);\n  const lastChar = string[string.length - 1];\n\n  // Recursive call: get all possible permutations for all chars except last\n  const permutationsOfAllCharsExceptLast = getPermutations(allCharsExceptLast);\n\n  // Put the last char in all possible positions for each of the above permutations\n  const permutations = new Set();\n  permutationsOfAllCharsExceptLast.forEach(\n    (permutationOfAllCharsExceptLast) => {\n      for (\n        let position = 0;\n        position <= allCharsExceptLast.length;\n        position++\n      ) {\n        const permutation =\n          permutationOfAllCharsExceptLast.slice(0, position) + lastChar + pe;\n        permutations.add(permutation);\n      }\n    }\n  );\n  return permutations;\n}\n",
      "diff": 1,
      "imp": 1,
      "cate": [
        "dynamic",
        "recursion"
      ],
      "id": 23
    },
    {
      "subject": "algo",
      "title": "Syllabus :",
      "ques": "",
      "links": [],
      "tags": [
        {
          "name": "Interview Cake"
        }
      ],
      "ans": "\n1.Array and string manipulation\n    a.Merging Meeting Times\n    b.Reverse String in Place\n    c.Reverse Words\n    d.Merge Sorted Arrays\n    e.Cafe Order Checker\n    \n2.Hashing & Hash tables\n    a.Inflight Entertainment\n    b.Permutation Palindrome\n    c. Word Cloud Data\n    \n3.Greedy algorithms\n    a.Apple Stocks\n    b.Highest Product of 3\n    c.Product of All Other Numbers\n    d.Cafe Order Checker\n    e.In-place shuffle\n    \n4.Sorting, searching and logarithms\n    a.Find Rotation Point\n    b.Find Repeat, Space Edition\n    c.Top Scores\n    d.Merging Meeting Times\n    \n5.Trees and graphs\n    a.Balanced Binary Tree\n    b.Binary Search Tree Checker\n    c.2nd Largest Item in a Binary Search Tree\n    d.Graph Coloring\n    e.Mesh Message\n    f.Find Repeat, Space Edition BEAST MODE\n    \n6.Dynamic Programming and recursion\n    a.Recursive String Permutations\n    b.Compute the nth Fibonacci Number\n    c.Making Change\n    d.The Cake Thief\n    e.Balanced Binary Tree\n    f.Binary Search Tree Checker\n    g.2nd Largest Item in a Binary Search Tree\n    \n7.Queues and stacks\n    a.Largest stack\n    b.Implement a Queue with two stacks\n    c.Parenthesis Matching\n    d.Bracket Validator\n    \n8.Linked lists\n    a.Delete Node\n    b.Does this Linked List Have a cycle\n    c.Reverse a linked list\n    d.Kth to last Node in as Singly-Linked list\n    e.Find Repeat, Space Edition BEAST MODE\n    \n    \n    \n    \n    \n    \n    \n    \n    ",
      "diff": 1,
      "imp": 1,
      "cate": [
        "syllabus"
      ],
      "id": 24
    },
    {
      "subject": "algo",
      "title": "Type of array and its maximum element",
      "ques": "Given an array, it can be of 4 types. \n(a) Ascending \n(b) Descending \n(c) Ascending Rotated \n(d) Descending Rotated \nFind out which kind of array it is and return the maximum of that array.",
      "links": [
        {
          "name": "https://www.geeksforgeeks.org/type-array-maximum-element/"
        }
      ],
      "tags": [
        {
          "name": "GeeksforGeeks"
        },
        {
          "name": "Amazon"
        }
      ],
      "ans": "\n/*\nInput :  arr[] = { 2, 1, 5, 4, 3}\nOutput : Descending rotated with maximum element 5\n\nInput :  arr[] = { 3, 4, 5, 1, 2}\nOutput : Ascending rotated with maximum element 5\n\n\n\n====\n\nlet x1 = [2, 1, 5, 4, 3]; // Descending Rotated\nlet x2 = [3, 4, 5, 1, 2]; // Ascending Rotated\nlet a1 = [1, 1, 1, 2, 3, 4, 5, 6, 6, 6]; // Ascending\nlet a2 = [6, 6, 6, 5, 4, 3, 2, 1, 1, 1]; // Descending\nlet a3 = [3, 2, 1, 1, 1, 6, 6, 6, 5, 4]; // Descending rotated\nlet a4 = [4, 5, 6, 6, 6, 1, 1, 1, 2, 3]; // Ascending rotated\n\nconsole.log(\"*Descending Rotated :: \", findType(x1));\nconsole.log(\"*Ascending Rotated ::\", findType(x2));\nconsole.log(\"Ascending :: \", findType(a1));\nconsole.log(\"Descending :: \", findType(a2));\nconsole.log(\"Descending rotated :: \", findType(a3));\nconsole.log(\"Ascending rotated :: \", findType(a4));\n*/\n\nfunction findType(arr, n) {\n  // To store the minimum and the maximum\n  // element from the array\n  let min_element = Number.MAX_VALUE,\n    max_element = Number.MIN_VALUE;\n\n  // To store the first and the last occurrences\n  // of the minimum and the maximum\n  // element from the array\n  let min_index1 = -1,\n    max_index1 = -1,\n    max_index2 = -1,\n    min_index2 = -1;\n\n  for (let i = 0; i < n; i++) {\n    // If new minimum is found\n    if (arr[i] < min_element) {\n      // Update the minimum so far\n      // and its occurrences\n      min_element = arr[i];\n      min_index1 = i;\n      min_index2 = i;\n    }\n\n    // If current element is equal the found\n    // minimum so far then update the last\n    // occurrence of the minimum element\n    else if (arr[i] == min_element){\n     // console.log(\"ELSE Min :: i :: arr[i] ::::\", i,\"::\",arr[i]);  \n      min_index2 = i;\n    } \n\n    // If new maximum is found\n    if (arr[i] > max_element) {\n      // Update the maximum so far\n      // and its occurrences\n      max_element = arr[i];\n      max_index1 = i;\n      max_index2 = i;\n    }\n\n    // If current element is equal the found\n    // maximum so far then update the last\n    // occurrence of the maximum element\n    else if (arr[i] == max_element) {\n      max_index2 = i;\n    }\n  }\n  \n  console.log(\"MIN :: min_element :: min_index1 :: min_index2 ::::\", min_element,\"::\",min_index1,\"::\",min_index2);\n  console.log(\"MAX :: max_element :: max_index1 :: max_index2 ::::\", max_element,\"::\",max_index1,\"::\",max_index2);\n\n  // First occurrence of minimum element is at the\n  // beginning of the array and the last occurrence\n  // of the maximum element is at the end of the\n  // array then the array is sorted in ascending\n  // For example, {1, 1, 1, 2, 3, 4, 5, 6, 6, 6}\n  if (min_index1 == 0 && max_index2 == n - 1) {\n    console.log(\"Ascending with maximum\" + \" element = \" + max_element);\n  }\n\n  // First occurrence of maximum element is at the\n  // beginning of the array and the last occurrence\n  // of the minimum element is at the end of the\n  // array then the array is sorted in descending\n  // For example, {6, 6, 6, 5, 4, 3, 2, 1, 1, 1}\n  else if (max_index1 == 0 && min_index2 == n - 1) {\n    console.log(\"Descending with maximum\" + \" element = \" + max_element);\n  }\n\n  // First occurrence of maximum element is equal\n  // to the last occurrence of the minimum element + 1\n  // then the array is descending and rotated\n  // For example, {3, 2, 1, 1, 1, 6, 6, 6, 5, 4}\n  else if (max_index1 == min_index2 + 1) {\n    console.log(\n      \"Descending rotated with \" + \"maximum element = \" + max_element\n    );\n  }\n\n  // First occurrence of minimum element is equal\n  // to the last occurrence of the maximum element + 1\n  // then the array is ascending and rotated\n  // For example, {4, 5, 6, 6, 6, 1, 1, 1, 2, 3}\n  else {\n    console.log(\"Ascending rotated with \" + \"maximum element = \" + max_element);\n  }\n}\n\nlet arr1 = [5,4,3,2,1];\n\nlet arr4 = [4, 5, 6, 6, 6, 1, 1, 1, 2, 3];\n\nfindType(arr1, arr1.length);\n",
      "diff": 4,
      "imp": 4,
      "cate": [
        "arr"
      ],
      "id": 25
    },
    {
      "subject": "algo",
      "title": "Rearrange characters in a string such that no two adjacent are same",
      "ques": "Given a string with repeated characters, the task is to rearrange characters in a string so that no two adjacent characters are same.\nNote : It may be assumed that the string has only lowercase English alphabets.",
      "links": [
        {
          "name": "https://www.geeksforgeeks.org/rearrange-characters-string-no-two-adjacent/"
        }
      ],
      "tags": [
        {
          "name": "GeeksforGeeks"
        },
        {
          "name": "Amazon"
        }
      ],
      "ans": "\n/*\nInput: aaabc \nOutput: abaca \n\nInput: aaabb\nOutput: ababa \n\nInput: aa \nOutput: Not Possible\n\nInput: aaaabc \nOutput: Not Possible\n*/",
      "diff": 4,
      "imp": 3,
      "cate": [
        "str"
      ],
      "id": 26
    },
    {
      "subject": "algo",
      "title": "List of problems sorted in increasing order of difficulty",
      "ques": "",
      "links": [
        {
          "name": "https://www.ideserve.co.in/learn/dynamic-programming-interview-questions"
        }
      ],
      "tags": [
        {
          "name": "ideserve"
        }
      ],
      "ans": "",
      "diff": 3,
      "imp": 4,
      "cate": [
        "dynamic"
      ],
      "id": 27
    },
    {
      "subject": "algo",
      "title": "Binary Search",
      "ques": "",
      "links": [],
      "tags": [
        {
          "name": "General"
        }
      ],
      "ans": "  function binarySearch(key, inputArray) {\r\n      var low  = 0,\r\n          high = inputArray.length - 1,\r\n          mid;\r\n\r\n      while (low <= high) {\r\n          mid = low + (high - low) / 2;\r\n          if ((mid % 1) > 0) { mid = Math.ceil(mid); }\r\n\r\n          if (key < inputArray[mid]) { high = mid - 1; }\r\n          else if (key > inputArray[mid]) { low = mid + 1; }\r\n          else { return mid; }\r\n      }\r\n\r\n      return null;\r\n  }\r\n\r\n  // run the binary search\r\n  binarySearch(3, [1,2,4]); //returns null\r\n  binarySearch(3, [2,3,5]); //returns 1",
      "diff": 1,
      "imp": 1,
      "cate": [
        "search"
      ],
      "id": 28
    },
    {
      "subject": "algo",
      "title": "Merge Sort",
      "ques": "",
      "links": [
        {
          "name": "https://stackabuse.com/merge-sort-in-javascript/"
        }
      ],
      "tags": [
        {
          "name": "General"
        }
      ],
      "ans": "function mergeSort(array) {\n  const half = array.length / 2\n  \n  // Base case or terminating case\n  if(array.length < 2){\n    return array \n  }\n  \n  const left = array.splice(0, half)\n  return merge(mergeSort(left),mergeSort(array))\n}\n\nfunction merge(left, right) {\n    let arr = []\n    // Break out of loop if any one of the array gets empty\n    while (left.length && right.length) {\n        // Pick the smaller among the smallest element of left and right sub arrays \n        if (left[0] < right[0]) {\n            arr.push(left.shift())  \n        } else {\n            arr.push(right.shift()) \n        }\n    }\n    \n    // Concatenating the leftover elements\n    // (in case we didn't go through the entire left or right array)\n    return [ ...arr, ...left, ...right ]\n}",
      "diff": 1,
      "imp": 1,
      "cate": [
        "sort"
      ],
      "id": 29
    },
    {
      "subject": "algo",
      "title": "All possible permutation of number",
      "ques": "",
      "links": [
        {
          "name": "https://medium.com/weekly-webtips/step-by-step-guide-to-array-permutation-using-recursion-in-javascript-4e76188b88ff"
        }
      ],
      "tags": [
        {
          "name": "General"
        },
        {
          "name": "Permutations"
        }
      ],
      "ans": "var permArr = [],\n  usedChars = [];\n\nfunction permute(input) {\n  var i, ch;\n  for (i = 0; i < input.length; i++) {\n    ch = input.splice(i, 1)[0];\n    usedChars.push(ch);\n    if (input.length == 0) {\n      permArr.push(usedChars.slice());\n    }\n    permute(input);\n    input.splice(i, 0, ch);\n    usedChars.pop();\n  }\n  return permArr\n};\n\n\nconsole.log(permute([5, 3, 7, 1]));",
      "diff": 1,
      "imp": 1,
      "cate": [
        "str",
        "arr"
      ],
      "id": 30
    },
    {
      "subject": "algo",
      "title": "Array Rotation",
      "ques": "",
      "links": [],
      "tags": [
        {
          "name": "General"
        }
      ],
      "ans": "function rotatedArray(arr, times){\n   times = times % arr.length;\n   for(var i=arr.length -1; i>arr.length - 1 - times; i--){\n       var pop = arr.pop();\n       arr.unshift(pop);\n   }\n   return arr;\n}\n\n\nfunction reverseArray(arr, startIndex, EndIndex){\n  /* if(startIndex === EndIndex){\n       return \"Not valid start and end Index\";\n   }*/\n\n\n   while(startIndex < EndIndex){\n       var temp = arr[startIndex];\n       arr[startIndex]  = arr[EndIndex];\n       arr[EndIndex] = temp;\n\n\n       startIndex = startIndex + 1;\n       EndIndex = EndIndex - 1;\n  }\n\n\n   return arr;\n\n\n}\n\n\nfunction rotatedArray2(arr, times){\n    times = times % arr.length;\n   var splitArrayIndex = arr.length - times - 1;\n\n\n   arr = reverseArray(arr, 0,splitArrayIndex);\n   arr = reverseArray(arr, splitArrayIndex + 1, arr.length - 1);\n   arr = reverseArray(arr, 0, arr.length - 1);\n\n\n   return arr;\n}\n\n\n\n\nvar arr = [1,2,3,4,5, 6,7,8];\nrotatedArray(arr, 3);\n\n\nvar arr = [1,2,3,4,5, 6,7,8];\nreverseArray(arr, 5,7);",
      "diff": 1,
      "imp": 1,
      "cate": [
        "arr"
      ],
      "id": 31
    },
    {
      "subject": "algo",
      "title": "Segregate 0's, 1's and 2's together in an array[O(n)](Dutch National Flag Problem)",
      "ques": "",
      "links": [
        {
          "name": "https://www.youtube.com/watch?v=BOt1DAvR0zI&ab_channel=VivekanandKhyade-AlgorithmEveryDay"
        }
      ],
      "tags": [
        {
          "name": "Dutch National Flag Problem"
        },
        {
          "name": "youtube"
        }
      ],
      "ans": "\nconst segregate = (arr) => {\n  let posIdxLeft = 0;\n  let posIdxRight = arr.length - 1;\n\n  let elIdx = 0;\n\n  while(elIdx <= posIdxRight){\n    let v = arr[elIdx];\n\n    console.log(\"* posIdxLeft | posIdxRight | elIdx ::\", posIdxLeft, \" | \",posIdxRight, \" | \",elIdx)\n\n    if(v == 0){\n      [arr[elIdx], arr[posIdxLeft]] = [arr[posIdxLeft], arr[elIdx]];\n      posIdxLeft = posIdxLeft + 1;\n      elIdx = elIdx + 1;\n    }\n\n    if(v == 1){\n      elIdx = elIdx + 1;\n    }\n\n    if(v == 2){\n      [arr[elIdx], arr[posIdxRight]] = [arr[posIdxRight], arr[elIdx]];\n      posIdxRight = posIdxRight - 1;\n    }\n\n\n    console.log(\"*\", arr)\n    console.log(\"---------\")\n  }\n\n  return arr;\n}\n\nconst a1 = [0, 1, 1, 0, 1, 2, 1, 2, 0, 0, 0, 1];\nconsole.log(segregate(a1))",
      "diff": 1,
      "imp": 1,
      "cate": [
        "arr"
      ],
      "id": 32
    },
    {
      "subject": "algo",
      "title": "Find the missing number in the increasing sequence",
      "ques": "",
      "links": [
        {
          "name": "https://www.youtube.com/watch?v=yxYCiBja8_s&ab_channel=IDeserve"
        }
      ],
      "tags": [
        {
          "name": "ideserve"
        }
      ],
      "ans": "// total = n*(n+1)/2",
      "diff": 1,
      "imp": 1,
      "cate": [
        "arr"
      ],
      "id": 33
    },
    {
      "subject": "algo",
      "title": "Remove duplicate in Array in single loop",
      "ques": "",
      "links": [],
      "tags": [
        {
          "name": "Duplicate inArray"
        }
      ],
      "ans": "var t1 = [1,2,3,2,3];\n\nfunction duplicateInArray(){\n  for(var i=0; i<t1.length; i++){\n    if(t1[Math.abs(t1[i])] > 0){\n      t1[Math.abs(t1[i])] = -t1[Math.abs(t1[i])];\n    }else{\n      console.log('Element '+Math.abs(t1[i])+' duplicate at '+i);\n    }\n  }\n}",
      "diff": 1,
      "imp": 1,
      "cate": [
        "arr"
      ],
      "id": 34
    },
    {
      "subject": "algo",
      "title": "Doubly linked list - basics (ES5)",
      "ques": "",
      "links": [
        {
          "name": "https://stackblitz.com/edit/js-dx5fk1?file=index.js"
        }
      ],
      "tags": [
        {
          "name": "General"
        }
      ],
      "ans": "\nfunction LinkedList() {\n  this.head = null;\n  this.tail = null;\n}\n \nfunction Node(value, next, prev) {\n  this.value = value;\n  this.next = next;\n  this.prev = prev;\n}\n \nLinkedList.prototype.addToHead = function(value) {\n  var newNode = new Node(value, this.head, null);\n  if (this.head) this.head.prev = newNode;\n  else this.tail = newNode;\n  this.head = newNode;\n};\n \nLinkedList.prototype.addToTail = function(value) {\n  var newNode = new Node(value, null, this.tail);\n  if (this.tail) this.tail.next = newNode;\n  else this.head = newNode;\n  this.tail = newNode;\n};\n \nLinkedList.prototype.removeHead = function() {\n  if (!this.head) return null;\n  var val = this.head.value;\n  this.head = this.head.next;\n  if (this.head) this.head.prev = null;\n  else this.tail = null;\n  return val;\n};\n \nLinkedList.prototype.removeTail = function() {\n  if (!this.tail) return null;\n  var val = this.tail.value;\n  this.tail = this.tail.prev;\n  if (this.tail) this.tail.next = null;\n  else this.head = null;\n  return val;\n};\n \nLinkedList.prototype.search = function(searchValue) {\n  var currentNode = this.head;\n  while (currentNode) {\n    if (currentNode.value === searchValue) return currentNode.value;\n    currentNode = currentNode.next;\n  } \n  return null;\n};\n \nLinkedList.prototype.indexOf = function(value) {\n  var indexes = [];\n  var currentIndex = 0;\n  var currentNode = this.head;\n  while(currentNode) {\n    if (currentNode.value === value) indexes.push(currentIndex);\n    currentNode = currentNode.next;\n    currentIndex++;\n  }\n  return indexes;\n};\n \n \nvar myLL = new LinkedList();\n \nmyLL.addToHead(123);\nmyLL.addToHead(70);\nmyLL.addToHead('hello');\nmyLL.addToTail(19);\nmyLL.addToTail('world');\nmyLL.addToTail(20);",
      "diff": 1,
      "imp": 1,
      "cate": [
        "linked-list"
      ],
      "id": 35
    },
    {
      "subject": "algo",
      "title": "Basic binary tree implementation (ES5)",
      "ques": "",
      "links": [
        {
          "name": "https://faculty.cs.niu.edu/~mcmahon/CS241/Notes/Data_Structures/binary_tree_traversals.html"
        }
      ],
      "tags": [
        {
          "name": "General"
        }
      ],
      "ans": "\nfunction BST(value) {\n  this.value = value;\n  this.right = null;\n  this.left = null;\n}\n \nBST.prototype.insert = function(value) {\n  if (value <= this.value) {\n    if (!this.left) this.left = new BST(value);\n    else this.left.insert(value);\n  }\n  else if (value > this.value) {\n    if (!this.right) this.right = new BST(value);\n    else this.right.insert(value);\n  }\n};\n \nBST.prototype.contains = function(value) {\n  if (this.value === value) return true;\n  if (value < this.value) {\n    if (!this.left) return false;\n    else return this.left.contains(value);\n  }\n  else if (value > this.value) {\n    if (!this.right) return false;\n    else return this.right.contains(value);\n  }\n};\n \nBST.prototype.depthFirstTraversal = function(iteratorFunc, order) {\n  if (order === 'pre-order') iteratorFunc(this.value);\n  if (this.left) this.left.depthFirstTraversal(iteratorFunc, order);\n  if (order === 'in-order') iteratorFunc(this.value);\n  if (this.right) this.right.depthFirstTraversal(iteratorFunc, order);\n  if (order === 'post-order') iteratorFunc(this.value);\n};\n \nBST.prototype.breadthFirstTraversal = function(iteratorFunc) { /*** IMP ***/\n  var queue = [this];\n  while (queue.length) {\n    var treeNode = queue.shift();  /*** IMP ***/\n    iteratorFunc(treeNode);\n    if (treeNode.left) queue.push(treeNode.left);\n    if (treeNode.right) queue.push(treeNode.right);\n  }\n};\n \nfunction log(value) {\n    console.log(value);\n};\n \nBST.prototype.getMinVal = function() {\n  if (this.left) return this.left.getMinVal();\n  else return this.value;\n};\n \nBST.prototype.getMaxVal = function() {\n  if (this.right) return this.right.getMaxVal();\n  else return this.value;\n};\n \n \n \nvar bst = new BST(50);\n \nbst.insert(30);\nbst.insert(70);\nbst.insert(100);\nbst.insert(60);\nbst.insert(59);\nbst.insert(20);\nbst.insert(45);\nbst.insert(35);\nbst.insert(85);\nbst.insert(105);\nbst.insert(10);\n \nfunction log(node) {\n console.log(node.value);\n}\n \nbst.breadthFirstTraversal(log);",
      "diff": 1,
      "imp": 1,
      "cate": [
        "tree"
      ],
      "id": 36
    },
    {
      "subject": "algo",
      "title": "Queue and stack implementation using linked list",
      "ques": "",
      "links": [
        {
          "name": "https://stackblitz.com/edit/js-z2hzaf?file=index.js"
        },
        {
          "name": "https://stackblitz.com/edit/js-yhu5el?file=index.js"
        }
      ],
      "tags": [
        {
          "name": "General"
        }
      ],
      "ans": "\n// queue is initially empty\nvar Queue = {front: null, back: null};\n\n// we will use a node to keep track of the elements\n// in the queue which is represented by a linked list\nfunction Node(data, next) {\n  this.data = data;\n  this.next = next;\n} \n\n// add elements to queue in O(1) time\nfunction Enqueue(element) {\n  var N = new Node(element, null);\n  if (Queue.back === null) {\n    Queue.front = N;\n    Queue.back = N; \n  } else { \n    Queue.back.next = N; \n    Queue.back = Queue.back.next;\n  } \n}\n\n// remove first element from queue in O(1) time\nfunction Dequeue() {\n  if (Queue.front !== null) { \n    var first = Queue.front;\n    Queue.front = Queue.front.next; \n    return first.data;\n  } else {\n    if (Queue.back !== null) { Queue.back = null; }\n    return 'Cannot dequeue because queue is empty';\n  }\n}\n\nEnqueue('a'); \nEnqueue('b'); \nEnqueue('c');\n\n\nconsole.log(\"Queue ::\", Queue)\n\n=====\n\nclass queueNode{\n  constructor(v){\n    this.value = v;\n    this.next = null;\n  }\n}\n\nclass customQueue{\n  queue = {\"front\": null, \"back\": null};\n\n  enqueue(v){\n    let n = new queueNode(v);\n    if(this.queue.back == null){\n      this.queue.front = n;\n      this.queue.back = n;\n    } else {\n      this.queue.back.next = n;\n      this.queue.back = this.queue.back.next;\n    }\n  }\n\n  dequeue(){\n    if(this.queue.front){\n      let first = this.queue.front.next;\n      this.queue.front = first;\n      return first.value;\n    } else {\n      if(this.queue.back) this.queue.back = null;\n      return \"Not having any value to dequeue\"\n    }\n  }\n}\n\n// let q = new customQueue();\n// q.enqueue(1);\n// q.enqueue(2);\n// q.enqueue(3);\n// q.dequeue();\n// q.enqueue(4);\n// q.dequeue();\n// q.enqueue(5);\n\n// console.log(\"q.queue ::\", q.queue)\n\n\nconsole.log(\"========== STACK ==============\");\n\nclass stackNode{\n  constructor(v, next){\n    this.value = v;\n    this.next = next || null;\n  }\n}\n\nclass customStack{\n  stack = {\"head\": null, \"tail\": null};\n\n  push(v){\n    // let n = new stackNode(v);\n    // or\n    let n = new stackNode(v, this.stack.head);\n    \n\n    if(this.stack.tail == null){\n      this.stack.head = n;\n      this.stack.tail = n;\n    } else {\n      // let currentHead = this.stack.head;\n      // n.next = currentHead;\n      // this.stack.head = n;\n\n      // or \n      this.stack.head = n;\n    }\n  }\n\n  pop(){\n    if(this.stack.head){\n      let current = this.stack.head.value;\n      let first = this.stack.head.next;\n      this.stack.head = first;\n      return current;\n    } else {\n      if(this.stack.tail) this.stack.tail = null;\n      return \"Not having any value to pop\"\n    }\n  }\n\n  get(){\n    let res = [];\n    let head = this.stack && this.stack.head;\n    while(head){\n      res.push(head.value);\n      head = head.next\n    }\n    return res;\n  }\n}\n\nlet st = new customStack();\n\nst.push(1);\nst.push(2);\nst.push(3);\nconsole.log(\"pop ::\", st.pop());\nst.push(4);\nst.push(5);\n\nconsole.log(\"st ::\", st);\n\nconsole.log(\"stack ::\", st.get());",
      "diff": 1,
      "imp": 1,
      "cate": [
        "queueStack",
        "linked-list"
      ],
      "id": 37
    },
    {
      "subject": "algo",
      "title": "Maximum room required",
      "ques": "",
      "links": [],
      "tags": [
        {
          "name": "General"
        }
      ],
      "ans": "function maxRoom(A){\n         console.log(\"*** A ::\", A);\n         const dt = A.sort((a, b) => {\n             return a[0] - b[0]\n         });\n         console.log(\"### sorted A ::\", dt);\n         let another = [dt[0]]\n         let tot = 1;\n        for(let i=1, l=dt.length; i<l; i++){\n            let last = another[another.length - 1];\n            let current = dt[i];\n\n            if(current[0] <= last[1]){\n                //tot = tot + 1;\n                //another.push(current);\n                last[1] = Math.max(last[1], current[1]);\n            } else {\n                another.push(current);\n            }\n\n        }\n\n        return another;\n\n\t}\n\n\nlet test1 = [\n  [1, 18],\n  [18, 23],\n  [15, 29],\n  [4, 15],\n  [2, 11],\n  [5, 13]\n]\n\nlet test2 = [ [0, 30],\n            [5, 10],\n            [15, 20]\n         ];\nconsole.log(maxRoom(test1));",
      "diff": 1,
      "imp": 1,
      "cate": [
        "arr",
        "sort"
      ],
      "id": 38
    },
    {
      "subject": "algo",
      "title": "Crop String message",
      "ques": "Write a method(CropMessage) that will accept two arguments i.e. string message and size to be cropped. The final method will return a string in such a way that none of the words will be partially cropped",
      "links": [],
      "tags": [
        {
          "name": "Toptal"
        }
      ],
      "ans": "/*\n CropMessage(\"Hello World\", 8) ==> \"Hello\"\n CropMessage(\"Hello World\", 11) ===> \"Hello World\"\n*/\n\n\nfunction cropMessage(message, K) {\n    // write your code in JavaScript (Node.js 8.9.4)\n    let croppedMessage = message.slice(0, K);\n    let lastChar = croppedMessage[croppedMessage.length - 1]\n    if(lastChar === \" \" || (message[croppedMessage.length] && message[croppedMessage.length] !== \" \") ){\n        let lastSpaceIndex = croppedMessage.lastIndexOf(\" \");\n        croppedMessage = croppedMessage.slice(0, lastSpaceIndex);\n    }\n\n    return croppedMessage;\n}\n\nconsole.log(cropMessage(\"Hello World\", 10))",
      "diff": 1,
      "imp": 1,
      "cate": [
        "str"
      ],
      "id": 39
    },
    {
      "subject": "algo",
      "title": "Minimum no. of cars",
      "ques": "Write a method that accepts two arguments - totalSeatRequired and array of the car with no. of seats. It will return minimum no. of cars needed to accommodate all seats",
      "links": [],
      "tags": [
        {
          "name": "Toptal"
        }
      ],
      "ans": "/*\n  getMinSeats(6, [1,5,1]). ==> 2\n*/\n\nfunction solution2(P, S) {\n    // write your code in JavaScript (Node.js 8.9.4)\n    function maxValue(arr){\n        return arr.reduce((max, val) => max > val ? max : val);\n    }\n\n    let totalSeatRequired = P.reduce((s, p) => { return p+s;}, 0);\n    let minCarNeeded = 0;\n    while(totalSeatRequired > 0){\n        let max = maxValue(S);\n        let maxIdx = S.indexOf(max);\n        minCarNeeded += 1;\n        totalSeatRequired -= max;\n        S.splice(maxIdx, 1);\n    }\n    return minCarNeeded;\n}\n\nconsole.log(solution2([1,4,1], [1,5,1]))",
      "diff": 1,
      "imp": 1,
      "cate": [
        "greed"
      ],
      "id": 40
    },
    {
      "subject": "algo",
      "title": "Minimum no of chimney filter",
      "ques": "There is an array containing the amount of pollution released from each factory. Installing a filter will reduce the pollution by 50%. what will be minimum no. of filters required to reduce overall pollution by half",
      "links": [],
      "tags": [
        {
          "name": "Toptal"
        }
      ],
      "ans": "/*\n    getMinFilters([5, 19, 8, 1]) ===> 3\n*/\n\nfunction getMinFilters(A) {\n    function findMax(ar){\n        let max = 0, idx = 0;\n        for(let i=0; i<ar.length;i++){\n            if(ar[i]>max){\n                max=ar[i];\n                idx = i;\n            }\n        }\n        return {\"v\" : max, \"idx\": idx}\n    }\n    let totalPollution = A.reduce((s, p) => { return p+s;}, 0);\n    let minPoll = totalPollution / 2;\n    let minFilter = 0;\n\n    while(totalPollution > minPoll){\n        let maxResult = findMax(A);\n        console.log(\"maxResult ::\", maxResult);\n        A.splice(maxResult.idx, 1, ((maxResult.v)/2));\n        minFilter += 1;\n        totalPollution -= (maxResult.v)/2\n    }\n    return minFilter;\n}\n\nconsole.log(getMinFilters([5, 19, 8, 1]));",
      "diff": 1,
      "imp": 1,
      "cate": [
        "greed"
      ],
      "id": 41
    },
    {
      "subject": "algo",
      "title": "Flatten a JSON object",
      "ques": "",
      "links": [],
      "tags": [
        {
          "name": "General"
        },
        {
          "name": "Goldman sachs"
        }
      ],
      "ans": "//object 1\nvar d1 = {\n    name: 'test',\n    ar: [1,2, [3,4,[5,6, [7]]]],\n    config: { },\n    prev: { name: 'test1.1',\n        config: { },\n        prev: {\n            name: 'test1.1.1',\n            config: {  },\n            prev: { name: 'test1.1.1.1', config: { }, prev: undefined }\n        }\n    }\n};\n\nvar d2 = [1,2, [3,4,[5,6, [7]]]]\n\nfunction flattenObj(ob){\n    let finalObj = [];\n    let extractValue = (obj) => {\n        for(let p in obj){\n            if(typeof(obj[p]) == \"object\"){ // both array & object\n                extractValue(obj[p]);\n            } else {\n                if(Array.isArray(obj)){\n                   finalObj.push(obj[p]);\n                } else{\n                    let _ob = {};\n                   _ob[p] = obj[p]; \n                   finalObj.push(_ob); \n                }\n            }\n        }\n       \n    }\n\n    extractValue(ob);\n    return finalObj;\n}\n\nflattenObj(d1);",
      "diff": 1,
      "imp": 1,
      "cate": [
        "arr",
        "obj"
      ],
      "id": 42
    },
    {
      "subject": "algo",
      "title": "Check if no. is prime",
      "ques": "",
      "links": [],
      "tags": [
        {
          "name": "General"
        }
      ],
      "ans": "const isPrime = num => {\n    for(let i = 2, s = Math.sqrt(num); i <= s; i++)\n        if(num % i === 0) return false; \n    return num > 1;\n}\n\nisPrime(11)",
      "diff": 1,
      "imp": 1,
      "cate": [
        "numbers"
      ],
      "id": 43
    },
    {
      "subject": "algo",
      "title": "Possible denominaions",
      "ques": "",
      "links": [],
      "tags": [
        {
          "name": "Toptal"
        }
      ],
      "ans": "// 1c, 5c, 10c, 25c, 50c, and $1\n\n\nconst getChange = (M, P) => {\n    const denominations = [1, 5, 10, 25, 50]; \n\n    let changeAmount = (M-P).toFixed(2).split(\".\");\n    //console.log(\"changeAmount ::\", changeAmount);\n    const dollarAmt = Number(changeAmount[0]);\n    const centAmt = Number(changeAmount[1]);\n\n    console.log(\"dollarAmt :: centAmt ::\", dollarAmt, \"::\",centAmt);\n    \n    let finalalDeno = [];\n    let centLeft = centAmt;\n\n//***************************************************\n\n\n    let idx = 4;\n    while(idx >= 0){\n       let deno = denominations[idx]\n       if(deno <= centLeft && centLeft > 0){\n            let qty = Math.floor(centLeft/deno);\n            centLeft = centLeft - (deno * qty);\n            finalalDeno.unshift(qty);\n       } else {\n            finalalDeno.unshift(0); \n       }\n       idx = idx - 1;\n    }\n\n\n//********************* OR ***********************\n\n\n//     for(let i=(denominations.length - 1); i >= 0; i--){\n//             let deno = denominations[i]\n//            if(deno <= centLeft && centLeft > 0){\n//                 let qty = Math.floor(centLeft/deno);\n//                 centLeft = centLeft - (deno * qty);\n//                 finalalDeno.unshift(qty);\n//            } else {\n//                 finalalDeno.unshift(0); \n//            }\n//     }\n\n\n//***************************************************\n\n    finalalDeno.push(dollarAmt)\n    console.log(\"*** finalalDeno *** ::\", finalalDeno);\n}\n\ngetChange(5, 0.99) // should return [1,0,0,0,0,4]\ngetChange(3.14, 1.99) // should return [0,1,1,0,0,1]\ngetChange(3, 0.01) // should return [4,0,2,1,1,2]\ngetChange(4, 3.14) // should return [1,0,1,1,1,0]\ngetChange(0.45, 0.34) // should return [1,0,1,0,0,0]",
      "diff": 1,
      "imp": 1,
      "cate": [
        "greed"
      ],
      "id": 44
    },
    {
      "subject": "algo",
      "title": "Given a number, find its corresponding Roman numeral",
      "ques": "Converting Decimal Number lying between 1 to 3999 to Roman Numerals",
      "links": [
        {
          "name": "https://www.geeksforgeeks.org/converting-decimal-number-lying-between-1-to-3999-to-roman-numerals/"
        }
      ],
      "tags": [
        {
          "name": "Oracle"
        }
      ],
      "ans": "/*\nint num[] = {1,4,5,9,10,40,50,90,100,400,500,900,1000};\nstring sym[] = {\"I\",\"IV\",\"V\",\"IX\",\"X\",\"XL\",\"L\",\"XC\",\"C\",\"CD\",\"D\",\"CM\",\"M\"};\n*/",
      "diff": 1,
      "imp": 1,
      "cate": [
        "arr",
        "obj"
      ],
      "id": 45
    },
    {
      "subject": "algo",
      "title": "Trapping Rain Water between Towers Problem",
      "ques": "We have an array where each element represents height of a tower. If it starts raining, what is the amount of water that can be collected between the towers? Assumption is that the width of every tower is 1.",
      "links": [
        {
          "name": "https://www.youtube.com/watch?v=KV-Eq3wYjxI&ab_channel=IDeserve"
        },
        {
          "name": "https://leetcode.com/problems/trapping-rain-water/?envType=list&envId=9sk6s9xj"
        }
      ],
      "tags": [
        {
          "name": "Oracle"
        },
        {
          "name": "Leetcode"
        }
      ],
      "ans": "/*\n[1,5,2,3,1,7,2] – then answer is 11 units.\n*/",
      "diff": 5,
      "imp": 1,
      "cate": [
        "arr"
      ],
      "id": 46
    },
    {
      "subject": "algo",
      "title": "Buildings With an Ocean View",
      "ques": "There are n buildings in a line. You are given an integer array heights of size n that represents the heights of the buildings in the line.\n\nThe ocean is to the right of the buildings. A building has an ocean view if the building can see the ocean without obstructions. Formally, a building has an ocean view if all the buildings to its right have a smaller height.\n\nReturn a list of indices (0-indexed) of buildings that have an ocean view, sorted in increasing order.",
      "links": [
        {
          "name": "https://leetcode.com/problems/buildings-with-an-ocean-view"
        }
      ],
      "tags": [
        {
          "name": "Leetcode"
        },
        {
          "name": "Microsoft"
        }
      ],
      "ans": "/*\nExample 1:\n\nInput: heights = [4,2,3,1]\nOutput: [0,2,3]\nExplanation: Building 1 (0-indexed) does not have an ocean view because building 2 is taller.\nExample 2:\n\nInput: heights = [4,3,2,1]\nOutput: [0,1,2,3]\nExplanation: All the buildings have an ocean view.\nExample 3:\n\nInput: heights = [1,3,2,4]\nOutput: [3]\nExplanation: Only building 3 has an ocean view.\n*/\n\nvar findBuildings = function(heights) {    \n    if(heights.length == 0) return [];\n    \n    let buildingIdx = [];\n    let maxSoFar = 0;\n    for(let i= (heights.length - 1); i >=0; i--){\n        if(heights[i] > maxSoFar) {\n            buildingIdx.push(i)\n            maxSoFar = heights[i];\n        };\n    }\n    \n    return buildingIdx.reverse();\n};",
      "diff": 3,
      "imp": 3,
      "cate": [
        "arr",
        "queueStack"
      ],
      "id": 47
    },
    {
      "subject": "algo",
      "title": " Minimum Add to Make Parentheses Valid",
      "ques": "A parentheses string is valid if and only if:\n\nIt is the empty string,\nIt can be written as AB (A concatenated with B), where A and B are valid strings, or\nIt can be written as (A), where A is a valid string.\nYou are given a parentheses string s. In one move, you can insert a parenthesis at any position of the string.\n\nFor example, if s = \"()))\", you can insert an opening parenthesis to be \"(()))\" or a closing parenthesis to be \"())))\".\nReturn the minimum number of moves required to make s valid.",
      "links": [
        {
          "name": "https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/"
        }
      ],
      "tags": [
        {
          "name": "Microsoft"
        },
        {
          "name": "Leetcode"
        }
      ],
      "ans": "/*\nExample 1:\n\nInput: s = \"())\"\nOutput: 1\nExample 2:\n\nInput: s = \"(((\"\nOutput: 3\n*/\n\nvar minAddToMakeValid = function(s) {\n   let open = 0, close = 0;\n   for(let i=0; i<s.length; i++){\n       if(s[i] == \"(\"){\n          open = open + 1;\n        } else {\n            if(open > 0){\n                open = open - 1;\n            } else {\n                close = close + 1;\n            } \n        }\n   }\n    \n   return open + close;\n};",
      "diff": 3,
      "imp": 3,
      "cate": [
        "str",
        "greed",
        "queueStack"
      ],
      "id": 48
    },
    {
      "subject": "algo",
      "title": "Single linked list - basics (ES6) :",
      "ques": "",
      "links": [
        {
          "name": "https://medium.com/swlh/singly-linked-list-in-javascript-a0e58d045561"
        },
        {
          "name": "https://codeburst.io/linked-lists-in-javascript-es6-code-part-1-6dd349c3dcc3"
        }
      ],
      "tags": [
        {
          "name": "General"
        }
      ],
      "ans": "\nclass LinkedList{\n\n  constructor(d){\n    this.data = d;\n    this.next = null\n  }\n\n  add(d){\n    let head = this;\n    while(head.next){\n      head = head.next;\n    }\n    head.next = new LinkedList(d);\n  }\n\n  remove(idx){\n    if(!idx){\n      let head = this.next;\n      this.data = head.data;\n      this.next = head.next;\n    } \n\n    if(idx){\n      let i=0;\n      let head = this;\n      while(i < (idx-1) && head.next){\n        head = head.next;\n        i = i + 1;\n      }\n\n      if(head && head.next){\n        if(idx > 0 ){\n          head.next = head.next.next; \n        } else{\n          head.next = head.next;\n        }\n      }\n            \n    }\n    \n  }\n\n  traverse(){\n    let idx = 0;\n    let head = this;\n    while(head.next){\n      console.log(idx +\" : \"+head.data);\n      head = head.next;\n      idx = idx + 1;\n    }\n    console.log(idx +\" : \"+head.data);\n  }\n}\n\nlet ll = new LinkedList(1);\nll.add(2);\nll.add(3);\nll.add(4);\nll.add(5);\nll.add(6);\n\n// ll.remove();\n// ll.remove();\nll.remove(2);\n\nll.traverse();\nconsole.log(ll);",
      "diff": 1,
      "imp": 1,
      "cate": [
        "linked-list"
      ],
      "id": 49
    },
    {
      "subject": "algo",
      "title": "Minimum Deletions to Make Character Frequencies Unique",
      "ques": "A string s is called good if there are no two different characters in s that have the same frequency.\n\nGiven a string s, return the minimum number of characters you need to delete to make s good.\n\nThe frequency of a character in a string is the number of times it appears in the string. For example, in the string \"aab\", the frequency of 'a' is 2, while the frequency of 'b' is 1.",
      "links": [
        {
          "name": "https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/submissions/"
        }
      ],
      "tags": [
        {
          "name": "Leetcode"
        },
        {
          "name": "Microsoft"
        }
      ],
      "ans": "/*\nExample 1:\n\nInput: s = \"aab\"\nOutput: 0\nExplanation: s is already good.\nExample 2:\n\nInput: s = \"aaabbbcc\"\nOutput: 2\nExplanation: You can delete two 'b's resulting in the good string \"aaabcc\".\nAnother way it to delete one 'b' and one 'c' resulting in the good string \"aaabbc\".\nExample 3:\n\nInput: s = \"ceabaacb\"\nOutput: 2\nExplanation: You can delete both 'c's resulting in the good string \"eabaab\".\nNote that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored).\n*/\n\n\nvar minDeletions = function(s) {\n    console.log(\"s ::\", s); \n    let sMap = {};\n    for(let i=0; i<s.length; i++){\n        sMap[s[i]] = (s[i] in sMap) ? sMap[s[i]] + 1 :  1;\n    }\n    console.log(\"sMap ::\", sMap); \n    \n   let fMap = {}; \n   let count = 0;\n    \n   const recurse = () => {\n        let fMap = {};\n         for(let key in sMap){\n              let f = sMap[key];\n              if((f in fMap)){\n                  count = count + 1;\n                  if(sMap[key] > 1){\n                     sMap[key] = sMap[key] - 1;\n                  }else {\n                      delete sMap[key];\n                  }\n                  recurse();\n                  break;\n              } else {\n                  fMap[f] = 1;\n              }\n         }  \n   }\n   \n    \n  recurse();\n  return count;\n    \n};\n",
      "diff": 1,
      "imp": 1,
      "cate": [
        "str",
        "sort"
      ],
      "id": 50
    },
    {
      "subject": "algo",
      "title": "1304. Find N Unique Integers Sum up to Zero",
      "ques": "Given an integer n, return any array containing n unique integers such that they add up to 0.",
      "links": [
        {
          "name": "https://leetcode.com/problems/find-n-unique-integers-sum-up-to-zero/"
        }
      ],
      "tags": [
        {
          "name": "Microsoft"
        },
        {
          "name": "Leetcode"
        }
      ],
      "ans": "/*\nExample 1:\n\nInput: n = 5\nOutput: [-7,-1,1,3,4]\nExplanation: These arrays also are accepted [-5,-1,1,2,3] , [-3,-1,2,-2,4].\nExample 2:\n\nInput: n = 3\nOutput: [-1,0,1]\nExample 3:\n\nInput: n = 1\nOutput: [0]\n \n*/\n\nvar sumZero = function(n) {\n    let a = [];\n\n     a.push((n % 2 == 0) ? -1 : 0); \n    \n    for(let i=1; i<n; i++){\n        a.push((a[i-1] < 0 ) ? (-(a[i-1])) : -(a[i-1] + 1));\n    }\n    \n    return a;\n};",
      "diff": 1,
      "imp": 1,
      "cate": [
        "arr"
      ],
      "id": 51
    },
    {
      "subject": "algo",
      "title": " Median of Two Sorted Arrays",
      "ques": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).\n",
      "links": [
        {
          "name": "https://leetcode.com/problems/median-of-two-sorted-arrays/"
        }
      ],
      "tags": [
        {
          "name": "Leetcode"
        }
      ],
      "ans": "/*\nExample 1:\n\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.\nExample 2:\n\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n*/\n\n/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nvar findMedianSortedArrays = function(nums1, nums2) {\n    console.log(\"nums1, nums2 ::\", nums1, \"::\",nums2);\n    let nums = [];\n    let idx1 = 0, idx2 = 0;\n    \n  while(idx1 < nums1.length || idx2 < nums2.length){\n        if(nums1[idx1] != undefined && nums2[idx2] == undefined){\n           nums.push(nums1[idx1]);\n           idx1 = idx1 + 1; \n        }\n        \n        if(nums1[idx1] == undefined && nums2[idx2] != undefined){\n           nums.push(nums2[idx2]);\n           idx2 = idx2 + 1; \n        }\n        \n        if(nums1[idx1] != undefined && nums2[idx2] != undefined){\n           if(nums1[idx1] < nums2[idx2]){\n              nums.push(nums1[idx1]);\n              idx1 = idx1 + 1; \n           } else {\n              nums.push(nums2[idx2]);\n              idx2 = idx2 + 1;  \n           }\n        }   \n    }\n    \n    console.log(\"nums ::\", nums);\n    \n    if(nums.length % 2 == 0){\n       let idx = nums.length/2;\n       return (nums[idx-1] + nums[idx])/2; \n    } else {\n        return nums[Math.floor(nums.length/2)];\n    }\n};",
      "diff": 5,
      "imp": 4,
      "cate": [
        "arr",
        "search",
        "sort"
      ],
      "id": 52
    },
    {
      "subject": "algo",
      "title": "how convert json to flat array and flat array to json in javascript?",
      "ques": "",
      "links": [],
      "tags": [
        {
          "name": "JS"
        }
      ],
      "ans": "To convert a JSON object to a flat array in JavaScript, you can use recursion to traverse the object and flatten it. Here's an example of how you can accomplish that:\n\n```javascript\nfunction flattenObject(obj) {\n  let result = [];\n\n  function flatten(obj, path = '') {\n    for (let key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        let newPath = path ? `${path}.${key}` : key;\n        if (typeof obj[key] === 'object' && !Array.isArray(obj[key])) {\n          flatten(obj[key], newPath);\n        } else {\n          result.push({ key: newPath, value: obj[key] });\n        }\n      }\n    }\n  }\n\n  flatten(obj);\n  return result;\n}\n\n// Example usage:\nconst jsonObject = {\n  name: 'John Doe',\n  age: 30,\n  address: {\n    street: '123 Main St',\n    city: 'New York',\n    country: 'USA'\n  }\n};\n\nconst flatArray = flattenObject(jsonObject);\nconsole.log(flatArray);\n```\n\nThe `flattenObject` function takes a JSON object as input and recursively traverses it. It checks if a property's value is an object (but not an array) and recursively calls `flatten` with the updated path. When it encounters a non-object property, it pushes an object with `key` and `value` properties representing the flattened key-value pair into the `result` array.\n\nTo convert a flat array back to a JSON object, you can iterate over the array and reconstruct the object structure using the keys. Here's an example:\n\n```javascript\nfunction unflattenArray(flatArray) {\n  let result = {};\n\n  flatArray.forEach(item => {\n    const keys = item.key.split('.');\n    let tempObj = result;\n\n    keys.forEach((key, index) => {\n      if (!tempObj.hasOwnProperty(key)) {\n        tempObj[key] = {};\n      }\n\n      if (index === keys.length - 1) {\n        tempObj[key] = item.value;\n      } else {\n        tempObj = tempObj[key];\n      }\n    });\n  });\n\n  return result;\n}\n\n// Example usage:\nconst flatArray = [\n  { key: 'name', value: 'John Doe' },\n  { key: 'age', value: 30 },\n  { key: 'address.street', value: '123 Main St' },\n  { key: 'address.city', value: 'New York' },\n  { key: 'address.country', value: 'USA' }\n];\n\nconst jsonObject = unflattenArray(flatArray);\nconsole.log(jsonObject);\n```\n\nThe `unflattenArray` function iterates over each item in the flat array. It splits the key by dot (.) to get the nested structure. It then reconstructs the object hierarchy by creating nested objects as needed and assigns the value to the final key.\n\nNote that the above examples assume a simple JSON object structure without circular references or complex data types. Adjustments may be necessary depending on your specific use case.",
      "diff": 1,
      "imp": 1,
      "cate": [
        "javascript"
      ],
      "id": 53
    },
    {
      "subject": "algo",
      "title": "How to create deep copy of json in javascript?",
      "ques": "",
      "links": [
        {
          "name": "https://stackblitz.com/edit/js-5yxqbh?file=index.js,index.html"
        }
      ],
      "tags": [
        {
          "name": "JS"
        }
      ],
      "ans": "To create a deep copy of an object in JavaScript, you can write a program from scratch using recursion to traverse the object and clone its properties and nested objects. Here's an example:\n\n```javascript\nfunction deepCopy(obj) {\n  if (obj === null || typeof obj !== 'object') {\n    return obj;\n  }\n\n  let clone = Array.isArray(obj) ? [] : {};\n\n  for (let key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      clone[key] = deepCopy(obj[key]);\n    }\n  }\n\n  return clone;\n}\n\n// Example usage:\nconst originalObj = {\n  name: 'John Doe',\n  age: 30,\n  address: {\n    street: '123 Main St',\n    city: 'New York',\n    country: 'USA'\n  },\n  hobbies: ['reading', 'gaming']\n};\n\nconst copiedObj = deepCopy(originalObj);\nconsole.log(copiedObj);\n```\n\nIn the `deepCopy` function, we check if the input `obj` is null or not an object. If it's not an object (e.g., a primitive value), we return it as is. If it's an object, we create a new empty object (`clone`) or an empty array based on the original object's type.\n\nWe then iterate over the properties of the original object using a `for...in` loop. For each property, we recursively call `deepCopy` on the value to clone any nested objects or arrays.\n\nBy using recursion, the `deepCopy` function ensures that all levels of the object are cloned, resulting in a new object that is a deep copy of the original object.\n\nNote that this implementation assumes a simple object structure without circular references or complex data types. Adjustments may be necessary depending on your specific use case. Additionally, this implementation does not preserve any non-enumerable properties or prototype chains associated with the original object.",
      "diff": 1,
      "imp": 1,
      "cate": [
        "javascript"
      ],
      "id": 54
    },
    {
      "subject": "algo",
      "title": "700. Search in a Binary Search Tree",
      "ques": "",
      "links": [
        {
          "name": "https://leetcode.com/problems/search-in-a-binary-search-tree/description/"
        }
      ],
      "tags": [],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 55
    },
    {
      "subject": "algo",
      "title": "42. Trapping Rain Water",
      "ques": "",
      "links": [
        {
          "name": "https://leetcode.com/problems/trapping-rain-water/description/"
        }
      ],
      "tags": [],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 56
    },
    {
      "subject": "algo",
      "title": "2096. Step-By-Step Directions From a Binary Tree Node to Another",
      "ques": "",
      "links": [
        {
          "name": "https://leetcode.com/problems/step-by-step-directions-from-a-binary-tree-node-to-another"
        }
      ],
      "tags": [],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 57
    },
    {
      "subject": "algo",
      "title": "Integer to Roman",
      "ques": "",
      "links": [
        {
          "name": "https://leetcode.com/problems/integer-to-roman/?envType=list&envId=9sk6s9xj"
        }
      ],
      "tags": [
        {
          "name": "Leetcode"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 58
    },
    {
      "subject": "algo",
      "title": "Swap Nodes in Pairs",
      "ques": "",
      "links": [
        {
          "name": "https://leetcode.com/problems/swap-nodes-in-pairs/?envType=list&envId=9sk6s9xj"
        }
      ],
      "tags": [
        {
          "name": "Leetcode"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 59
    },
    {
      "subject": "algo",
      "title": "Linked List Cycle",
      "ques": "",
      "links": [
        {
          "name": "https://leetcode.com/problems/linked-list-cycle/?envType=list&envId=9sk6s9xj"
        }
      ],
      "tags": [
        {
          "name": "Leetcode"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 60
    },
    {
      "subject": "algo",
      "title": "Reverse Linked List",
      "ques": "",
      "links": [
        {
          "name": "https://leetcode.com/problems/reverse-linked-list/?envType=list&envId=9sk6s9xj"
        }
      ],
      "tags": [
        {
          "name": "Leetcode"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 61
    },
    {
      "subject": "algo",
      "title": "Reverse String",
      "ques": "",
      "links": [
        {
          "name": "https://leetcode.com/problems/reverse-string/?envType=list&envId=9sk6s9xj"
        }
      ],
      "tags": [
        {
          "name": "Leetcode"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 62
    },
    {
      "subject": "algo",
      "title": "415. Add Strings",
      "ques": "",
      "links": [
        {
          "name": "https://leetcode.com/problems/add-strings/?envType=list&envId=9sk6s9xj"
        }
      ],
      "tags": [
        {
          "name": "Leetcode"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 63
    },
    {
      "subject": "algo",
      "title": "700. Search in a Binary Search Tree",
      "ques": "",
      "links": [
        {
          "name": "https://leetcode.com/problems/search-in-a-binary-search-tree/?envType=list&envId=9sk6s9xj"
        }
      ],
      "tags": [
        {
          "name": "Leetcode"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 64
    },
    {
      "subject": "algo",
      "title": "202. Happy Number",
      "ques": "",
      "links": [
        {
          "name": "https://leetcode.com/problems/happy-number/?envType=list&envId=emyyi7m2"
        }
      ],
      "tags": [
        {
          "name": "Leetcode"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 65
    },
    {
      "subject": "algo",
      "title": "700. Search in a Binary Search Tree",
      "ques": "",
      "links": [
        {
          "name": "https://leetcode.com/problems/search-in-a-binary-search-tree/?envType=list&envId=emyyi7m2"
        }
      ],
      "tags": [
        {
          "name": "Leetcode"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 66
    },
    {
      "subject": "algo",
      "title": "1. Two Sum",
      "ques": "",
      "links": [
        {
          "name": "https://leetcode.com/problems/two-sum/?envType=list&envId=emyyi7m2"
        }
      ],
      "tags": [
        {
          "name": "Leetcode"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 67
    },
    {
      "subject": "algo",
      "title": "319. Bulb Switcher",
      "ques": "",
      "links": [
        {
          "name": "https://leetcode.com/problems/bulb-switcher/?envType=list&envId=rosqqj7g"
        }
      ],
      "tags": [
        {
          "name": "Leetcode"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 68
    },
    {
      "subject": "algo",
      "title": "5. Longest Palindromic Substring",
      "ques": "",
      "links": [
        {
          "name": "https://leetcode.com/problems/longest-palindromic-substring/?envType=list&envId=rozod5s3"
        }
      ],
      "tags": [
        {
          "name": "Leetcode"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 69
    },
    {
      "subject": "algo",
      "title": "22. Generate Parentheses",
      "ques": "",
      "links": [
        {
          "name": "https://leetcode.com/problems/generate-parentheses/?envType=list&envId=rozod5s3"
        }
      ],
      "tags": [
        {
          "name": "Leetcode"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 70
    },
    {
      "subject": "algo",
      "title": "53. Maximum Subarray",
      "ques": "",
      "links": [
        {
          "name": "https://leetcode.com/problems/maximum-subarray/?envType=list&envId=rozod5s3"
        }
      ],
      "tags": [
        {
          "name": "Leetcode"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 71
    },
    {
      "subject": "algo",
      "title": "64. Minimum Path Sum",
      "ques": "",
      "links": [
        {
          "name": "https://leetcode.com/problems/minimum-path-sum/?envType=list&envId=rozod5s3"
        }
      ],
      "tags": [
        {
          "name": "Leetcode"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 72
    },
    {
      "subject": "algo",
      "title": "91. Decode Ways",
      "ques": "",
      "links": [
        {
          "name": "https://leetcode.com/problems/decode-ways/?envType=list&envId=rozod5s3"
        }
      ],
      "tags": [
        {
          "name": "Leetcode"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 73
    },
    {
      "subject": "algo",
      "title": "Letter Combinations of a Phone Number",
      "ques": "",
      "links": [
        {
          "name": "https://leetcode.com/problems/letter-combinations-of-a-phone-number/?envType=list&envId=od6fto9i"
        }
      ],
      "tags": [
        {
          "name": "Leetcode"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 74
    },
    {
      "subject": "algo",
      "title": "41. First Missing Positive",
      "ques": "",
      "links": [
        {
          "name": "https://leetcode.com/problems/first-missing-positive/?envType=list&envId=or4pmjl5"
        }
      ],
      "tags": [
        {
          "name": "Leetcode"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 75
    },
    {
      "subject": "algo",
      "title": "198. House Robber",
      "ques": "",
      "links": [
        {
          "name": "https://leetcode.com/problems/house-robber/?envType=list&envId=evmfrfbe"
        }
      ],
      "tags": [
        {
          "name": "Leetcode"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 76
    },
    {
      "subject": "algo",
      "title": "746. Min Cost Climbing Stairs",
      "ques": "",
      "links": [
        {
          "name": "https://leetcode.com/problems/min-cost-climbing-stairs/?envType=list&envId=evmfrfbe"
        }
      ],
      "tags": [
        {
          "name": "Leetcode"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 77
    },
    {
      "subject": "algo",
      "title": "Matching Pairs",
      "ques": "\"\"\"\nYou are given a 0-indexed string array words.\n\nTwo strings are similar if they consist of the same characters.\n\nFor example, \"abca\" and \"cba\" are similar since both consist of characters 'a', 'b', and 'c'.\nHowever, \"abacba\" and \"bcfd\" are not similar since they do not consist of the same characters.\nReturn the number of pairs (i, j) such that 0 <= i < j <= word.length - 1 and the two strings words[i] and words[j] are similar.\n\n \n\nExample 1:\n\nInput: words = [\"aba\",\"aabb\",\"abcd\",\"bac\",\"aabc\"]\nOutput: 2\nExplanation: There are 2 pairs that satisfy the conditions:\n- i = 0 and j = 1 : both words[0] and words[1] only consist of characters 'a' and 'b'. \n- i = 3 and j = 4 : both words[3] and words[4] only consist of characters 'a', 'b', and 'c'. \nExample 2:\n\nInput: words = [\"aabb\",\"ab\",\"ba\"]  -- [\"aabb\",\"ab\",\"ba\", \"abac\",\"aabbc\"]\nOutput: 3\nExplanation: There are 3 pairs that satisfy the conditions:\n- i = 0 and j = 1 : both words[0] and words[1] only consist of characters 'a' and 'b'. \n- i = 0 and j = 2 : both words[0] and words[2] only consist of characters 'a' and 'b'.\n- i = 1 and j = 2 : both words[1] and words[2] only consist of characters 'a' and 'b'.\nExample 3:\n\nInput: words = [\"nba\",\"cba\",\"dba\"]\nOutput: 0\nExplanation: Since there does not exist any pair that satisfies the conditions, we return 0.\n \n\nConstraints:\n\n1 <= words.length <= 100\n1 <= words[i].length <= 100\nwords[i] consist of only lowercase English letters.\n\"\"\"\n\n\ndef similarPairs(words: list) -> int:\n    pass\n        \n    \nprint(similarPairs([\"aba\",\"aabb\",\"abcd\",\"bac\",\"aabc\"]))",
      "links": [
        {
          "name": "https://onecompiler.com/python/3z9my8vpq"
        },
        {
          "name": "https://onecompiler.com/javascript/3zdqtpyk4"
        }
      ],
      "tags": [
        {
          "name": "cisco"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": [
        "str",
        "arr"
      ],
      "id": 78
    }
  ],
  "js": [
    {
      "subject": "js",
      "title": "Throttling and Debouncing in JavaScript",
      "ques": "",
      "links": [
        {
          "name": "https://codeburst.io/throttling-and-debouncing-in-javascript-b01cad5c8edf"
        },
        {
          "name": "https://stackblitz.com/edit/js-justrw?file=index.js"
        },
        {
          "name": "https://stackblitz.com/edit/stackblitz-starters-i9judn"
        }
      ],
      "tags": [
        {
          "name": "Debouncing and Throttling"
        }
      ],
      "ans": "\n-> Throttling and debouncing give us control over the rate at which a function is called. \n\n-> They are especially useful when we are dealing with event handler assignments. There are scenarios where we may invoke functions when it isn’t necessary.\n\n\n\n==\n\n\n<input type=\"text\" id=\"search\" placeholder=\"search ..\"> <br/> <br/> <br/>\n<input type=\"text\" id=\"dsearch\" placeholder=\"Debounce Search ..\"> <br/> <br/> <br/>\n<input type=\"text\" id=\"tsearch\" placeholder=\"Throttle Search ..\">\n\n--------\n\nconst fn1 = (e) => { console.log(e.target.value); };\n\nconst debounce = (consFn, delay) => {\n  let timeout;\n  \n  return function(){\n    let context = this;\n    let args = arguments;\n    \n    clearTimeout(timeout);\n    timeout = setTimeout(() => {\n      consFn.apply(context, args);\n    }, delay);\n  }\n}\n\nconst throttle = (consFn, delay) => {\n  let inThrottle = true;\n  \n  return function(){\n    let context = this;\n    let args = arguments;\n    \n    if(inThrottle){\n      consFn.apply(context, args);\n      inThrottle = false;\n      setTimeout(() => {\n        inThrottle = true;\n      }, delay)\n    }\n  }\n}\n\ndocument.querySelector(\"#search\").addEventListener(\"keyup\", fn1);\n\ndocument.querySelector(\"#dsearch\").addEventListener(\"keyup\", debounce(fn1, 1000));\n\ndocument.querySelector(\"#tsearch\").addEventListener(\"keyup\", throttle(fn1, 1000));\n",
      "diff": 4,
      "imp": 4,
      "cate": [
        "Events"
      ],
      "id": 1
    },
    {
      "subject": "js",
      "title": "JS: Basics and Tricky Questions",
      "ques": "",
      "links": [
        {
          "name": "http://www.thatjsdude.com/interview/js2.html#nullVsUndefined"
        }
      ],
      "tags": [
        {
          "name": "Basics & Tricky"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": [
        "General"
      ],
      "id": 2
    },
    {
      "subject": "js",
      "title": "Practical Uses for Closures",
      "ques": "",
      "links": [
        {
          "name": "https://medium.com/@dis_is_patrick/practical-uses-for-closures-c65640ae7304#.fva9ii8od"
        },
        {
          "name": "https://www.youtube.com/watch?v=-xqJo5VRP4A&ab_channel=techsith"
        }
      ],
      "tags": [
        {
          "name": "closures"
        }
      ],
      "ans": "function pam() {\n    var name = \"Pam Beesly\";\n    function displayName() {\n        alert (name);\n    }\n    displayName(); \n}\npam();\n",
      "diff": 3,
      "imp": 4,
      "cate": [
        "general"
      ],
      "id": 3
    },
    {
      "subject": "js",
      "title": "JavaScript scope",
      "ques": "Everything you wanted to know about JavaScript scope",
      "links": [
        {
          "name": "https://ultimatecourses.com/blog/everything-you-wanted-to-know-about-javascript-scope"
        }
      ],
      "tags": [
        {
          "name": "scoping"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 3,
      "cate": [
        "general"
      ],
      "id": 4
    },
    {
      "subject": "js",
      "title": "javaScript promises",
      "ques": "",
      "links": [
        {
          "name": "https://www.youtube.com/watch?v=s6SH72uAn3Q#t=6.819927&ab_channel=techsith"
        },
        {
          "name": "https://www.youtube.com/watch?v=104J7_HyaG4&ab_channel=DecypherMedia"
        },
        {
          "name": "https://stackblitz.com/edit/js-k4zgov?file=index.js,index.html"
        }
      ],
      "tags": [
        {
          "name": "Promises"
        }
      ],
      "ans": "\nlet p1 = new Promise((resolve, reject) => {\n  // do async operation then resolve or reject\n  resolve(\"Wake Up\");\n});\n\nlet p2 = new Promise((resolve, reject) => {\n  resolve(\"office\");\n});\n\nlet p3 = new Promise((resolve, reject) => {\n  resolve(\"Sleep\");\n});\n\n\n// p1.then((result) => {\n//   console.log(\"p1 finshed :: result ::\", result);\n//   return p2;\n// }).then((result) => {\n//   console.log(\"p2 finshed :: result ::\", result);\n//   return p3;\n// }).then((result) => {\n//   console.log(\"p3 finshed :: result ::\", result);\n// });\n\n\nlet P1 = function(){\n  return new Promise((resolve, reject) => {\n    // do async operation then resolve or reject\n    resolve(\"Wake Up\");\n  });\n}\n\nlet P2 = function(res){\n  return new Promise((resolve, reject) => {\n    res ? resolve([res, \"Office\"]) : resolve(\"Office\");\n  });\n}\n\nlet P3 = function(res){\n  return new Promise((resolve, reject) => {\n    res ? resolve([...res, ...[\"Sleep\"]]) : resolve(\"Sleep\");\n  });\n}\n\nP1().then((result) => {\n  console.log(\"***P1 finshed :: result ::\", result);\n  return P2(result);\n}).then((result) => {\n  console.log(\"***P2 finshed :: result ::\", result);\n  return P3(result)\n}).then((result) => {\n  console.log(\"***P3 finshed :: result ::\", result);\n});\n\nPromise.all([P1(), P2(), P3()]).then((result) => {\n  console.log(\"Finsished all :: result ::\", result);\n});\n\nPromise.race([P1(), P2(), P3()]).then((result) => {\n  console.log(\"promise race - Finsished once :: result ::\", result);\n});\n\n",
      "diff": 1,
      "imp": 1,
      "cate": [
        "general",
        "Async"
      ],
      "id": 5
    },
    {
      "subject": "js",
      "title": "How new operator works ?",
      "ques": "",
      "links": [
        {
          "name": "https://ianbicking.org/blog/2013/04/new-considered-harmful.html"
        },
        {
          "name": "https://www.liip.ch/en/blog/why-i-dont-use-the-javascript-new-keyword"
        }
      ],
      "tags": [
        {
          "name": "New operator"
        }
      ],
      "ans": "\nfunction new_(constructor /* plus a variable number of arguments */) {\n  var newObject = Object.create(constructor.prototype);\n  // This gets the varargs after `constructor`:\n  var restArgs = Array.prototype.slice.call(arguments, 1);\n  var result = constructor.apply(newObject, restArgs);\n  if (typeof result == \"object\") {\n    // If the function returns something, ignore newObject\n    return result;\n  }\n  return newObject;\n}",
      "diff": 1,
      "imp": 3,
      "cate": [
        "general"
      ],
      "id": 6
    },
    {
      "subject": "js",
      "title": "Shadow Dom in HTML Introduction tutorial",
      "ques": "",
      "links": [
        {
          "name": "https://www.youtube.com/watch?v=SDs4xmMcVS4&ab_channel=techsith"
        },
        {
          "name": "https://css-tricks.com/modular-future-web-components/"
        }
      ],
      "tags": [
        {
          "name": "Shadow DOM"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": [
        "general",
        "DOM"
      ],
      "id": 7
    },
    {
      "subject": "js",
      "title": "What is Functional Programming?",
      "ques": "",
      "links": [
        {
          "name": "https://medium.com/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0"
        },
        {
          "name": "https://www.dropbox.com/scl/fi/j9xepv67cqnn4aup30ek9/Master-the-JavaScript-Interview-What-is-Functional-Programming-by-Eric-Elliott-JavaScript-Scene-Medium.pdf?rlkey=n5tkosre3kja1wuuceclf5fi8&dl=0"
        }
      ],
      "tags": [
        {
          "name": "Functional Programming"
        }
      ],
      "ans": "Functional programming favors:\n\na. Pure functions instead of shared state & side effects\nb. Immutability over mutable data\nc. Function composition over imperative flow control\nd. Lots of generic, reusable utilities that use higher order functions to act on many data types instead of methods that only operate on their colocated data\ne. Declarative rather than imperative code (what to do, rather than how to do it)\nf. Expressions over statements\ng. Containers & higher order functions over ad-hoc polymorphism",
      "diff": 1,
      "imp": 3,
      "cate": [
        "general",
        "Code Pattern"
      ],
      "id": 8
    },
    {
      "subject": "js",
      "title": "Js Eventloop",
      "ques": "",
      "links": [
        {
          "name": "https://blog.carbonfive.com/the-javascript-event-loop-explained/"
        },
        {
          "name": "https://www.youtube.com/watch?v=8aGhZQkoFbQ&ab_channel=JSConf"
        }
      ],
      "tags": [
        {
          "name": "Eventloop"
        }
      ],
      "ans": "// callstack try to finish all exec then async process(cb part) is taking into consideration\nconsole.log(1);\nconsole.log(2)\n\nsetTimeout(() => {\n  console.log(3);  \n});\n\nconsole.log(4);\n\nsetTimeout(() => {\n  console.log(5)  \n});\n\nconsole.log(6);\nconsole.log(7);\nconsole.log(8);\n\n// output \neventLoop:2 1\neventLoop:3 2\neventLoop:9 4\neventLoop:15 6\neventLoop:16 7\neventLoop:17 8\n\neventLoop:6 3\neventLoop:12 5",
      "diff": 1,
      "imp": 4,
      "cate": [
        "general",
        "async"
      ],
      "id": 9
    },
    {
      "subject": "js",
      "title": "JavaScript Design Patterns",
      "ques": "",
      "links": [
        {
          "name": "https://www.digitalocean.com/community/tutorial_series/javascript-design-patterns"
        },
        {
          "name": "https://www.youtube.com/watch?v=PldXoGemkyk&list=PL0iFifR5umck8Dqm51YewHERHUY7-Q2aZ"
        }
      ],
      "tags": [],
      "ans": "a. Factory\nb. Constructor\nb. Moduular & Revealing modular\nd. prototype\ne. Observer design pattern\nf. pub/sub\ng. singleton",
      "diff": 1,
      "imp": 1,
      "cate": [
        "code_pattern"
      ],
      "id": 10
    },
    {
      "subject": "js",
      "title": "Javascript OOPs implementation",
      "ques": "",
      "links": [
        {
          "name": "https://www.educative.io/blog/object-oriented-programming"
        },
        {
          "name": "https://www.youtube.com/watch?v=S1dWe3f2zm0&ab_channel=Telusko"
        },
        {
          "name": "https://www.youtube.com/watch?v=vDJpGenyHaA&ab_channel=TraversyMedia"
        },
        {
          "name": "https://www.youtube.com/watch?v=PFmuCDHHpwk&ab_channel=ProgrammingwithMosh"
        },
        {
          "name": "https://stackblitz.com/edit/js-ezmjoz?file=index.js"
        }
      ],
      "tags": [
        {
          "name": "OOPs"
        }
      ],
      "ans": "Certainly! Here's a detailed explanation of Object-Oriented Programming (OOP) concepts in JavaScript using ES6 features:\n\n1. Objects and Classes:\n   - In ES6, classes were introduced as syntactic sugar over JavaScript's existing prototype-based inheritance system.\n   - Classes provide a more familiar syntax for defining objects and their behavior.\n   - The `class` keyword is used to define a class, and the `constructor` method is used to initialize the object.\n   - Here's an example of defining a class and creating objects from it:\n\n```javascript\nclass Person {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n\n  sayHello() {\n    console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`);\n  }\n}\n\nconst john = new Person(\"John\", 25);\njohn.sayHello(); // Output: Hello, my name is John and I am 25 years old.\n```\n\n2. Encapsulation:\n   - Encapsulation refers to the bundling of data and methods within an object, hiding the internal details and providing a public interface for interaction.\n   - ES6 introduces support for `get` and `set` keywords to define getter and setter methods for object properties.\n   - Getters allow accessing a property's value, while setters allow modifying the property value with validation or additional logic.\n   - Here's an example:\n\n```javascript\nclass BankAccount {\n  constructor(accountNumber, balance) {\n    this._accountNumber = accountNumber;\n    this._balance = balance;\n  }\n\n  get accountNumber() {\n    return this._accountNumber;\n  }\n\n  get balance() {\n    return this._balance;\n  }\n\n  set balance(newBalance) {\n    if (newBalance >= 0) {\n      this._balance = newBalance;\n    } else {\n      console.log(\"Invalid balance.\");\n    }\n  }\n}\n\nconst account = new BankAccount(\"1234567890\", 1000);\nconsole.log(account.accountNumber); // Output: 1234567890\nconsole.log(account.balance); // Output: 1000\naccount.balance = -500; // Output: Invalid balance.\naccount.balance = 2000;\nconsole.log(account.balance); // Output: 2000\n```\n\n3. Inheritance:\n   - Inheritance allows objects to inherit properties and methods from other objects, creating a hierarchical relationship.\n   - ES6 introduced the `extends` keyword to establish inheritance between classes.\n   - The `super` keyword is used to invoke the parent class's constructor or methods.\n   - Here's an example of inheritance:\n\n```javascript\nclass Animal {\n  constructor(name) {\n    this.name = name;\n  }\n\n  speak() {\n    console.log(`${this.name} makes a sound.`);\n  }\n}\n\nclass Dog extends Animal {\n  speak() {\n    console.log(`${this.name} barks.`);\n  }\n}\n\nconst dog = new Dog(\"Buddy\");\ndog.speak(); // Output: Buddy barks.\n```\n\n4. Polymorphism:\n   - Polymorphism allows objects of different classes to be treated as objects of a common superclass, enabling interchangeable usage.\n   - JavaScript achieves polymorphism through dynamic typing and duck typing.\n   - Duck typing focuses on the object's behavior rather than its type.\n   - Here's an example:\n\n```javascript\nclass Shape {\n  area() {\n    console.log(\"Calculating area of a shape.\");\n  }\n}\n\nclass Circle extends Shape {\n  constructor(radius) {\n    super();\n    this.radius = radius;\n  }\n\n  area() {\n    console.log(`Calculating area of a circle with radius ${this.radius}`);\n  }\n}\n\nclass Rectangle extends Shape {\n  constructor(length, width) {\n   \n\n super();\n    this.length = length;\n    this.width = width;\n  }\n\n  area() {\n    console.log(`Calculating area of a rectangle with length ${this.length} and width ${this.width}`);\n  }\n}\n\nconst shapes = [new Circle(5), new Rectangle(4, 6)];\n\nshapes.forEach(shape => shape.area());\n// Output:\n// Calculating area of a circle with radius 5\n// Calculating area of a rectangle with length 4 and width 6\n```\n\nThese are some of the key Object-Oriented Programming concepts in JavaScript using ES6 features. Understanding and applying these concepts can help you write more modular, reusable, and maintainable code.",
      "diff": 1,
      "imp": 4,
      "cate": [
        "general",
        "oops"
      ],
      "id": 11
    },
    {
      "subject": "js",
      "title": "JS Promised",
      "ques": "",
      "links": [],
      "tags": [
        {
          "name": "Promises"
        }
      ],
      "ans": "const getConfig1 = new Promise((resolve, reject) => {\n    let ser;\n    setTimeout(() => resolve(ser), 100)\n  });\n\n\nconst _f1 = () => {\n    const asyncPromise  = new Promise(async(resolve, reject) => {\n        try{\n           let data = await getConfig1;\n           resolve(data); \n        } catch(err){\n            reject(err);\n        }\n    });\n\n    return [asyncPromise];\n}\n\nconst f1 = () => {\n    const asyncPromise  = async() => {\n        try{\n           let data = 42; //await getConfig1;\n           return data; \n        } catch(err){\n            return err;\n        }\n    }\n    return [asyncPromise];\n}\n\nlet promises = _f1();\n\nPromise.all(promises).then((configPayloads)=>{\n    console.log(\"configPayloads ::\", configPayloads);\n}).catch((error)=>{\n    console.log(\"error ::\", error);\n})\n",
      "diff": 1,
      "imp": 1,
      "cate": [
        "general"
      ],
      "id": 12
    },
    {
      "subject": "js",
      "title": "Currying",
      "ques": "",
      "links": [],
      "tags": [
        {
          "name": "Currying"
        },
        {
          "name": "Walmart"
        }
      ],
      "ans": "/*\nCase 1: add(1)(2)(3)\nIt’s basically a sequence of functions with single argument. \nSo our approach is to return a function which in turn returns another function to accept next argument.\n*/\nfunction add(a){\n return function(b){\n  return function(c){\n   return a+b+c\n  }\n }\n}\n\n\n/*\nCase 2: add(1)(2)(3)…(n)()\nIt’s basically a sequence of n+1 functions with single argument except the last one. \nSo our approach is to return a function which in turn returns another function to accept \nnext argument and so on till the last argument doesn’t exist.\n*/\nfunction add(a) {\n  return function(b){\n    if(b){\n      return add(a+b)\n    }\n    return a\n  }\n}\n\n//let res = add(1)(2)(3)(4)();\n//console.log(\"res ::\", res);\n\n\n/*\nCase 3: sum(1,2)(3,4)\nSo, this is similar as above just that we are accepting two arguments in single call. \nSo, we need to add the arguments. Let’s look at the code:\n*/\nfunction sum(a,b) {\n  return function(c,d){\n    return a+b+c+d\n  }\n}\n\n/*\nCase 4: add(1,2..n)(5,6…n)…(n)()\nNow in this case, everything is infinite. We already know infinite currying, let’s focus on infinite arguments.\n*/\nfunction add(...args) {\n  let a = args.reduce((a, b) => a + b, 0)\n  return function(...args){\n    let b = args.reduce((a, b) => a + b, 0)\n    if(b){\n      return add(a+b)\n    }\n    return a\n  }\n}",
      "diff": 1,
      "imp": 1,
      "cate": [
        "general",
        "code_pattern"
      ],
      "id": 13
    },
    {
      "subject": "js",
      "title": "Predict Output",
      "ques": "",
      "links": [
        {
          "name": "https://stackblitz.com/edit/js-qxha7g?file=index.html,index.js"
        }
      ],
      "tags": [
        {
          "name": "Basics & Tricky"
        }
      ],
      "ans": "1.what will be the output?\nvar a = 10;\n\nfunction t(){\n    this.a = 20;\n    return a;\n}\n\nconsole.log(new t())\n\nOptions :-\nA. 10\nB. 20\nC. {a : 20}\nD. undefined\n\nAnswer - C\n---------------------------------------------------\n\n2.what will be the output?\nconsole.log(a);\nconsole.log(b);\nvar a=1;\nconst b=2;\n\n\noptions :-\nA. ReferenceError: a is not defined, ReferenceError: b is not defined\nB. undefined, ReferenceError: b is not defined\nC. 1, 2\nD. ReferenceError: a is not defined, undefined\n\nAnswer - B\n---------------------------------------------------\n\n3.what will be the output?\nlet i;\nfor(i=0; i<5; i++){\n    setTimeout(()=>{\n        console.log(i);\n    });\n}\n\noptions :-\nA. 4, 4, 4, 4, 4\nB. 5, 5, 5, 5, 5\nC. undefined\nD. 0, 1, 2, 3, 4\n\nAnswer - B\n---------------------------------------------------\n\n4.what will be output?\nconst length = 4;\nconst numbers = [];\nfor (var i = 0; i < length; i++);{\n  numbers.push(i + 1);\n}\nnumbers;\n\n\noptions :-\nA.[5]\nB.[0,1,2,3]\nC.[1,2,3,4]\nD.[]\n\nAnswer - A\n---------------------------------------------------\n\n5.What will be output?\nfunction foo() {\n  let a = b = 0;\n  a++;\n  return a;\n}\nfoo();\nconsole.log(typeof a); \nconsole.log(typeof b);\n\noptions :-\nA. undefined, number\nB. number, number\nC. boolean, boolean\nD. number, undefined\n\nAnswer - A\n\n\n\n\n",
      "diff": 1,
      "imp": 1,
      "cate": [
        "general"
      ],
      "id": 14
    },
    {
      "subject": "js",
      "title": "Factory Function vs. Constructor vs. Class",
      "ques": "",
      "links": [
        {
          "name": "https://www.youtube.com/watch?v=fbuyliXlDGI&ab_channel=ColorCode"
        }
      ],
      "tags": [
        {
          "name": "Youtube"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": [
        "general",
        "code_pattern"
      ],
      "id": 15
    },
    {
      "subject": "js",
      "title": "Implement Hashcode in Javascript",
      "ques": "",
      "links": [
        {
          "name": "https://stackoverflow.com/questions/194846/is-there-any-kind-of-hash-code-function-in-javascript"
        }
      ],
      "tags": [
        {
          "name": "Leetcode"
        }
      ],
      "ans": "String.prototype.hashCode = function(){\n    var hash = 0;\n    for (var i = 0; i < this.length; i++) {\n        var character = this.charCodeAt(i);\n        hash = ((hash<<5)-hash)+character;\n        hash = hash & hash; // Convert to 32bit integer\n    }\n    return hash;\n}",
      "diff": 1,
      "imp": 1,
      "cate": [
        "general"
      ],
      "id": 16
    },
    {
      "subject": "js",
      "title": "Polyfill for Array methods: map(), filter() and reduce() ",
      "ques": "",
      "links": [
        {
          "name": "https://medium.com/nerd-for-tech/polyfill-for-array-map-filter-and-reduce-e3e637e0d73b"
        },
        {
          "name": "https://stackblitz.com/edit/js-ajcqxm?file=index.js"
        }
      ],
      "tags": [
        {
          "name": "medium.com"
        },
        {
          "name": "Adobe"
        }
      ],
      "ans": "//MAP\nlet newArray = arr.map(callback(currentValue[, index[, array]]) {\n  // return element for newArray, after executing something\n});\n\n\nArray.prototype.myMap = function(callbackFn) {\n  var arr = [];              \n  for (var i = 0; i < this.length; i++) { \n     /* call the callback function for every value of this array and       push the returned value into our resulting array\n     */\n    arr.push(callbackFn(this[i], i, this));\n  }\n  return arr;\n}\n\n\n\n//FILTER\nlet newArray = arr.filter(callback(currentValue[, index[, array]]) {\n  // return element for newArray, if true\n});\n\nArray.prototype.myFilter = function(callbackFn) {\n  var arr = [];     \n  for (var i = 0; i < this.length; i++) {\n    if (callbackFn.call(this, this[i], i, this)) {\n      arr.push(this[i]);\n    }\n  }\n  return arr;\n}\n\n//REDUCE\narr.reduce(callback( accumulator, currentValue, [, index[, array]] )[, initialValue])\n\nArray.prototype.myReduce= function(callbackFn, initialValue) {\n  var accumulator = initialValue;\nfor (var i = 0; i < this.length; i++) {\n    if (accumulator !== undefined) {\n      accumulator = callbackFn.call(undefined, accumulator, this[i],   i, this);\n    } else {\n      accumulator = this[i];\n    }\n  }\n  return accumulator;\n}\n\n\n\n\n",
      "diff": 1,
      "imp": 1,
      "cate": [
        "general"
      ],
      "id": 17
    },
    {
      "subject": "js",
      "title": "Web Components",
      "ques": "What is web components in Js?",
      "links": [
        {
          "name": "https://kinsta.com/blog/web-components/"
        }
      ],
      "tags": [
        {
          "name": "web componet"
        }
      ],
      "ans": "Certainly! Here's a detailed explanation of web component concepts in JavaScript with code examples:\n\n1. Custom Elements:\n   - Custom Elements allow you to define your own HTML elements with custom behaviors and functionality.\n   - Custom elements can encapsulate their own markup, style, and behavior, making them reusable and self-contained.\n   - To define a custom element, you need to extend the `HTMLElement` class and define the desired behavior.\n   - Here's an example of creating a custom `<my-button>` element:\n\n```javascript\nclass MyButton extends HTMLElement {\n  constructor() {\n    super();\n    this.attachShadow({ mode: 'open' });\n    this.shadowRoot.innerHTML = `\n      <style>\n        button {\n          background-color: blue;\n          color: white;\n        }\n      </style>\n      <button>Click me</button>\n    `;\n  }\n\n  connectedCallback() {\n    this.shadowRoot.querySelector('button').addEventListener('click', () => {\n      console.log('Button clicked!');\n    });\n  }\n}\n\ncustomElements.define('my-button', MyButton);\n```\n\n2. Shadow DOM:\n   - Shadow DOM provides encapsulation by creating an isolated DOM subtree within a custom element.\n   - It separates the styles and DOM of the custom element from the surrounding page's styles and DOM.\n   - The Shadow DOM can be attached to a custom element using the `attachShadow()` method.\n   - Here's an example of using the Shadow DOM in a custom element:\n\n```javascript\nclass MyCard extends HTMLElement {\n  constructor() {\n    super();\n    const shadow = this.attachShadow({ mode: 'open' });\n    shadow.innerHTML = `\n      <style>\n        .card {\n          border: 1px solid gray;\n          padding: 10px;\n        }\n      </style>\n      <div class=\"card\">\n        <slot></slot>\n      </div>\n    `;\n  }\n}\n\ncustomElements.define('my-card', MyCard);\n```\n\n3. HTML Templates:\n   - HTML Templates allow you to define reusable markup structures that can be cloned and used multiple times.\n   - Templates provide a way to define static markup without rendering it immediately.\n   - Templates can be used within custom elements or inserted dynamically in the document.\n   - Here's an example of using an HTML template within a custom element:\n\n```javascript\nconst template = document.createElement('template');\ntemplate.innerHTML = `\n  <style>\n    .my-alert {\n      background-color: yellow;\n      padding: 10px;\n      border: 1px solid black;\n    }\n  </style>\n  <div class=\"my-alert\">\n    <slot></slot>\n  </div>\n`;\n\nclass MyAlert extends HTMLElement {\n  constructor() {\n    super();\n    const shadow = this.attachShadow({ mode: 'open' });\n    shadow.appendChild(template.content.cloneNode(true));\n  }\n}\n\ncustomElements.define('my-alert', MyAlert);\n```\n\nThese examples demonstrate the core concepts of web components in JavaScript. Custom Elements, Shadow DOM, and HTML Templates allow you to create reusable and encapsulated components, providing modularity, encapsulation, and reusability in web development.",
      "diff": 1,
      "imp": 1,
      "cate": [
        "general"
      ],
      "id": 18
    },
    {
      "subject": "js",
      "title": "What are web APIs?",
      "ques": "",
      "links": [
        {
          "name": "https://developer.mozilla.org/en-US/docs/Web/API"
        }
      ],
      "tags": [
        {
          "name": "web API"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": [
        "general"
      ],
      "id": 19
    },
    {
      "subject": "js",
      "title": "What is the order of inline onclick vs addeventlistener and why?",
      "ques": "",
      "links": [
        {
          "name": "https://stackoverflow.com/questions/49805942/what-is-the-order-of-inline-onclick-vs-addeventlistener-and-why#:~:text=As%20we%20can%20see%20then,second%20listener%20set%20with%20addEventListener%20."
        },
        {
          "name": "https://jsbin.com/xubajoradi/edit?html,js,console,output"
        }
      ],
      "tags": [],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": [
        "events",
        "general"
      ],
      "id": 20
    },
    {
      "subject": "js",
      "title": "real time communication",
      "ques": "what are solution for real time communication between client and server?",
      "links": [
        {
          "name": "https://www.telerik.com/blogs/real-time-communication-techniques"
        },
        {
          "name": "https://eduardocribeiro.com/blog/real-time-communication/"
        }
      ],
      "tags": [
        {
          "name": "web API"
        }
      ],
      "ans": "There are several solutions available for real-time communication between client and server. Here are some commonly used options:\n\na. **WebSockets**: WebSockets provide full-duplex communication channels over a single TCP connection. They allow real-time, bidirectional communication between the client and server. WebSockets are widely supported by modern web browsers and offer low latency and efficient data transfer. Libraries like Socket.IO and SignalR simplify WebSocket implementation.\n\nb. **Server-Sent Events (SSE)**: SSE is a unidirectional communication protocol where the server sends data to the client over a persistent HTTP connection. SSE allows the server to push updates to the client as they occur, providing real-time updates. SSE is well-suited for scenarios where the client needs to receive continuous streams of data. It is supported by most modern web browsers.\n\nc. **Long Polling**: Long polling is a technique where the client sends a request to the server, and the server keeps the request open until new data is available. Once the server has new data, it responds to the request, and the client immediately sends another request. Long polling allows real-time updates while reducing the frequency of requests compared to regular polling. It works well in scenarios where WebSocket or SSE support is limited.\n\nd. **HTTP Streaming**: HTTP streaming allows the server to send data to the client continuously as it becomes available. The server sends an initial response and keeps the connection open, streaming data in chunks as it is generated. This approach enables real-time updates but may require more server resources compared to other options.\n\ne. **Push Notifications**: Push notifications are a mechanism to deliver real-time updates to clients through platform-specific notification services. They are commonly used in mobile applications to provide real-time alerts or messages. Push notification services like Firebase Cloud Messaging (FCM) or Apple Push Notification Service (APNS) can be utilized to achieve real-time communication.\n\nThe choice of the solution depends on the specific requirements of your application, the level of real-time responsiveness needed, and the limitations or constraints of your infrastructure. It's important to consider factors such as scalability, compatibility, ease of implementation, and the nature of the data being transmitted when selecting a real-time communication solution.\n",
      "diff": 1,
      "imp": 1,
      "cate": [
        "general"
      ],
      "id": 21
    },
    {
      "subject": "js",
      "title": "what is EventSource in Javascript?",
      "ques": "",
      "links": [
        {
          "name": "https://www.w3schools.com/html/html5_serversentevents.asp"
        },
        {
          "name": "https://blog.tericcabrel.com/implement-server-sent-event-in-node-js"
        }
      ],
      "tags": [],
      "ans": "In JavaScript, `EventSource` is an API that allows the client (typically a web browser) to establish a persistent connection to a server over HTTP and receive real-time updates in the form of server-sent events (SSE).\n\nThe `EventSource` API provides a simple and convenient way to consume SSE streams and handle server-sent events. It abstracts the underlying networking details and provides a high-level interface to work with SSE.\n\nHere are some key features and concepts related to `EventSource`:\n\n1. **Establishing a connection**: To establish a connection with the server, you create an instance of `EventSource` and provide the URL of the SSE endpoint as the argument.\n\n2. **Listening for events**: Once the connection is established, you can listen for different types of events sent by the server using event listeners. The common events include `message`, `open`, and `error`.\n\n3. **Message event**: The `message` event is triggered when the server sends an event. You can add an event listener for the `message` event and handle the received event data.\n\n4. **Event data**: The event data sent by the server typically includes fields like event type, data payload, and optional custom fields. You can access these fields using properties of the `Event` object provided in the event listener.\n\n5. **Reconnection and error handling**: The `EventSource` API automatically handles reconnection and error scenarios. If the connection is interrupted, it attempts to reconnect. When an error occurs, the `error` event is triggered, and you can handle the error appropriately.\n\nHere's a basic example demonstrating the usage of `EventSource`:\n\n```javascript\nconst eventSource = new EventSource('http://example.com/events');\n\neventSource.addEventListener('message', (event) => {\n  const eventData = JSON.parse(event.data);\n  console.log('Received event:', eventData);\n});\n\neventSource.addEventListener('open', () => {\n  console.log('Connection opened');\n});\n\neventSource.addEventListener('error', (error) => {\n  console.error('Error occurred:', error);\n});\n```\n\nIn this example, we create an `EventSource` instance and provide the URL of the SSE endpoint (`http://example.com/events`). We add event listeners for `message`, `open`, and `error` events to handle the received events, connection open, and error scenarios respectively.\n\nThe `EventSource` API simplifies the process of working with server-sent events and allows you to build real-time applications that can receive and handle continuous updates from the server.",
      "diff": 1,
      "imp": 1,
      "cate": [
        "general"
      ],
      "id": 22
    },
    {
      "subject": "js",
      "title": "How could you use Math.max to find the max value in an array?",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "function getMax(arr){\n  return Math.max.apply(null, arr);  \n}",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 23
    },
    {
      "subject": "js",
      "title": "What the heck is this in JavaScript?",
      "ques": "",
      "links": [
        {
          "name": "https://www.youtube.com/watch?v=yuo8YqKDQ-M&ab_channel=ThatJSDude"
        }
      ],
      "tags": [],
      "ans": "At the time of execution of every function, JavaScript engine sets \na property to the function called this which refer to the current \nexecution context. this is always refer to an object and depends \non how function is called. \nThere are 7 different cases where the value of this varies :-\n\na. In the global context or inside a function this refers to the window object.\n\nb. Inside IIFE (immediate invoking function) if you use \"use strict\", value of this is undefined. To pass access window inside IIFE with \"use strict\", you have to pass this.\n\nc. While executing a function in the context of an object, the object becomes the value of this\n\nd. Inside a setTimeout function, the value of this is the window object.\n\ne. If you use a constructor (by using new keyword) to create an object, the value of this will refer to the newly created object.\n\nf. You can set the value of this to any arbitrary object by passing the object as the first parameter of bind, call or apply\n\ng. For dom event handler, value of this would be the element that fired the event",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 24
    },
    {
      "subject": "js",
      "title": "How could you implement moveLeft animation?",
      "ques": "",
      "links": [
        {
          "name": "https://stackblitz.com/edit/js-92mhcq?file=index.js,index.html"
        }
      ],
      "tags": [],
      "ans": "function moveDiv(margin, delay) {\n  // arrow function was creating issue with margin variable scoping so replaced with simple function\n  let clearMargin = setInterval(function(){\n    margin = margin + 10;\n    document.querySelector(\"#move\").style.cssText = `margin-left : ${margin}px;`; \n    if(margin == 100){\n      clearInterval(clearMargin);\n    }\n  }, delay)\n\n}\n\nmoveDiv(10, 1000);",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 25
    },
    {
      "subject": "js",
      "title": "Generate no between 5 and 8",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "min = 5\nmax = 8\n\nMath.floor(Math.random() *( (max - min) + 1) ) + min\n\nMath.floor(Math.random() *( (8 - 5) + 1) ) + 5\n\nMath.floor(Math.random() * 4) + 5",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 26
    },
    {
      "subject": "js",
      "title": "why fat arrow don't read this context when declare new method on Array prototype?",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "The fat arrow (`=>`) function in JavaScript has lexical scoping for the `this` keyword. It means that the value of `this` inside a fat arrow function is determined by the surrounding context where the function is defined, and it does not have its own `this` binding.\n\nWhen you declare a new method on the Array prototype using a fat arrow function, the `this` inside that function will not refer to the array instance you are operating on. Instead, it will inherit the `this` value from the surrounding scope where the function is defined.\n\nHere's an example to illustrate this behavior:\n\n```javascript\nArray.prototype.myMethod = () => {\n  console.log(this); // 'this' will not refer to the array instance\n};\n\nconst myArray = [1, 2, 3];\nmyArray.myMethod(); // Output: undefined (referring to the surrounding scope)\n```\n\nIn this example, the `myMethod` is declared using a fat arrow function. When calling `myArray.myMethod()`, the `this` inside the fat arrow function will not refer to `myArray`. Instead, it will be determined by the surrounding scope, which in this case is the global scope (or the closest non-arrow function surrounding scope).\n\nTo access the correct `this` value inside the method, you should use a regular function declaration or a regular function expression. For example:\n\n```javascript\nArray.prototype.myMethod = function () {\n  console.log(this); // 'this' will refer to the array instance\n};\n\nconst myArray = [1, 2, 3];\nmyArray.myMethod(); // Output: [1, 2, 3] (referring to myArray)\n```\n\nUsing a regular function allows the method to have its own `this` binding, which will be set to the array instance on which the method is called.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 27
    },
    {
      "subject": "js",
      "title": "can we create deep copyof object using spread operator?",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "No, using the spread operator (`...`) alone to create a shallow copy of an object. It does not create a deep copy. A shallow copy only creates a new object with the same top-level properties as the original object, but the nested objects and arrays inside the original object will still reference the same memory locations in both the original and copied objects.\n\nTo create a deep copy of an object, including all nested objects and arrays, you need to use other methods or techniques. Here are a few commonly used approaches:\n\n1. Using `JSON.parse()` and `JSON.stringify()`: You can serialize the object to a JSON string using `JSON.stringify()`, and then parse it back into a new object using `JSON.parse()`. This technique creates a deep copy but has limitations when dealing with functions, prototypes, or circular references.\n\n   ```javascript\n   const originalObject = { ... };\n   const deepCopy = JSON.parse(JSON.stringify(originalObject));\n   ```\n\n2. Using libraries or utility functions: There are several third-party libraries, such as Lodash or Underscore, that provide functions like `cloneDeep()` or `deepClone()` to create deep copies of objects.\n\n   ```javascript\n   const originalObject = { ... };\n   const deepCopy = _.cloneDeep(originalObject); // Using Lodash\n   ```\n\n3. Implementing a custom deep copy function: You can write a custom function that recursively traverses the object, creating new instances of nested objects and arrays.\n\n   ```javascript\n   function deepCopy(obj) {\n     if (typeof obj !== 'object' || obj === null) {\n       return obj;\n     }\n\n     const copy = Array.isArray(obj) ? [] : {};\n\n     for (let key in obj) {\n       if (obj.hasOwnProperty(key)) {\n         copy[key] = deepCopy(obj[key]);\n       }\n     }\n\n     return copy;\n   }\n\n   const originalObject = { ... };\n   const deepCopy = deepCopy(originalObject);\n   ```\n\nIt's important to note that deep copying large or complex objects can have performance implications, especially if the object contains circular references or deeply nested structures. Therefore, consider the specific requirements and constraints of your application when choosing the appropriate method for creating a deep copy.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 28
    },
    {
      "subject": "js",
      "title": "how to make script executed after page load finshes using inline attribute",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "To execute a script after the page has finished loading using the inline attribute, you can use the `onload` event directly in the HTML tag. The `onload` event is triggered when the entire web page (including all images, styles, and scripts) has loaded.\n\nHere's an example of how to do it:\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n  <title>Page with Inline Script</title>\n</head>\n<body>\n  <h1>Hello, world!</h1>\n  \n  <!-- Your content goes here -->\n\n  <script>\n    // Your script goes here\n    window.onload = function() {\n      // This function will be executed after the page finishes loading\n      alert('Page has finished loading!');\n    };\n  </script>\n</body>\n</html>\n```\n\nIn the above example, the `<script>` tag contains the JavaScript code that is executed when the page finishes loading. The `window.onload` function sets an event handler, and when the `onload` event occurs (i.e., when the page finishes loading), the specified function is called.\n\nThe `onload` event is often used to ensure that JavaScript code runs after the DOM (Document Object Model) is fully constructed and all the resources on the page, like images and stylesheets, have been loaded. This way, you can be sure that your script will have access to all the elements on the page without any issues.\n\nHowever, using inline scripts is generally not recommended for larger projects, as it can make the HTML code harder to manage and maintain. In larger projects, it's more common to place JavaScript in separate files and use modern JavaScript practices like event listeners or the `defer` attribute on the `<script>` tag to handle script execution.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 29
    },
    {
      "subject": "js",
      "title": "What if multiple same eventListener implement in different files in javascript, then what will be the order of execution?",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "In JavaScript, if you attach the same event listener function to the same event in different files, the order of execution will depend on the order in which the files are loaded or executed in your application.\n\nJavaScript files are usually loaded and executed in the order they are included in the HTML page (in the case of browser-based JavaScript) or the order in which they are required in the main Node.js application (in the case of server-side JavaScript).\n\nLet's consider the following scenario:\n\nFile 1: `listener1.js`\n\n```javascript\n// listener1.js\nconst button = document.querySelector('#myButton');\n\nfunction handleClick() {\n  console.log('Listener 1: Button clicked!');\n}\n\nbutton.addEventListener('click', handleClick);\n```\n\nFile 2: `listener2.js`\n\n```javascript\n// listener2.js\nconst button = document.querySelector('#myButton');\n\nfunction handleClick() {\n  console.log('Listener 2: Button clicked!');\n}\n\nbutton.addEventListener('click', handleClick);\n```\n\nIf you include these files in the HTML page like this:\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n  <title>Multiple Event Listeners</title>\n</head>\n<body>\n  <button id=\"myButton\">Click Me</button>\n\n  <script src=\"listener1.js\"></script>\n  <script src=\"listener2.js\"></script>\n</body>\n</html>\n```\n\nThen, the order of execution will be as follows:\n\n1. `listener1.js` will be loaded and executed first.\n2. It will attach the event listener `handleClick` to the button click event.\n3. `listener2.js` will be loaded and executed next.\n4. It will also try to attach the event listener `handleClick` to the same button click event.\n\nIn this case, the event listener attached by `listener2.js` will overwrite the event listener attached by `listener1.js`. As a result, only the event listener from `listener2.js` will be executed when the button is clicked.\n\nThe order of execution is determined by the order in which the files are loaded and executed. If you need to control the order of execution for event listeners or other parts of your JavaScript code, make sure to manage the dependencies and include the files in the desired order.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 30
    },
    {
      "subject": "js",
      "title": "How to implement global exception handling in JavaScript?",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "In JavaScript, you can implement global exception handling by attaching event listeners for the `uncaughtException` and `unhandledRejection` events on the `process` object (in Node.js) or the `window` object (in the browser). These events will capture unhandled exceptions and unhandled promise rejections, respectively.\n\nHere's how you can implement global exception handling in JavaScript:\n\n1. For Node.js:\n\nCreate a new file (e.g., `globalExceptionHandler.js`) to define the global exception handling logic.\n\n```javascript\n// globalExceptionHandler.js\n\n// Function to handle uncaught exceptions\nfunction handleUncaughtException(error) {\n  console.error('Uncaught Exception:', error.stack || error.message || error);\n  // Add any additional error handling logic or cleanup operations here\n  process.exit(1); // Optional: Gracefully exit the Node.js process with a non-zero exit code\n}\n\n// Function to handle unhandled promise rejections\nfunction handleUnhandledRejection(reason) {\n  console.error('Unhandled Rejection:', reason instanceof Error ? reason.stack : reason);\n  // Add any additional error handling logic or cleanup operations here\n}\n\n// Attach event listeners for uncaught exceptions and unhandled promise rejections\nprocess.on('uncaughtException', handleUncaughtException);\nprocess.on('unhandledRejection', handleUnhandledRejection);\n```\n\nIn your main Node.js application file (e.g., `app.js`), require the `globalExceptionHandler.js` file to set up the global exception handling.\n\n```javascript\n// app.js\nrequire('./globalExceptionHandler');\n\n// Your main application code here...\n// Any uncaught exceptions or unhandled promise rejections will be caught by the global exception handler\n```\n\n2. For the Browser:\n\nIn your main HTML file, include a `<script>` tag to load a JavaScript file (e.g., `globalExceptionHandler.js`) that defines the global exception handling logic.\n\n```html\n<!-- index.html -->\n<!DOCTYPE html>\n<html>\n<head>\n  <title>Global Exception Handling</title>\n</head>\n<body>\n  <!-- Your HTML content here -->\n  <script src=\"globalExceptionHandler.js\"></script>\n</body>\n</html>\n```\n\nIn the `globalExceptionHandler.js` file, attach event listeners for the `unhandledrejection` and `error` events on the `window` object.\n\n```javascript\n// globalExceptionHandler.js\n\n// Function to handle uncaught exceptions and unhandled promise rejections\nfunction handleGlobalError(event) {\n  const message = event.message || 'Unknown error';\n  const stack = event.error && event.error.stack ? event.error.stack : 'No stack trace available';\n  console.error(`Global Error: ${message}\\nStack Trace: ${stack}`);\n  // Add any additional error handling logic or cleanup operations here\n}\n\n// Attach event listeners for uncaught exceptions and unhandled promise rejections\nwindow.addEventListener('error', handleGlobalError);\nwindow.addEventListener('unhandledrejection', handleGlobalError);\n```\n\nWith these implementations, you have set up global exception handling in JavaScript. Any uncaught exceptions or unhandled promise rejections that occur during the execution of your application will be caught by the respective global event listeners. You can then log the errors, perform any necessary cleanup, and take appropriate action based on the specific scenario.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 31
    },
    {
      "subject": "js",
      "title": "how can we automate api integration using openapi, explain with code example in reactjs. Include example of how post call handle",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "Automating API integration using OpenAPI in a React.js application involves generating client code from the OpenAPI specification and using it to make API requests. Let's walk through the steps with a code example:\n\n1. **Generate Client Code:**\n\n   First, you need to generate the client code from the OpenAPI specification. You can use tools like `openapi-generator-cli` to generate the code. Install it globally:\n\n   ```bash\n   npm install -g openapi-generator-cli\n   ```\n\n   Generate the client code for your API:\n\n   ```bash\n   openapi-generator-cli generate -i path/to/your/openapi.yaml -g javascript -o ./api-client\n   ```\n\n2. **Install Dependencies:**\n\n   In your React.js project, install the necessary dependencies:\n\n   ```bash\n   npm install axios\n   ```\n\n3. **Make a POST Request:**\n\n   In your React component, you can use the generated client code to make API requests. Here's an example:\n\n   ```jsx\n   import React, { useState } from 'react';\n   import ApiClient from './api-client'; // Import the generated client\n\n   function App() {\n     const [response, setResponse] = useState('');\n\n     const handlePostRequest = async () => {\n       const api = new ApiClient.DefaultApi();\n\n       const requestBody = {\n         // Your request body data here\n         name: 'John Doe',\n         email: 'john@example.com',\n       };\n\n       try {\n         const apiResponse = await api.createResource(requestBody);\n         setResponse(apiResponse);\n       } catch (error) {\n         console.error('Error:', error);\n       }\n     };\n\n     return (\n       <div>\n         <button onClick={handlePostRequest}>Make POST Request</button>\n         <pre>{JSON.stringify(response, null, 2)}</pre>\n       </div>\n     );\n   }\n\n   export default App;\n   ```\n\n   In this example, `createResource` is a method that corresponds to the POST operation defined in your OpenAPI specification. Replace `createResource` with the actual operation name from your generated client.\n\n4. **Run the React App:**\n\n   Start your React.js application:\n\n   ```bash\n   npm start\n   ```\n\n   Open your browser and access the app. Click the \"Make POST Request\" button to trigger the POST call and see the response displayed.\n\nBy automating API integration using OpenAPI and generating client code, you can easily make API requests and handle responses in your React.js application. This approach streamlines the integration process and ensures consistency when interacting with APIs.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 32
    },
    {
      "subject": "js",
      "title": "why and how we use lerna",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "Lerna is a popular tool for managing JavaScript projects with multiple packages, often referred to as monorepos. It allows you to optimize the workflow of developing and maintaining multiple interdependent packages within a single repository. Lerna helps to improve code reuse, simplify versioning, and streamline development processes. Here's why and how you might use Lerna:\n\n**Why Use Lerna:**\n\n1. **Code Reusability:** Lerna enables you to share code and components across different packages within your project. This can lead to reduced duplication and a more efficient development process.\n\n2. **Dependency Management:** Lerna simplifies the management of dependencies between packages. It ensures that packages within your monorepo use consistent versions of shared dependencies.\n\n3. **Streamlined Development:** With Lerna, you can develop and test multiple packages simultaneously. Changes to one package can be quickly tested against other dependent packages, reducing integration issues.\n\n4. **Versioning Control:** Lerna provides versioning control for your packages. It allows you to manage version bumps across packages, ensuring that changes are properly propagated.\n\n5. **Atomic Commits:** Lerna encourages atomic commits, where changes to multiple packages are committed together. This helps maintain a consistent state across packages.\n\n**How to Use Lerna:**\n\n1. **Installation:**\n   Install Lerna globally or as a development dependency in your monorepo:\n\n   ```bash\n   npm install -g lerna\n   # OR\n   npm install lerna --save-dev\n   ```\n\n2. **Initialize a Monorepo:**\n   Create a new directory for your monorepo or navigate to your existing project. Then initialize your monorepo with Lerna:\n\n   ```bash\n   lerna init\n   ```\n\n3. **Creating Packages:**\n   Use Lerna to create new packages within your monorepo:\n\n   ```bash\n   lerna create package-name\n   ```\n\n4. **Managing Dependencies:**\n   Lerna automatically manages dependencies and versioning for your packages. You can use the following commands to add, remove, or upgrade dependencies:\n\n   ```bash\n   lerna add package-name --scope=package-name\n   lerna remove package-name --scope=package-name\n   lerna exec -- npm install # Install dependencies for all packages\n   ```\n\n5. **Running Commands:**\n   Lerna allows you to run commands across all packages or specific packages using the `lerna run` command:\n\n   ```bash\n   lerna run build\n   lerna run test --scope=package-name\n   ```\n\n6. **Publishing Packages:**\n   Lerna simplifies the process of publishing packages to your chosen package registry (npm or Yarn). It ensures that versioning is consistent and that changes are properly reflected:\n\n   ```bash\n   lerna publish\n   ```\n\n7. **Custom Configuration:**\n   You can configure Lerna to match your project's specific needs by adding a `lerna.json` configuration file or using the `lerna.json` property in your `package.json`.\n\nLerna provides additional commands and features to enhance your monorepo development workflow. Be sure to refer to the official Lerna documentation for a comprehensive guide and best practices.\n\nUsing Lerna can greatly improve the organization, development, and maintenance of projects with multiple packages, making it a valuable tool for managing monorepos in JavaScript ecosystems.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 33
    },
    {
      "subject": "js",
      "title": "how to implement pub sub in javascript",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "Implementing the Publish-Subscribe (Pub-Sub) pattern in JavaScript involves creating a mechanism for components or modules to communicate with each other without direct dependencies. Here's a basic example of how you can implement Pub-Sub in JavaScript:\n\n1. **Create a Pub-Sub Module:**\n\n   Start by creating a module that acts as the central hub for communication. This module will manage subscribers and notify them when events are published.\n\n   ```javascript\n   // pubsub.js\n   const PubSub = (function () {\n     const events = {};\n\n     function subscribe(event, callback) {\n       if (!events[event]) {\n         events[event] = [];\n       }\n       events[event].push(callback);\n     }\n\n     function publish(event, data) {\n       if (events[event]) {\n         events[event].forEach((callback) => {\n           callback(data);\n         });\n       }\n     }\n\n     return {\n       subscribe,\n       publish,\n     };\n   })();\n\n   export default PubSub;\n   ```\n\n2. **Subscribe to an Event:**\n\n   In a module that wants to listen for events, use the `subscribe` method to register a callback function for a specific event.\n\n   ```javascript\n   // subscriber.js\n   import PubSub from './pubsub.js';\n\n   function handleCustomEvent(data) {\n     console.log('Received custom event:', data);\n   }\n\n   PubSub.subscribe('customEvent', handleCustomEvent);\n   ```\n\n3. **Publish an Event:**\n\n   In another module that wants to publish an event, use the `publish` method.\n\n   ```javascript\n   // publisher.js\n   import PubSub from './pubsub.js';\n\n   function publishEvent() {\n     PubSub.publish('customEvent', 'Event data from Publisher');\n   }\n\n   publishEvent();\n   ```\n\n4. **Run Modules:**\n\n   Depending on your environment (browser, Node.js, etc.), run the subscriber and publisher modules.\n\n   For Node.js:\n   ```bash\n   node subscriber.js\n   node publisher.js\n   ```\n\n   For the browser, include the scripts in an HTML file:\n   ```html\n   <script type=\"module\" src=\"subscriber.js\"></script>\n   <script type=\"module\" src=\"publisher.js\"></script>\n   ```\n\nWith this implementation, when you run the `publisher.js` script or load the HTML file in the browser, the `subscriber.js` module will receive the published event and execute the associated handler function. This demonstrates the basic implementation of the Pub-Sub pattern in JavaScript. Remember that this is a simplified example, and in more complex scenarios, you might consider using libraries like `mitt`, `PubSubJS`, or a state management library like Redux for more robust Pub-Sub implementations.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 34
    },
    {
      "subject": "js",
      "title": "Infinite Scroll",
      "ques": "how to implement windowing concept in core javascript so that no need to fetch previous API data and DOM don't get heavy. Write code steps by step for how data will be fetch and stored and how these data would be used to render the html element",
      "links": [],
      "tags": [],
      "ans": "Implementing the windowing concept in pure JavaScript involves dynamically loading and rendering a subset of data as the user scrolls, similar to how libraries like `react-virtualized` work. Here's a step-by-step guide on how to achieve this:\n\nLet's assume you have an API endpoint that returns a list of items. In this example, we'll fetch data in batches and render only the visible items.\n\n1. **HTML Structure**:\n   Create an HTML structure to display the items. For simplicity, let's assume you have a `<ul>` element with an `id` of `\"item-list\"` where the items will be rendered.\n\n2. **Fetch Data in Batches**:\n   Fetch data from the API in batches as the user scrolls. You can use the `fetch` API or any other method to retrieve data. Here's an example of how to fetch data in batches of 10 items:\n\n   ```javascript\n   async function fetchData(startIndex, batchSize) {\n     const response = await fetch(`your-api-url?start=${startIndex}&count=${batchSize}`);\n     const data = await response.json();\n     return data;\n   }\n   ```\n\n3. **Initial Data Load**:\n   Load the initial batch of data when the page loads or the component initializes:\n\n   ```javascript\n   let startIndex = 0;\n   let batchSize = 10;\n   let data = [];\n\n   async function loadInitialData() {\n     data = await fetchData(startIndex, batchSize);\n     renderVisibleItems();\n   }\n\n   loadInitialData();\n   ```\n\n4. **Render Visible Items**:\n   Create a function to render only the visible items in the current viewport. This function calculates which items are visible based on the scroll position and renders them:\n\n   ```javascript\n   function renderVisibleItems() {\n     const container = document.getElementById('item-list');\n     const scrollPosition = container.scrollTop;\n     const visibleItems = data.slice(Math.floor(scrollPosition / itemHeight), Math.floor((scrollPosition + container.clientHeight) / itemHeight));\n\n     container.innerHTML = ''; // Clear existing items\n\n     visibleItems.forEach(item => {\n       const listItem = document.createElement('li');\n       listItem.textContent = item.name; // Assuming your data has a 'name' property\n       container.appendChild(listItem);\n     });\n   }\n   ```\n\n5. **Scroll Event Listener**:\n   Add a scroll event listener to the container to detect when the user scrolls and trigger the rendering of visible items:\n\n   ```javascript\n   const container = document.getElementById('item-list');\n   const itemHeight = 50; // Assuming a fixed item height\n\n   container.addEventListener('scroll', () => {\n     renderVisibleItems();\n   });\n   ```\n\n6. **Load More Data on Scroll**:\n   When the user scrolls near the end of the visible items, load the next batch of data and append it to the existing data:\n\n   ```javascript\n   container.addEventListener('scroll', async () => {\n     if (container.scrollHeight - container.scrollTop - container.clientHeight < itemHeight * 3) {\n       startIndex += batchSize;\n       const newData = await fetchData(startIndex, batchSize);\n       data = [...data, ...newData];\n       renderVisibleItems();\n     }\n   });\n   ```\n\nWith these steps, you've implemented a basic windowing concept in pure JavaScript. As the user scrolls, the script fetches additional data in batches, calculates which items are visible, and renders only those items in the viewport. This approach reduces the memory usage and improves performance compared to rendering the entire list of items at once.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 35
    }
  ],
  "es6": [
    {
      "subject": "es6",
      "title": "Hoisting in Modern JavaScript — let, const, and var",
      "ques": "",
      "links": [
        {
          "name": "https://blog.bitsrc.io/hoisting-in-modern-javascript-let-const-and-var-b290405adfda"
        }
      ],
      "tags": [
        {
          "name": "medium.com"
        }
      ],
      "ans": "\nTo avoid possible side effects of hoisting like undefined variables or reference error, \nalways try to declare the variables at the top of their respective scopes and also \nalways try to initialize variables when you declare them.\n\n\nconsole.log(\"a ::\", a); // a :: undefined\nconsole.log(\"b ::\", b); // Uncaught ReferenceError: b is not defined\nconsole.log(\"c ::\", c); // VM1944 hoisting:3 Uncaught ReferenceError: c is not defined\n\nvar a = 10;\nlet b = 20;\nconst c = 30;",
      "diff": 1,
      "imp": 1,
      "cate": [
        "general"
      ],
      "id": 1
    },
    {
      "subject": "es6",
      "title": "Javascript set",
      "ques": "",
      "links": [
        {
          "name": "https://bretcameron.medium.com/how-to-make-your-code-faster-using-javascript-sets-b432457a4a77#:~:text=Because%20Set.,time%20of%20O(N)."
        }
      ],
      "tags": [
        {
          "name": "set"
        },
        {
          "name": "Oracle"
        }
      ],
      "ans": "let s = new Set([1,2,3]);\n\nconsole.log(s);\ns.add(4);\nconsole.log(s);\ns.add(1);\nconsole.log(s);",
      "diff": 1,
      "imp": 1,
      "cate": [
        "general"
      ],
      "id": 2
    },
    {
      "subject": "es6",
      "title": "Javascript Private/public/static vars/methods",
      "ques": "",
      "links": [
        {
          "name": "https://stackblitz.com/edit/js-syltmu?file=index.html,index.js"
        }
      ],
      "tags": [],
      "ans": "class Employee{\n  #salary = \"10000\";\n  name = \"VJ\";\n\n  #getSalary () {\n    return this.#salary;\n  }\n\n  getEmpName() {\n    return this.name;\n  }\n\n}\nconst e1 = new Employee();\n// console.log(\"Employee class ::\", Employee);\nconsole.log(\"Employee class ::\", Employee);\n// console.log(\"Employee class obj ::\", e1);\n\n// console.log(\"Employee - private var salary ::\", e1.#salary());\n//console.log(\"Employee - private methid getSalary ::\", e1.#getSalary());\n\n\n\nfunction Developer(){\n  dev_name = \"VJ developer\";\n  dev_skill = \"FE\";\n\n  this.exp = 5; \n\n  function getDevName(){\n    return dev_name;\n  }\n\n  this.getExp = function(){\n    return \"*getExp\"\n  }\n}\n\nDeveloper.prototype.getDevDetails = function(){\n  return \"*getDevDetails\"\n};\n\nDeveloper.getDevSkill = function(){\n  return dev_skill;\n}\n\nconsole.log(\"static method getDevSkill ::\", Developer.getDevSkill() );\n\nconst d1 = new Developer();\n\nconsole.log(\"Developer obj ::\", d1);",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 3
    }
  ],
  "ts": [],
  "html": [],
  "css": [
    {
      "subject": "css",
      "title": "what is BEM methodology?",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "BEM (Block Element Modifier) is a methodology for naming CSS classes in order to facilitate reusable and maintainable code.\n\nThe key principles of BEM are:\n\n- Block: An encapsulated component that is meaningful on its own. Represented by the base class name, e.g. .block\n\n- Element: A part of a block that has no standalone meaning. Represented using two underscores, e.g. .block__element \n\n- Modifier: A variant or extension of a block or element. Represented by two hyphens, e.g. .block--modifier\n\nSome examples:\n\n```css\n/* Block */\n.btn {} \n\n/* Element */  \n.btn__price {}\n\n/* Modifier */\n.btn--primary {}\n.btn--large {}\n```\n\nThe benefits of BEM:\n\n- Code is more reusable and portable since blocks are decoupled\n- Naming convention makes relationships clear\n- Modified blocks can be easily styled without duplication\n- CSS is more maintainable and scalable\n\nSo in summary, BEM provides a consistent and future-proof approach to CSS class naming that makes stylesheets easy to read, understand, and maintain. Its principles help developers write modular, reusable CSS.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 1
    }
  ],
  "ng": [
    {
      "subject": "ng",
      "title": "how to implement pub sub in angular",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "Implementing the Publish-Subscribe (Pub-Sub) pattern in Angular involves using a messaging system where components can communicate with each other without having direct dependencies. This pattern is useful when you want to decouple components and allow them to communicate and exchange information without tight coupling. Here's how you can implement the Pub-Sub pattern in Angular:\n\n1. **Create a Pub-Sub Service:**\n\n   Start by creating a service that acts as the central hub for communication between components. This service will provide methods for subscribing to and publishing events.\n\n   ```typescript\n   // pubsub.service.ts\n   import { Injectable } from '@angular/core';\n   import { Subject, Observable } from 'rxjs';\n\n   @Injectable({\n     providedIn: 'root'\n   })\n   export class PubSubService {\n     private subject = new Subject<any>();\n\n     publish(event: string, data: any) {\n       this.subject.next({ event, data });\n     }\n\n     on(event: string): Observable<any> {\n       return this.subject.asObservable().pipe(\n         filter((message) => message.event === event),\n         map((message) => message.data)\n       );\n     }\n   }\n   ```\n\n2. **Subscribe to an Event:**\n\n   In a component that wants to listen for events, inject the `PubSubService` and subscribe to the desired event.\n\n   ```typescript\n   // subscriber.component.ts\n   import { Component, OnInit } from '@angular/core';\n   import { PubSubService } from './pubsub.service';\n\n   @Component({\n     selector: 'app-subscriber',\n     template: `\n       <div>\n         <h2>Subscriber Component</h2>\n         <p>{{ message }}</p>\n       </div>\n     `\n   })\n   export class SubscriberComponent implements OnInit {\n     message: string;\n\n     constructor(private pubsubService: PubSubService) {}\n\n     ngOnInit() {\n       this.pubsubService.on('customEvent').subscribe((data) => {\n         this.message = data;\n       });\n     }\n   }\n   ```\n\n3. **Publish an Event:**\n\n   In another component that wants to publish an event, inject the `PubSubService` and use the `publish` method.\n\n   ```typescript\n   // publisher.component.ts\n   import { Component } from '@angular/core';\n   import { PubSubService } from './pubsub.service';\n\n   @Component({\n     selector: 'app-publisher',\n     template: `\n       <div>\n         <h2>Publisher Component</h2>\n         <button (click)=\"publishEvent()\">Publish Event</button>\n       </div>\n     `\n   })\n   export class PublisherComponent {\n     constructor(private pubsubService: PubSubService) {}\n\n     publishEvent() {\n       this.pubsubService.publish('customEvent', 'Event data from Publisher');\n     }\n   }\n   ```\n\n4. **Add Components to Module:**\n\n   Don't forget to add the components and the `PubSubService` to your module's `declarations` and `providers` arrays.\n\n   ```typescript\n   // app.module.ts\n   import { NgModule } from '@angular/core';\n   import { BrowserModule } from '@angular/platform-browser';\n   import { PubSubService } from './pubsub.service';\n   import { SubscriberComponent } from './subscriber.component';\n   import { PublisherComponent } from './publisher.component';\n\n   @NgModule({\n     imports: [BrowserModule],\n     declarations: [SubscriberComponent, PublisherComponent],\n     providers: [PubSubService],\n     bootstrap: [SubscriberComponent, PublisherComponent]\n   })\n   export class AppModule {}\n   ```\n\nNow, when you click the \"Publish Event\" button in the `PublisherComponent`, the `SubscriberComponent` will receive the published event and update its content accordingly. This demonstrates the basic implementation of the Pub-Sub pattern in Angular, allowing components to communicate without direct coupling.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 1
    },
    {
      "subject": "ng",
      "title": "what is dependency injection in Angular, what are benefits of it. And How can we achieve the same in reactjs?",
      "ques": "",
      "links": [
        {
          "name": "https://chat.openai.com/c/fded0484-12c8-4f59-acb9-252afd4bf137"
        }
      ],
      "tags": [],
      "ans": "Dependency injection (DI) is a design pattern commonly used in software development to manage the dependencies of an application. In the context of Angular, which is a popular JavaScript framework for building web applications, dependency injection is a core concept.\n\n**Dependency Injection in Angular:**\n\nIn Angular, dependency injection is a mechanism that allows you to provide the dependent services or objects that a class or component needs rather than having the class create them itself. This separation of concerns makes code more modular, testable, and maintainable. Here's how it works:\n\n1. **Service Providers**: In Angular, you define services that encapsulate specific functionality. These services are essentially classes that provide some functionality or data.\n\n2. **Dependency Injection Container**: Angular has a built-in dependency injection container that manages the instantiation and sharing of these services.\n\n3. **Injection**: When a component or another service needs to use a particular service, it specifies its dependency in the constructor. Angular's dependency injection container then provides an instance of the required service to the component or service.\n\n**Benefits of Dependency Injection in Angular:**\n\n1. **Modularity**: It promotes modularity by allowing you to separate concerns and manage dependencies independently.\n\n2. **Testability**: Code that relies on dependency injection is easier to test because you can provide mock or fake implementations of services during testing.\n\n3. **Reusability**: Services can be reused across different components or services, reducing code duplication.\n\n4. **Maintainability**: Changes to a service's implementation can be done without affecting the components that depend on it.\n\n5. **Flexibility**: It makes it easier to switch out implementations or dependencies without affecting the consuming code.\n\n**Dependency Injection in React:**\n\nReact is a different JavaScript library than Angular, and it does not have a built-in dependency injection system like Angular does. However, you can achieve similar benefits in React by following some best practices:\n\n1. **Props**: In React, you can pass data and functions down the component tree via props. This is similar to dependency injection because you're providing dependencies to child components.\n\n2. **Context API**: React provides a Context API that allows you to share data and functions across components without explicitly passing them through props.\n\n3. **Third-Party Libraries**: You can also use third-party libraries like Redux or Mobx to manage the state and dependencies of your React application. These libraries provide a way to centralize and inject dependencies.\n\n4. **Custom Dependency Injection**: You can implement your own dependency injection mechanism in React by creating a custom context or using a third-party library designed for dependency injection.\n\nWhile React doesn't have dependency injection built in, you can achieve many of the same benefits by following best practices and using appropriate libraries and patterns to manage dependencies and state in your application.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 2
    }
  ],
  "react": [
    {
      "subject": "react",
      "title": "Basic Difference between Angular and React",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "a. Code organigation\nb. Framework v/s lib\nc. Code bundling\nd. Features - \n     i. routes, \n     ii. formComponents, \n     iii. services, \n     iv. directives, \n     v. pipes, \n     vi. dependency injection\n     \n     \nChatGPT\n---------\nAngular and React are two popular JavaScript frameworks used for building web applications. While they have some similarities, there are several key differences between them:\n\n1. **Architecture and Design Philosophy:**\n   - Angular: Angular is a complete framework that follows the Model-View-Controller (MVC) architectural pattern. It provides a comprehensive solution with a set of predefined practices and opinions on how to structure and develop applications.\n   - React: React is a JavaScript library focused on the View layer. It follows a component-based architecture and encourages a more flexible and modular approach to building UI components.\n\n2. **Language:**\n   - Angular: Angular is primarily written in TypeScript, a statically typed superset of JavaScript. It enforces strict typing and offers features like interfaces, classes, and decorators.\n   - React: React is written in JavaScript and supports both JavaScript and TypeScript. However, it doesn't require the use of TypeScript, and you can develop React applications using plain JavaScript.\n\n3. **Learning Curve:**\n   - Angular: Angular has a steeper learning curve due to its extensive features, complex concepts (such as dependency injection and decorators), and a large set of built-in tools and features.\n   - React: React has a relatively easier learning curve, especially for developers already familiar with JavaScript. It has a smaller API surface and focuses mainly on the component-based approach.\n\n4. **Size and Performance:**\n   - Angular: Angular applications tend to have a larger bundle size because of the framework's built-in features and overhead. It includes its own runtime and dependency injection system.\n   - React: React is lightweight and has a smaller bundle size compared to Angular. However, it requires additional libraries and tools for features like routing and state management.\n\n5. **Community and Ecosystem:**\n   - Angular: Angular has a mature and well-established ecosystem with a wide range of official and community-supported libraries, tools, and resources. It provides a more opinionated approach to development.\n   - React: React has a large and vibrant community with an extensive ecosystem. There are numerous third-party libraries and tools available for various needs, allowing developers more flexibility and choice.\n\n6. **Mobile Development:**\n   - Angular: Angular has built-in support for native mobile app development through the Ionic framework. It allows developers to create cross-platform mobile apps using Angular and web technologies.\n   - React: React offers React Native, a popular framework for building native mobile apps. React Native allows developers to write code once and deploy it on multiple platforms.\n\nIt's important to note that the choice between Angular and React often depends on project requirements, team expertise, and personal preferences. Both frameworks have their strengths and are widely used in the industry for different types of applications.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 1
    },
    {
      "subject": "react",
      "title": "Bare minimum library needed in react?",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "a. react\nb. react-dom\nc. redux\nd. react-redux\ne. react-router\nf. axiom\n\nChatGPT\n---------\n\nReact is a JavaScript library for building user interfaces. While React itself provides the core functionality for creating components and managing state, there are a few essential libraries that are commonly used alongside React in most projects. These libraries help with routing, state management, and other common tasks. Here are some of the bare minimum libraries that are often used in React projects:\n\n1. `react-dom`: This library is required to render React components in the browser. It provides the `ReactDOM.render()` method, which is used to mount your React components onto the DOM.\n\n2. `react-router-dom`: If your application involves multiple pages or routes, `react-router-dom` provides the necessary tools for client-side routing. It enables you to define routes, handle navigation, and render specific components based on the current URL.\n\n3. `prop-types`: While not strictly required, `prop-types` is a library used for defining and validating the props passed to React components. It helps ensure that the correct props are provided and can be helpful for debugging and maintaining your codebase.\n\n4. `axios` or `fetch`: These libraries are used for making HTTP requests to APIs. While you can use the built-in `fetch` API provided by modern browsers, libraries like `axios` offer additional features, such as request cancellation and response interception.\n\nThese are the essential libraries commonly used in React projects. However, depending on the specific requirements of your project, you may need additional libraries for state management (e.g., Redux, MobX), UI components (e.g., Material-UI, Ant Design), or form handling (e.g., Formik, React Hook Form).\n\nIt's worth noting that while these libraries are widely used and popular, they are not mandatory for every React project. The choice of additional libraries depends on the specific needs and complexity of your application.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 2
    },
    {
      "subject": "react",
      "title": "React Lifecycle in functional component and class component",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "\n\n\n\n\nChatGPT\n----------\nIn React, components have lifecycle methods that allow you to perform certain actions at different stages of a component's life. However, with the introduction of React Hooks, functional components can now also utilize lifecycle-like behavior. Here's a comparison of the lifecycle in functional components with React Hooks and class components:\n\n**Functional Components with React Hooks:**\n1. **Mounting:**\n   - `useEffect(() => {}, [])`: This is equivalent to the `componentDidMount` lifecycle method. It runs the provided callback function after the component is initially rendered and mounted.\n2. **Updating:**\n   - `useEffect(() => {})`: This is equivalent to the `componentDidUpdate` lifecycle method. It runs the provided callback function after each rendering cycle of the component.\n3. **Unmounting:**\n   - `useEffect(() => { return () => {} }, [])`: This is equivalent to the `componentWillUnmount` lifecycle method. The returned cleanup function runs when the component is about to be unmounted.\n\n**Class Components:**\n1. **Mounting:**\n   - `componentDidMount()`: This method is called once after the component is initially rendered and mounted to the DOM.\n2. **Updating:**\n   - `componentDidUpdate(prevProps, prevState)`: This method is called after the component updates and re-renders. It receives the previous props and state as parameters.\n3. **Unmounting:**\n   - `componentWillUnmount()`: This method is called right before the component is unmounted and destroyed.\n\nIt's important to note that React Hooks introduced the `useEffect` hook, which combines functionalities of multiple lifecycle methods into a single hook. By specifying dependencies as an array, you can control when the effect runs based on changes to specific props or state values.\n\nAdditionally, React Hooks provide other hooks like `useState`, `useContext`, and `useReducer` to manage state and context within functional components.\n\nOverall, React Hooks and functional components provide a simpler and more streamlined approach to managing component lifecycles, reducing the need for separate methods for different lifecycle stages as seen in class components.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 3
    },
    {
      "subject": "react",
      "title": "Stateless v/s stateful component",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "\n\n\n\n\nChatGPT\n---------\nIn React, components can be classified into two categories: stateless components and stateful components. Let's explore each of them and provide examples of both types:\n\n1. **Stateless Components (Functional Components):**\nStateless components, also known as functional components, are primarily concerned with rendering UI based on the props they receive. They don't have their own internal state and focus on presenting data passed to them. Stateless components are simpler and easier to understand and test.\n\nHere's an example of a stateless component in React:\n\n```jsx\nimport React from 'react';\n\nconst Greeting = ({ name }) => {\n  return <h1>Hello, {name}!</h1>;\n};\n\nexport default Greeting;\n```\n\nIn the above code, the `Greeting` component is a stateless component that receives a `name` prop and renders a greeting message. It takes the `name` prop as a parameter and displays it using JSX. This component doesn't manage any state and relies solely on the props passed to it.\n\n2. **Stateful Components (Class Components):**\nStateful components, also known as class components, have their own internal state and can handle events, perform actions, and update their state. They are more complex than stateless components and are suitable for managing more complex application logic and stateful behavior.\n\nHere's an example of a stateful component in React:\n\n```jsx\nimport React, { Component } from 'react';\n\nclass Counter extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0\n    };\n  }\n\n  incrementCount = () => {\n    this.setState(prevState => ({\n      count: prevState.count + 1\n    }));\n  };\n\n  render() {\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <button onClick={this.incrementCount}>Increment</button>\n      </div>\n    );\n  }\n}\n\nexport default Counter;\n```\n\nIn the above code, the `Counter` component is a stateful component that manages its own `count` state. It initializes the state in the constructor and provides a method `incrementCount` to update the count value. The `render` method displays the count value and a button that triggers the `incrementCount` method when clicked.\n\nStateful components have the ability to update their internal state using the `setState` method, triggering re-renders of the component and any child components that depend on the state.\n\nIn summary, stateless components are focused on rendering UI based on the props they receive, while stateful components have their own internal state and can handle events and perform actions. The choice between stateless and stateful components depends on the complexity of the component's behavior and the need for managing and updating state.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 4
    },
    {
      "subject": "react",
      "title": "Smart v/s dumb component",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "\n\nChatGPT\n---------\nIn React, the terms \"smart component\" and \"dumb component\" are sometimes used to describe different types of components based on their responsibilities and level of complexity. Let's explore each type and provide examples with code:\n\n1. **Smart Components (Container Components):**\nSmart components, also known as container components, are responsible for managing state, fetching data, and handling logic. They are typically more complex and deal with the business logic of the application. Smart components can contain both stateful and stateless components, coordinating the flow of data and behavior.\n\nHere's an example of a smart component in React:\n\n```jsx\nimport React, { Component } from 'react';\nimport UserList from './UserList';\nimport { fetchUsers } from '../api/userApi';\n\nclass UserContainer extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      users: []\n    };\n  }\n\n  componentDidMount() {\n    fetchUsers()\n      .then(users => {\n        this.setState({ users });\n      })\n      .catch(error => {\n        console.error('Error fetching users:', error);\n      });\n  }\n\n  render() {\n    return <UserList users={this.state.users} />;\n  }\n}\n\nexport default UserContainer;\n```\n\nIn the above code, the `UserContainer` component is a smart component responsible for fetching users from an API and managing the users' state. It uses the `componentDidMount` lifecycle method to fetch the users asynchronously when the component mounts. The fetched users are stored in the component's state and then passed as props to a child component `UserList`.\n\n2. **Dumb Components (Presentational Components):**\nDumb components, also known as presentational components, focus solely on rendering UI based on the props they receive. They have no internal state or logic and are primarily concerned with how things look. Dumb components receive data and callbacks as props and render them in a declarative manner.\n\nHere's an example of a dumb component in React:\n\n```jsx\nimport React from 'react';\n\nconst UserList = ({ users }) => {\n  return (\n    <div>\n      <h1>User List</h1>\n      <ul>\n        {users.map(user => (\n          <li key={user.id}>{user.name}</li>\n        ))}\n      </ul>\n    </div>\n  );\n};\n\nexport default UserList;\n```\n\nIn the above code, the `UserList` component is a dumb component that receives an array of `users` as props and renders them as a list. It doesn't have its own state or perform any data fetching or manipulation. It simply iterates over the `users` prop and renders the names of users in an unordered list.\n\nDumb components are reusable and purely focused on presenting UI based on the provided props. They are easier to understand, test, and maintain as they have clear responsibilities.\n\nIn summary, smart components (container components) handle state, data fetching, and logic, while dumb components (presentational components) focus on rendering UI based on props. Separating components into these categories helps with code organization, reusability, and maintainability. Smart components handle the complexity of the application, while dumb components focus on rendering and presentation.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 5
    },
    {
      "subject": "react",
      "title": "Class v/s functional component, code example",
      "ques": "",
      "links": [
        {
          "name": "https://stackblitz.com/edit/stackblitz-starters-v7hs8g?file=src%2FCustomer.tsx"
        }
      ],
      "tags": [],
      "ans": "Sure! Let's compare a class component and a functional component in React by providing code examples for both:\n\n**Class Component:**\n\n```jsx\nimport React, { Component } from 'react';\n\nclass Counter extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0\n    };\n  }\n\n  incrementCount = () => {\n    this.setState(prevState => ({\n      count: prevState.count + 1\n    }));\n  };\n\n  render() {\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <button onClick={this.incrementCount}>Increment</button>\n      </div>\n    );\n  }\n}\n\nexport default Counter;\n```\n\nIn the above code, we have a class component called `Counter`. It extends the `Component` class from React, and its state is initialized in the constructor with a `count` value of 0. The component has a method called `incrementCount` that updates the state by incrementing the `count` value. The updated count is displayed in the render method, along with a button that triggers the `incrementCount` method when clicked.\n\n**Functional Component:**\n\n```jsx\nimport React, { useState } from 'react';\n\nconst Counter = () => {\n  const [count, setCount] = useState(0);\n\n  const incrementCount = () => {\n    setCount(prevCount => prevCount + 1);\n  };\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={incrementCount}>Increment</button>\n    </div>\n  );\n};\n\nexport default Counter;\n```\n\nIn the above code, we have a functional component called `Counter`. It utilizes the `useState` hook from React to manage the `count` state. The `useState` hook initializes the state with a value of 0 and returns an array with two elements: the current state value and a function to update the state. The component renders the count value and a button that triggers the `incrementCount` function to update the state when clicked.\n\nBoth examples achieve the same functionality of incrementing a counter value, but they differ in syntax and structure. Class components use a class-based syntax and extend the `Component` class, while functional components are JavaScript functions using the functional component syntax. Functional components utilize hooks, such as `useState`, to manage state and perform side effects.\n\nIt's worth noting that functional components have become the preferred approach in React due to their simplicity, reusability, and easier testing. However, class components are still relevant, especially in legacy codebases or when working with older versions of React that don't support hooks.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 6
    },
    {
      "subject": "react",
      "title": "Redux example - claas v/s hooks",
      "ques": "",
      "links": [
        {
          "name": "https://jsbin.com/depavejudi/1/edit?js,output"
        },
        {
          "name": "https://stackblitz.com/edit/react-6swqv4?file=src%2Fcomponents%2FHeader.js"
        }
      ],
      "tags": [],
      "ans": "Certainly! Let's compare a Redux example implemented using class components and hooks.\n\n**Redux with Class Components:**\n\n```jsx\n// CounterActions.js\nexport const increment = () => {\n  return {\n    type: 'INCREMENT'\n  };\n};\n\n// CounterReducer.js\nconst initialState = {\n  count: 0\n};\n\nconst counterReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case 'INCREMENT':\n      return {\n        ...state,\n        count: state.count + 1\n      };\n    default:\n      return state;\n  }\n};\n\nexport default counterReducer;\n\n// Counter.js\nimport React from 'react';\nimport { connect } from 'react-redux';\nimport { increment } from './CounterActions';\n\nclass Counter extends React.Component {\n  render() {\n    return (\n      <div>\n        <p>Count: {this.props.count}</p>\n        <button onClick={this.props.increment}>Increment</button>\n      </div>\n    );\n  }\n}\n\nconst mapStateToProps = state => {\n  return {\n    count: state.count\n  };\n};\n\nconst mapDispatchToProps = dispatch => {\n  return {\n    increment: () => dispatch(increment())\n  };\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(Counter);\n```\n\nIn the above code, we have a counter application implemented using Redux with class components. The `CounterActions.js` file defines an action creator `increment` that returns an action object with the type `'INCREMENT'`. The `CounterReducer.js` file sets up the initial state and a reducer function that handles the `'INCREMENT'` action by updating the count value in the state.\n\nThe `Counter` component connects to the Redux store using the `connect` function from `react-redux`. It receives the count value from the store as a prop and the `increment` action creator as a prop. When the increment button is clicked, it dispatches the `increment` action to the Redux store.\n\n**Redux with Functional Components and Hooks:**\n\n```jsx\n// CounterActions.js\nexport const increment = () => {\n  return {\n    type: 'INCREMENT'\n  };\n};\n\n// CounterReducer.js\nconst initialState = {\n  count: 0\n};\n\nconst counterReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case 'INCREMENT':\n      return {\n        ...state,\n        count: state.count + 1\n      };\n    default:\n      return state;\n  }\n};\n\nexport default counterReducer;\n\n// Counter.js\nimport React from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { increment } from './CounterActions';\n\nconst Counter = () => {\n  const count = useSelector(state => state.count);\n  const dispatch = useDispatch();\n\n  const handleIncrement = () => {\n    dispatch(increment());\n  };\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={handleIncrement}>Increment</button>\n    </div>\n  );\n};\n\nexport default Counter;\n```\n\nIn the above code, we have the same counter application implemented using functional components and hooks. Instead of using class components, we utilize the `useSelector` and `useDispatch` hooks from `react-redux` to access the state and dispatch actions.\n\nThe `Counter` component uses the `useSelector` hook to get the `count` value from the Redux store. It also uses the `useDispatch` hook to get the dispatch function. When the increment button is clicked, it calls the `handleIncrement` function, which dispatches the `increment` action to the Redux store.\n\nFunctional components with hooks provide a more concise and modern approach to working with Redux, eliminating the need for class components, mapStateToProps, and mapDispatchToProps. Hooks make it easier to access state and dispatch\n\n actions directly within the component function.\n\nBoth the class component and functional component examples achieve the same result of incrementing a counter using Redux. However, the functional component with hooks approach is generally preferred in modern React applications due to its simplicity and reduced boilerplate.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 7
    },
    {
      "subject": "react",
      "title": "How to implement tree like structure for directory and files in react with state to open close directory",
      "ques": "",
      "links": [
        {
          "name": "https://stackblitz.com/edit/stackblitz-starters-ydskrn"
        },
        {
          "name": "https://stackblitz.com/edit/stackblitz-starters-fiskxu?file=src%2Ffile.json,src%2FApp.tsx,src%2FFileTree.tsx,src%2FFileNode.tsx"
        }
      ],
      "tags": [],
      "ans": "To implement a tree-like structure for directories and files in React with state to open/close directories, you can create a recursive component that represents each directory and file. Here's an example implementation:\n\n```jsx\nimport React, { useState } from 'react';\n\nconst TreeNode = ({ node }) => {\n  const [isOpen, setIsOpen] = useState(false);\n\n  const handleToggle = () => {\n    setIsOpen(!isOpen);\n  };\n\n  const renderChildNodes = () => {\n    if (node.children && node.children.length > 0) {\n      return (\n        <ul>\n          {node.children.map((child) => (\n            <li key={child.id}>\n              <TreeNode node={child} />\n            </li>\n          ))}\n        </ul>\n      );\n    }\n    return null;\n  };\n\n  return (\n    <div>\n      <div onClick={handleToggle}>\n        {isOpen ? <span>-</span> : <span>+</span>}\n        {node.name}\n      </div>\n      {isOpen && renderChildNodes()}\n    </div>\n  );\n};\n\nexport default TreeNode;\n```\n\nIn the above code, the `TreeNode` component represents a single node in the directory tree. It takes a `node` prop, which contains information about the directory or file, including its name, children (subdirectories/files), and an identifier (`id`).\n\nThe `isOpen` state is used to track whether the directory node is open or closed. The `handleToggle` function toggles the state value when the node is clicked.\n\nThe `renderChildNodes` function recursively renders child nodes if the current node has children. It maps through each child and recursively renders the `TreeNode` component for them.\n\nInside the `return` statement of the component, the directory or file name is displayed along with a toggle icon. Clicking on the toggle icon triggers the `handleToggle` function to open/close the node. If the node is open (`isOpen` is `true`), the child nodes are rendered.\n\nTo use the `TreeNode` component, you can pass the root node of your directory structure as a prop:\n\n```jsx\nimport React from 'react';\nimport TreeNode from './TreeNode';\n\nconst DirectoryTree = () => {\n  const rootDirectory = {\n    id: 1,\n    name: 'Root',\n    children: [\n      {\n        id: 2,\n        name: 'Folder 1',\n        children: [\n          {\n            id: 4,\n            name: 'Subfolder 1',\n            children: [],\n          },\n          {\n            id: 5,\n            name: 'Subfolder 2',\n            children: [\n              {\n                id: 6,\n                name: 'File 1',\n              },\n              {\n                id: 7,\n                name: 'File 2',\n              },\n            ],\n          },\n        ],\n      },\n      {\n        id: 3,\n        name: 'Folder 2',\n        children: [],\n      },\n    ],\n  };\n\n  return (\n    <div>\n      <TreeNode node={rootDirectory} />\n    </div>\n  );\n};\n\nexport default DirectoryTree;\n```\n\nIn the `DirectoryTree` component, you can define the directory structure using an object representing the root directory and its children. Each directory or file can have an `id`, `name`, and `children` property. Pass the root directory to the `TreeNode` component as a prop.\n\nThis implementation creates a collapsible tree structure where you can open/close directories by clicking on the toggle icon. Child directories/files will be displayed when a directory is open. You can further customize the appearance and behavior based on your requirements.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 8
    },
    {
      "subject": "react",
      "title": "How to use useSelector in react, explain with code example",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "In React, `useSelector` is a hook provided by the `react-redux` library that allows you to access the Redux store's state in your functional components. Redux is a state management library commonly used with React applications.\n\nTo use `useSelector`, you need to have a Redux store set up in your application, and you should have wrapped your main component tree with the `Provider` from `react-redux`. The `Provider` makes the Redux store available to all the components in your application.\n\nHere's a step-by-step guide on how to use `useSelector` in a React functional component:\n\nStep 1: Install Dependencies\nMake sure you have installed `react-redux` and `redux` in your project by running:\n\n```bash\nnpm install react-redux redux\n```\n\nStep 2: Create a Redux Store\nCreate a Redux store with reducers, actions, and middleware as needed for your application. For simplicity, let's assume we have a basic store with a single reducer managing a list of items.\n\n```jsx\n// store.js\n\nimport { createStore } from 'redux';\n\nconst initialState = {\n  items: [],\n};\n\nconst itemReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case 'ADD_ITEM':\n      return {\n        ...state,\n        items: [...state.items, action.payload],\n      };\n    default:\n      return state;\n  }\n};\n\nconst store = createStore(itemReducer);\n\nexport default store;\n```\n\nStep 3: Wrap your Component with `Provider`\nWrap your main component tree with the `Provider` component, passing the `store` as a prop.\n\n```jsx\n// index.js (or wherever you render your app)\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\nimport store from './store';\nimport App from './App';\n\nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById('root')\n);\n```\n\nStep 4: Use `useSelector` in your Component\nNow, you can use the `useSelector` hook in your functional component to access the state from the Redux store.\n\n```jsx\n// App.js\n\nimport React from 'react';\nimport { useSelector } from 'react-redux';\n\nconst App = () => {\n  // Using the useSelector hook to access the 'items' state from the Redux store\n  const items = useSelector((state) => state.items);\n\n  const renderItems = () => {\n    return items.map((item, index) => <li key={index}>{item}</li>);\n  };\n\n  return (\n    <div>\n      <h1>Items List</h1>\n      <ul>{renderItems()}</ul>\n    </div>\n  );\n};\n\nexport default App;\n```\n\nIn this example, the `useSelector` hook is used to extract the `items` state from the Redux store. The `items` array can now be used within the `App` component to render a list of items.\n\nRemember that the `useSelector` hook automatically subscribes to the Redux store and updates the component whenever the state it depends on changes. This allows your component to stay in sync with the global state managed by Redux without having to manually subscribe or unsubscribe to the store.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 9
    },
    {
      "subject": "react",
      "title": "what are different hooks in reacts, explain each one in simple words and code example",
      "ques": "",
      "links": [
        {
          "name": "https://www.smashingmagazine.com/2021/11/useful-react-hooks/"
        },
        {
          "name": "https://dev.to/abhisheknaiidu/10-react-hooks-explained-3ino"
        },
        {
          "name": "https://betterprogramming.pub/rundown-of-the-most-important-react-hooks-5c9ec4cac5a2"
        }
      ],
      "tags": [],
      "ans": "As of my knowledge cutoff date in September 2021, React provides several built-in hooks to add state and lifecycle features to functional components. Here are some commonly used React hooks along with simple explanations and code examples for each:\n\n1. `useState`:\n\nExplanation: `useState` is a hook used for managing state in functional components. It allows you to declare state variables and provides a function to update the state, which triggers a re-render of the component with the updated state.\n\nCode Example:\n\n```jsx\nimport React, { useState } from 'react';\n\nconst Counter = () => {\n  const [count, setCount] = useState(0);\n\n  const increment = () => {\n    setCount(count + 1);\n  };\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={increment}>Increment</button>\n    </div>\n  );\n};\n\nexport default Counter;\n```\n\n2. `useEffect`:\n\nExplanation: `useEffect` is a hook used for handling side effects in functional components. It allows you to perform actions after the component renders, such as fetching data, subscribing to events, or cleaning up resources.\n\nCode Example:\n\n```jsx\nimport React, { useState, useEffect } from 'react';\n\nconst DataFetcher = () => {\n  const [data, setData] = useState([]);\n\n  useEffect(() => {\n    // Fetch data from an API after the component renders\n    fetch('https://api.example.com/data')\n      .then(response => response.json())\n      .then(data => setData(data))\n      .catch(error => console.error(error));\n\n    // Clean up resources (optional)\n    return () => {\n      // Do cleanup here (e.g., canceling subscriptions, closing connections)\n    };\n  }, []);\n\n  return (\n    <div>\n      {data.map(item => (\n        <p key={item.id}>{item.name}</p>\n      ))}\n    </div>\n  );\n};\n\nexport default DataFetcher;\n```\n\n3. `useContext`:\n\nExplanation: `useContext` is a hook used for consuming data from a React context. It allows you to access data provided by a parent component without having to pass props through intermediary components. This is useful for sharing data across a component tree without manually passing it down through every level.\n\nCode Example:\n\n```jsx\nimport React, { useContext } from 'react';\n\nconst UserContext = React.createContext();\n\nconst Profile = () => {\n  const user = useContext(UserContext);\n\n  return (\n    <div>\n      <h1>{user.name}</h1>\n      <p>Email: {user.email}</p>\n    </div>\n  );\n};\n\nconst App = () => {\n  const user = {\n    name: 'John Doe',\n    email: 'john.doe@example.com',\n  };\n\n  return (\n    <UserContext.Provider value={user}>\n      <Profile />\n    </UserContext.Provider>\n  );\n};\n\nexport default App;\n```\n\n4. `useReducer`:\n\nExplanation: `useReducer` is a hook used for more complex state management. It is an alternative to `useState` when state changes depend on the previous state or when the state logic is more complex.\n\nCode Example:\n\n```jsx\nimport React, { useReducer } from 'react';\n\nconst initialState = { count: 0 };\n\nconst reducer = (state, action) => {\n  switch (action.type) {\n    case 'increment':\n      return { count: state.count + 1 };\n    case 'decrement':\n      return { count: state.count - 1 };\n    default:\n      return state;\n  }\n};\n\nconst Counter = () => {\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  return (\n    <div>\n      <p>Count: {state.count}</p>\n      <button onClick={() => dispatch({ type: 'increment' })}>Increment</button>\n      <button onClick={() => dispatch({ type: 'decrement' })}>Decrement</button>\n    </div>\n  );\n};\n\nexport default Counter;\n```\n\n5. `useMemo`:\n\nExplanation: `useMemo` is a hook used for memoizing expensive computations. It allows you to memoize the result of a computation and prevent unnecessary re-computation on every render.\n\nCode Example:\n\n```jsx\nimport React, { useState, useMemo } from 'react';\n\nconst ExpensiveComponent = () => {\n  // Some expensive computation here\n  const expensiveValue = useMemo(() => {\n    console.log('Expensive computation...');\n    return 10 + 20;\n  }, []);\n\n  return <div>Expensive Value: {expensiveValue}</div>;\n};\n\nexport default ExpensiveComponent;\n```\n\nIn this example, the expensive computation (10 + 20) will only be performed once, and the memoized value (30) will be reused in subsequent renders.\n\n6. `useCallback`:\n\nExplanation: `useCallback` is a hook used for memoizing event handlers or functions to prevent unnecessary re-creation of functions on every render. It is especially useful when passing functions as props to child components.\n\nCode Example:\n\n```jsx\nimport React, { useState, useCallback } from 'react';\n\nconst ClickButton = ({ onClick }) => {\n  console.log('Button rendered');\n  return <button onClick={onClick}>Click Me</button>;\n};\n\nconst ParentComponent = () => {\n  const [count, setCount] = useState(0);\n\n  // The handleButtonClick function is memoized using useCallback\n  const handleButtonClick = useCallback(() => {\n    console.log('Button clicked');\n    setCount(count + 1);\n  }, [count]);\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <ClickButton onClick={handleButtonClick} />\n    </div>\n  );\n};\n\nexport default ParentComponent;\n```\n\nIn this example, the `handleButtonClick` function is memoized using `useCallback`. It prevents the `handleButtonClick` function from being re-created on every render of the `ParentComponent`. This is useful to avoid unnecessary re-renders of the `ClickButton` component since the `handleButtonClick` prop remains the same as long as the `count` state does not change.\n\nThese are some of the widely used React hooks along with simple explanations and code examples for each. Please note that the availability and usage of hooks may change in newer versions of React, and there might be additional hooks introduced in\n\n the future. Always refer to the official React documentation for the most up-to-date information and best practices on using React hooks.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 10
    },
    {
      "subject": "react",
      "title": "Merge state in react using \"state\" method?",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "Yes, you can use the `state` method to merge state in React class components. In React class components, the `state` property holds the current state of the component, and you can directly access and modify it using `this.state`.\n\nTo update the state and merge new values into the existing state, you should not directly modify the state object, as directly modifying `this.state` will not trigger a re-render of the component. Instead, you should use the `setState` method provided by React's component class to update the state and trigger a re-render.\n\nHere's an example of how to use the `setState` method to merge state in a React class component:\n\n```jsx\nimport React, { Component } from 'react';\n\nclass MyComponent extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0,\n      name: 'John',\n    };\n  }\n\n  handleIncrement = () => {\n    // Using setState to merge new state into the existing state\n    this.setState({ count: this.state.count + 1 });\n  };\n\n  handleNameChange = () => {\n    // Using setState to merge new state into the existing state\n    this.setState({ name: 'Alice' });\n  };\n\n  render() {\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <p>Name: {this.state.name}</p>\n        <button onClick={this.handleIncrement}>Increment</button>\n        <button onClick={this.handleNameChange}>Change Name</button>\n      </div>\n    );\n  }\n}\n\nexport default MyComponent;\n```\n\nIn this example, we use the `setState` method to update the state and merge new values into the existing state. This will trigger a re-render of the component with the updated state values.\n\nKeep in mind that if you are using functional components with React Hooks, you should use the `useState` hook to manage state instead of using the `state` method in class components. Functional components with Hooks provide a more modern and cleaner way to handle state management in React.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 11
    },
    {
      "subject": "react",
      "title": "does findDOMNode belong to react-dom?",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "Yes, you are correct. The `findDOMNode()` function belongs to the `react-dom` package in React.\n\n`ReactDOM.findDOMNode()` is a method provided by the `react-dom` package, and it is used to get a reference to the underlying DOM node of a mounted React component. This function is primarily used in class components to access the actual DOM element that the component renders.\n\nHere's an example of how to use `ReactDOM.findDOMNode()`:\n\n```jsx\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n\nclass MyComponent extends React.Component {\n  componentDidMount() {\n    const domNode = ReactDOM.findDOMNode(this);\n    // Now, you can use domNode to interact with the underlying DOM element.\n  }\n\n  render() {\n    return <div>Hello, World!</div>;\n  }\n}\n\nexport default MyComponent;\n```\n\nIn this example, the `componentDidMount()` lifecycle method is used to get the underlying DOM node of the `MyComponent` instance using `ReactDOM.findDOMNode(this)`.\n\nIt's important to note that `findDOMNode()` is considered a legacy API, and its usage is discouraged in modern React applications, especially in functional components. Instead, React provides better alternatives like using `ref` with `createRef()` or the `useRef()` hook to access DOM nodes in functional components.\n\nFor class components, you can still use `ref` with the callback approach to get a reference to the DOM node without using `findDOMNode()`. For example:\n\n```jsx\nclass MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.myRef = React.createRef();\n  }\n\n  componentDidMount() {\n    const domNode = this.myRef.current;\n    // Now, you can use domNode to interact with the underlying DOM element.\n  }\n\n  render() {\n    return <div ref={this.myRef}>Hello, World!</div>;\n  }\n}\n```\n\nUsing `ref` with the `createRef()` or `useRef()` approach is the recommended way to access DOM nodes in modern React applications, as it is more in line with React's declarative and unidirectional data flow principles.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 12
    },
    {
      "subject": "react",
      "title": "does mountCOmponentAtReact belong to react-dom?",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "I apologize for the confusion in my previous response. There was a mistake in the method name. The correct method is `unmountComponentAtNode`, not `mountComponentAtReact`.\n\nYes, `unmountComponentAtNode()` is indeed part of the `react-dom` package in React.\n\n`ReactDOM.unmountComponentAtNode()` is a method provided by the `react-dom` package, and it is used to unmount a mounted React component from a specified DOM container. When you call this method with the DOM container as an argument, it will remove the mounted React component from the container, effectively cleaning up the component and its associated event listeners.\n\nHere's the correct usage of `unmountComponentAtNode()`:\n\n```jsx\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n\nconst App = () => {\n  const container = document.getElementById('root');\n\n  // Mount the component in the container\n  ReactDOM.render(<MyComponent />, container);\n\n  // Unmount the component from the container\n  ReactDOM.unmountComponentAtNode(container);\n\n  return null; // This component doesn't render anything, so return null\n};\n\nexport default App;\n```\n\nIn the above example, we first use `ReactDOM.render()` to mount the `MyComponent` into the `container` DOM element. Then, we call `ReactDOM.unmountComponentAtNode()` to unmount the component from the same `container`.\n\nAgain, I apologize for the oversight in my previous response. `unmountComponentAtNode()` is the correct method related to unmounting components in React using the `react-dom` package.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 13
    },
    {
      "subject": "react",
      "title": "which are methods of react-dom package?",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "As of my knowledge cutoff date in September 2021, the `react-dom` package provides the following methods:\n\n1. `render()`: This method is used to render a React element into the DOM. It takes a React element and a DOM container as arguments and mounts the element into the container. For example:\n\n```jsx\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n\nconst element = <h1>Hello, World!</h1>;\nconst container = document.getElementById('root');\n\nReactDOM.render(element, container);\n```\n\n2. `hydrate()`: This method is similar to `render()`, but it is specifically used for server-side rendered content. It takes a React element and a DOM container as arguments and hydrates the container with the element, preserving the server-rendered content. For example:\n\n```jsx\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n\nconst element = <h1>Hello, World!</h1>;\nconst container = document.getElementById('root');\n\nReactDOM.hydrate(element, container);\n```\n\n3. `unmountComponentAtNode()`: This method is used to unmount a mounted React component from a DOM container. It takes the DOM container as an argument and removes the mounted component from the container. For example:\n\n```jsx\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n\nconst container = document.getElementById('root');\n\n// Mount a component in the container\nReactDOM.render(<App />, container);\n\n// Unmount the component from the container\nReactDOM.unmountComponentAtNode(container);\n```\n\n4. `createPortal()`: This method is used to render a React component's children into a different DOM node outside of its parent component's normal hierarchy. It takes the children to render and a DOM container as arguments and returns a portal element that represents the rendered content. For example:\n\n```jsx\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n\nconst Modal = ({ children }) => {\n  const modalRoot = document.getElementById('modal-root');\n  return ReactDOM.createPortal(\n    <div className=\"modal\">\n      {children}\n    </div>,\n    modalRoot\n  );\n};\n```\n\nThese are the main methods provided by the `react-dom` package. Keep in mind that there might be additional methods or changes in the package's API in newer versions of React. Always refer to the official React documentation for the most up-to-date information and usage details.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 14
    },
    {
      "subject": "react",
      "title": "which all pointer Events supported in React?",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "As of my knowledge cutoff date in September 2021, React supports the following pointer events:\n\n1. `onPointerDown`: This event is fired when a pointing device (e.g., mouse, touchscreen) is pressed down on an element.\n\n2. `onPointerMove`: This event is fired when a pointing device is moved while over an element.\n\n3. `onPointerUp`: This event is fired when a pointing device is released after being pressed down on an element.\n\n4. `onPointerEnter`: This event is fired when a pointing device enters the hit test boundaries of an element.\n\n5. `onPointerLeave`: This event is fired when a pointing device leaves the hit test boundaries of an element.\n\n6. `onPointerOver`: This event is fired when a pointing device is moved onto an element or one of its child elements.\n\n7. `onPointerOut`: This event is fired when a pointing device is moved off an element or one of its child elements.\n\n8. `onPointerCancel`: This event is fired when a pointer event is canceled.\n\nThese pointer events provide a way to handle user interactions with elements using different pointing devices, such as a mouse, touchscreen, or pen. They are part of the Pointer Events API, which is supported by modern web browsers.\n\nIt's important to note that browser support for pointer events may vary, and some older browsers may not fully support all of these events. As always, it's recommended to check the compatibility of pointer events with the target browsers or consider using fallbacks or alternative event handling methods when necessary. Additionally, be sure to check the latest documentation and updates from React and browser vendors for any changes or additions to the supported pointer events.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 15
    },
    {
      "subject": "react",
      "title": "what are good use cases of HOCs in react?",
      "ques": "",
      "links": [
        {
          "name": "https://www.smashingmagazine.com/2020/06/higher-order-components-react/"
        }
      ],
      "tags": [],
      "ans": "Higher-Order Components (HOCs) are a powerful pattern in React that allows you to enhance or modify the behavior of components. HOCs are functions that take a component as input and return a new component with additional props or behavior. They can be used for a wide range of use cases in React. Here are some good use cases for Higher-Order Components:\n\n1. Reusability: HOCs enable you to encapsulate certain behavior or logic in a separate function and apply it to multiple components. This promotes code reusability, reducing duplication across your codebase.\n\n2. Code Separation: HOCs help you separate concerns and keep your components focused on their primary responsibilities. By moving shared logic into HOCs, your components can stay clean and easier to maintain.\n\n3. Authentication and Authorization: HOCs can be used to enforce authentication and authorization checks before rendering certain components. For example, you can create an HOC that checks if a user is logged in and then renders the protected component.\n\n4. Data Fetching: HOCs can handle data fetching and loading states for components. They can abstract the API calls and provide the fetched data to the wrapped component as props.\n\n5. Injecting Context: HOCs can inject specific context data into components, making it available as props. This allows components to access data from a context without needing to be direct consumers of the context API.\n\n6. Performance Optimization: HOCs can be used to optimize performance by implementing memoization or caching. This can prevent unnecessary re-renders and improve the overall efficiency of your components.\n\n7. Theming and Styling: HOCs can provide components with theme or styling information. For instance, you can create an HOC that injects a theme object into components, allowing them to style themselves based on the provided theme.\n\n8. Error Handling: HOCs can be used to wrap components and handle error scenarios. For instance, you can create an HOC that catches errors in the wrapped component and displays a fallback UI or logs the errors for debugging.\n\n9. Redux Integration: HOCs can be used to connect components to a Redux store, abstracting away the details of Redux integration and providing the necessary state and dispatch functions as props.\n\n10. Debugging and Logging: HOCs can be used to add logging or debugging capabilities to components. This can be helpful during development to gain insights into component behavior.\n\nOverall, Higher-Order Components are a versatile pattern in React that can be used to enhance components in various ways, promoting code reusability, separation of concerns, and better maintainability. However, with the introduction of React Hooks and other patterns, it's essential to consider other alternatives like render props and custom hooks when choosing the best approach for a particular use case.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 16
    },
    {
      "subject": "react",
      "title": "when it is recomended to pass this.setState as function instead of object in react?",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "In React, there are certain scenarios where it is recommended to pass `this.setState` as a function instead of an object. The primary reason for doing this is to ensure that the state updates are based on the previous state correctly, especially when dealing with asynchronous updates or when state updates depend on the current state.\n\nWhen using `this.setState` as a function, the function receives the previous state and props as arguments, and it returns an object representing the new state based on the previous state and props. This helps avoid issues with stale state and ensures that state updates are correctly based on the previous values.\n\nHere's an example to illustrate the recommended usage of `this.setState` as a function:\n\n```jsx\nimport React, { Component } from 'react';\n\nclass Counter extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0,\n    };\n  }\n\n  handleIncrement = () => {\n    // Using setState as a function, ensuring correct updates based on the previous state\n    this.setState((prevState) => ({ count: prevState.count + 1 }));\n  };\n\n  handleDoubleIncrement = () => {\n    // If you need to perform multiple state updates, use the function form to ensure they are batched correctly\n    this.setState((prevState) => ({ count: prevState.count + 1 }));\n    this.setState((prevState) => ({ count: prevState.count + 1 }));\n  };\n\n  render() {\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <button onClick={this.handleIncrement}>Increment</button>\n        <button onClick={this.handleDoubleIncrement}>Double Increment</button>\n      </div>\n    );\n  }\n}\n\nexport default Counter;\n```\n\nIn the above example, we use `this.setState` as a function in the `handleIncrement` method. This ensures that the new state is based on the previous state, and multiple consecutive updates will be correctly batched together.\n\nIt is recommended to use the function form of `this.setState` in the following scenarios:\n\n1. When the new state depends on the previous state.\n2. When performing multiple consecutive updates to the state, as it ensures that they are correctly batched together.\n\nUsing the function form of `this.setState` helps avoid issues related to stale state and can lead to more predictable behavior in your React components.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 17
    },
    {
      "subject": "react",
      "title": "does keys for list of element should be unique in the DOM or siblings only?",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "In React, the keys for a list of elements should be unique among their siblings. They are used to help React identify individual elements when rendering lists and to efficiently update the DOM when the list changes.\n\nWhen you create a list of elements in React using the `map()` function or any other method that generates an array of elements, React needs a way to distinguish between elements and keep track of their identities. That's where the `key` prop comes into play.\n\nThe `key` prop should be unique among the siblings of a particular list. This uniqueness is necessary for React's reconciliation process to work correctly and optimize DOM updates. When a list changes (e.g., elements are added, removed, or reordered), React uses the keys to efficiently update only the elements that have changed, rather than re-rendering the entire list.\n\nKeys don't have to be globally unique across the entire application or the entire DOM. They only need to be unique among siblings in the specific list that you are rendering.\n\nHere's an example of how to use the `key` prop in a list of elements:\n\n```jsx\nconst MyListComponent = () => {\n  const data = ['apple', 'banana', 'orange'];\n\n  return (\n    <ul>\n      {data.map((item, index) => (\n        <li key={index}>{item}</li>\n      ))}\n    </ul>\n  );\n};\n```\n\nIn this example, we're rendering a list of fruits (`data` array) as list items (`<li>` elements). The `key` prop is set to the `index` of each item in the array. While using the array index as keys is convenient in some cases, it's generally better to use unique IDs or other stable values when possible, especially if the list items can be reordered or change dynamically.\n\nRemember, when rendering lists in React, always ensure that the `key` prop is unique among the siblings within the list to ensure proper rendering and efficient updates.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 18
    },
    {
      "subject": "react",
      "title": "does react.lazy support named export only?",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "As of my knowledge cutoff date in September 2021, React's `React.lazy` function does not directly support named exports. Instead, it is designed to work with default exports. This means that when you use `React.lazy`, you can only dynamically import components that have been exported as the default export in the module.\n\nHere's an example of how you would use `React.lazy` with a default export:\n\n```jsx\nconst MyLazyComponent = React.lazy(() => import('./MyLazyComponent'));\n```\n\nIn this example, `MyLazyComponent` is the default export from the `'./MyLazyComponent'` module.\n\nHowever, if you have a component with named exports, you can still use `React.lazy` indirectly by creating a separate file that imports the named exports and then exports them as a default export.\n\nFor example, if you have a component with named exports like this:\n\n```jsx\n// MyNamedComponent.js\nexport const ComponentA = () => {\n  return <div>Component A</div>;\n};\n\nexport const ComponentB = () => {\n  return <div>Component B</div>;\n};\n```\n\nYou can create a separate file to export them as a default export like this:\n\n```jsx\n// LazyComponents.js\nexport { ComponentA, ComponentB } from './MyNamedComponent';\n```\n\nThen, you can use `React.lazy` with the default export from the `LazyComponents.js` file:\n\n```jsx\nconst LazyComponentA = React.lazy(() => import('./LazyComponents').then(module => ({ default: module.ComponentA })));\nconst LazyComponentB = React.lazy(() => import('./LazyComponents').then(module => ({ default: module.ComponentB })));\n```\n\nKeep in mind that this workaround may become unnecessary in future versions of React as the library evolves and introduces new features. Always refer to the official React documentation for the latest information and updates on React features and API changes.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 19
    },
    {
      "subject": "react",
      "title": "which methods define default value of props from these getPropsValue, getInitialState, GetInitialProps, getDefaultprops?",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "In React, the method that defines the default value of props is `getDefaultProps`. The other methods you mentioned (`getPropsValue`, `getInitialState`, and `getInitialProps`) are not standard React component methods for setting default props.\n\n1. `getDefaultProps`: This is a method used in class components to define the default values for props. It allows you to set default props for the component, which will be used if the parent component does not provide those props when rendering the child component. However, note that the use of `getDefaultProps` is mainly relevant for React class components, and it is not used in modern React functional components.\n\nExample of using `getDefaultProps` in a class component:\n\n```jsx\nimport React from 'react';\n\nclass MyComponent extends React.Component {\n  // Define default props using getDefaultProps method\n  static defaultProps = {\n    name: 'John',\n    age: 30,\n  };\n\n  render() {\n    return (\n      <div>\n        <p>Name: {this.props.name}</p>\n        <p>Age: {this.props.age}</p>\n      </div>\n    );\n  }\n}\n\nexport default MyComponent;\n```\n\n2. `getPropsValue`, `getInitialState`, and `getInitialProps`: These methods are not part of the standard React component API, and you generally won't find them in official React documentation or examples. The standard ways to work with props and state in React components are through `props`, `state`, and lifecycle methods like `constructor`, `render`, `componentDidMount`, and others. Additionally, `getInitialProps` is specific to Next.js, which is a framework for server-rendered React applications, and it is used in Next.js pages, not in standard React components.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 20
    },
    {
      "subject": "react",
      "title": "is \"hydrate()\" part of react-dom?",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "Yes, you are correct. The `hydrate()` function is part of the `react-dom` package in React.\n\nIn React, `hydrate()` is used to render a React application into the DOM. It is similar to the `render()` function provided by `react-dom`, but it is specifically designed",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 21
    },
    {
      "subject": "react",
      "title": "is \"findDOMNode()\" part of react-dom?",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "Yes, `findDOMNode()` is a method provided by the `react-dom` package in React.\n\n`react-dom` is a separate package from the main `react` package and is used specifically for rendering React components into the DOM (Document Object Model). It provides additional functionalities related to interacting with the DOM, such as finding and manipulating DOM elements that correspond to React components.\n\nThe `findDOMNode()` method was introduced in React as a way to access the DOM node of a mounted React component. It allows you to get a reference to the actual DOM element that a React component is rendering. This can be useful in certain situations, especially when you need to interact directly with the DOM, use third-party libraries that require DOM elements, or when working with legacy code.\n\nHowever, it's important to note that `findDOMNode()` is considered to be legacy API, and the React team recommends using other approaches, such as using React's `ref` system or the hooks API (`useRef()` hook), to interact with the DOM in modern React applications. The main reason for this recommendation is that direct manipulation of the DOM can bypass React's virtual DOM, potentially leading to performance issues and other problems.\n\nHere's an example of how you might use `findDOMNode()`:\n\n```jsx\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n\nclass MyComponent extends React.Component {\n  componentDidMount() {\n    const domNode = ReactDOM.findDOMNode(this);\n    // Now, you can use domNode to interact with the underlying DOM element.\n    // However, it's recommended to use the `ref` system or hooks instead.\n  }\n\n  render() {\n    return <div>Hello, World!</div>;\n  }\n}\n\nexport default MyComponent;\n```\n\nIn this example, `findDOMNode()` is called inside the `componentDidMount()` lifecycle method to get a reference to the DOM node of the `MyComponent` instance. As mentioned earlier, while this method can be used, it is not the preferred way to interact with the DOM in modern React applications.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 22
    },
    {
      "subject": "react",
      "title": "is babel also compiler",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "Yes, you are correct. Babel is indeed a compiler, but more specifically, it is a JavaScript compiler that is commonly referred to as a \"transpiler.\"\n\nAs I explained earlier, a transpiler, or \"source-to-source compiler,\" takes source code written in one language and converts it into another language of the same or similar level of abstraction. In the case of Babel, it takes modern JavaScript code, often using the latest ECMAScript features, and transpiles it into an older version of JavaScript that is compatible with a broader range of browsers and environments.\n\nSo, while Babel is a type of compiler (specifically, a transpiler), it is essential to note that it doesn't produce lower-level machine code like some traditional compilers do. Instead, it produces JavaScript code that is more widely supported and can be executed in various JavaScript environments, including older browsers.\n\nIn summary, Babel is a JavaScript transpiler, and its primary purpose is to convert modern JavaScript code into an older, more compatible version of JavaScript, enabling developers to use the latest language features while ensuring cross-browser compatibility.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 23
    },
    {
      "subject": "react",
      "title": "How to use useSelector in react, explain with code example",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "In React, `useSelector` is a hook provided by the `react-redux` library that allows you to access the Redux store's state in your functional components. Redux is a state management library commonly used with React applications.\n\nTo use `useSelector`, you need to have a Redux store set up in your application, and you should have wrapped your main component tree with the `Provider` from `react-redux`. The `Provider` makes the Redux store available to all the components in your application.\n\nHere's a step-by-step guide on how to use `useSelector` in a React functional component:\n\nStep 1: Install Dependencies\nMake sure you have installed `react-redux` and `redux` in your project by running:\n\n```bash\nnpm install react-redux redux\n```\n\nStep 2: Create a Redux Store\nCreate a Redux store with reducers, actions, and middleware as needed for your application. For simplicity, let's assume we have a basic store with a single reducer managing a list of items.\n\n```jsx\n// store.js\n\nimport { createStore } from 'redux';\n\nconst initialState = {\n  items: [],\n};\n\nconst itemReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case 'ADD_ITEM':\n      return {\n        ...state,\n        items: [...state.items, action.payload],\n      };\n    default:\n      return state;\n  }\n};\n\nconst store = createStore(itemReducer);\n\nexport default store;\n```\n\nStep 3: Wrap your Component with `Provider`\nWrap your main component tree with the `Provider` component, passing the `store` as a prop.\n\n```jsx\n// index.js (or wherever you render your app)\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\nimport store from './store';\nimport App from './App';\n\nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById('root')\n);\n```\n\nStep 4: Use `useSelector` in your Component\nNow, you can use the `useSelector` hook in your functional component to access the state from the Redux store.\n\n```jsx\n// App.js\n\nimport React from 'react';\nimport { useSelector } from 'react-redux';\n\nconst App = () => {\n  // Using the useSelector hook to access the 'items' state from the Redux store\n  const items = useSelector((state) => state.items);\n\n  const renderItems = () => {\n    return items.map((item, index) => <li key={index}>{item}</li>);\n  };\n\n  return (\n    <div>\n      <h1>Items List</h1>\n      <ul>{renderItems()}</ul>\n    </div>\n  );\n};\n\nexport default App;\n```\n\nIn this example, the `useSelector` hook is used to extract the `items` state from the Redux store. The `items` array can now be used within the `App` component to render a list of items.\n\nRemember that the `useSelector` hook automatically subscribes to the Redux store and updates the component whenever the state it depends on changes. This allows your component to stay in sync with the global state managed by Redux without having to manually subscribe or unsubscribe to the store.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 24
    },
    {
      "subject": "react",
      "title": "what are  all lifecycle methods in react class component, explain each one with simple words and example",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "In React class components, lifecycle methods are special methods that are automatically called at different stages of a component's lifecycle. These methods allow you to perform certain actions when a component is created, updated, or removed from the DOM. Understanding these methods is crucial for managing component behavior and optimizing performance. Below are the main lifecycle methods in React class components, explained with simple words and examples:\n\n1. **constructor()**:\n   - The `constructor()` method is the first method called when a component is created. It is used to initialize the component's state and bind event handlers. You should call `super(props)` inside the constructor to properly set up the component.\n\n```jsx\nclass MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0\n    };\n    // Bind event handler\n    this.handleClick = this.handleClick.bind(this);\n  }\n\n  handleClick() {\n    this.setState({ count: this.state.count + 1 });\n  }\n\n  render() {\n    return (\n      <div>\n        <button onClick={this.handleClick}>Click Me</button>\n        <p>Count: {this.state.count}</p>\n      </div>\n    );\n  }\n}\n```\n\n2. **render()**:\n   - The `render()` method is a mandatory lifecycle method that is called whenever a component is rendered or updated. It returns the JSX (UI) that should be displayed on the screen. This method should be pure, meaning it should not modify component state or interact with the DOM directly.\n\n3. **componentDidMount()**:\n   - The `componentDidMount()` method is called after the component is rendered on the screen. It is often used for tasks that require access to the DOM or fetching data from an API. This method is a good place to set up subscriptions or timers.\n\n```jsx\nclass MyComponent extends React.Component {\n  componentDidMount() {\n    // Fetch data from API\n    fetch('https://api.example.com/data')\n      .then(response => response.json())\n      .then(data => console.log(data))\n      .catch(error => console.error(error));\n  }\n\n  render() {\n    // Render JSX (UI)\n    return <div>My Component</div>;\n  }\n}\n```\n\n4. **shouldComponentUpdate(nextProps, nextState)**:\n   - The `shouldComponentUpdate()` method is called before a component updates. It allows you to control whether the component should re-render or not. By default, React will re-render the component whenever its state or props change. You can optimize performance by implementing your own logic to determine if a re-render is necessary.\n\n```jsx\nclass MyComponent extends React.Component {\n  shouldComponentUpdate(nextProps, nextState) {\n    // Only re-render if the count changes\n    return this.state.count !== nextState.count;\n  }\n\n  render() {\n    return <div>Count: {this.state.count}</div>;\n  }\n}\n```\n\n5. **componentDidUpdate(prevProps, prevState)**:\n   - The `componentDidUpdate()` method is called after the component updates. It is often used to perform side effects after a re-render. You can compare the current props and state with the previous props and state to perform specific actions based on the changes.\n\n```jsx\nclass MyComponent extends React.Component {\n  componentDidUpdate(prevProps, prevState) {\n    if (prevProps.itemId !== this.props.itemId) {\n      // Fetch new data when the itemId prop changes\n      fetch(`https://api.example.com/items/${this.props.itemId}`)\n        .then(response => response.json())\n        .then(data => console.log(data))\n        .catch(error => console.error(error));\n    }\n  }\n\n  render() {\n    return <div>Item: {this.props.itemId}</div>;\n  }\n}\n```\n\n6. **componentWillUnmount()**:\n   - The `componentWillUnmount()` method is called just before a component is removed from the DOM. It is often used to clean up resources such as subscriptions, timers, or event listeners to prevent memory leaks.\n\n```jsx\nclass MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.timerId = null;\n  }\n\n  componentDidMount() {\n    // Start a timer when the component mounts\n    this.timerId = setInterval(() => console.log('Timer tick'), 1000);\n  }\n\n  componentWillUnmount() {\n    // Clean up the timer before the component unmounts\n    clearInterval(this.timerId);\n  }\n\n  render() {\n    return <div>My Component</div>;\n  }\n}\n```\n\nThese are the main lifecycle methods in React class components, and they play a crucial role in controlling the behavior of your components throughout their lifecycle. As of React 16.3, some of these lifecycle methods are considered legacy and have been replaced with more modern alternatives (e.g., `getDerivedStateFromProps()` and `getSnapshotBeforeUpdate()`). For the most up-to-date information, always refer to the official React documentation.\n\n===============\n\n\nHere are all the lifecycle methods in a React class component explained simply with examples:\n\n1. **constructor()** - Called before the component is mounted. Initialize state and bindings here.\n\n```jsx\nconstructor(props) {\n  super(props);\n  this.state = {count: 0};\n}\n```\n\n2. **getDerivedStateFromProps()** - Set state before render using props. \n\n```jsx\nstatic getDerivedStateFromProps(props, state) {\n  // return updated state based on props\n}\n```\n\n3. **render()** - Render UI with data. Required method.\n\n```jsx\nrender() {\n  return <h1>{this.state.count}</h1>; \n}\n```\n\n4. **componentDidMount()** - Runs after initial rendering. Ideal for API calls.\n\n```jsx\ncomponentDidMount() {\n  fetchData();\n}\n```\n\n5. **shouldComponentUpdate()** - Decide if component should re-render after state/prop change.\n\n```jsx\nshouldComponentUpdate(nextProps, nextState) {\n  // return true or false \n}\n```\n\n6. **getSnapshotBeforeUpdate()** - Called right before DOM update. Capture DOM info.\n\n```jsx\ngetSnapshotBeforeUpdate(prevProps, prevState) {\n  // return snapshot value \n} \n```\n\n7. **componentDidUpdate()** - Called after update occurs. Ideal for DOM updates based on state change.\n\n```jsx \ncomponentDidUpdate(prevProps, prevState) {\n  // DOM updates  \n}\n```\n\n8. **componentWillUnmount()** - Cleanup before component is destroyed/unmounted. \n\n```jsx\ncomponentWillUnmount() {\n  // cleanup  \n}\n```\n\nSo in summary, these methods are called in order during the component's life cycle during mounting, updating, and unmounting.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 25
    },
    {
      "subject": "react",
      "title": "how to test apis on reactjs side",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "Testing APIs on the React.js side involves using various testing libraries and techniques to ensure that your React components interact correctly with APIs and handle responses as expected. Here's a step-by-step guide on how to test APIs on the React.js side:\n\n1. **Install Testing Libraries:**\n\n   First, you need to install the necessary testing libraries. The most common libraries for testing React components are Jest and React Testing Library.\n\n   ```bash\n   npm install jest @testing-library/react @testing-library/jest-dom --save-dev\n   ```\n\n2. **Mock API Calls:**\n\n   Use a library like `msw` (Mock Service Worker) to mock API calls during testing. This ensures that your tests are isolated from the actual API and can run independently.\n\n   ```bash\n   npm install msw --save-dev\n   ```\n\n   Create a file for setting up `msw` mocks:\n\n   ```javascript\n   // src/setupTests.js\n   import { server } from './mocks/server';\n\n   // Setup the mock API server before tests run\n   beforeAll(() => server.listen());\n   // Reset any runtime request handlers we may add during the tests.\n   afterEach(() => server.resetHandlers());\n   // Clean up once the tests are done.\n   afterAll(() => server.close());\n   ```\n\n3. **Write API Tests:**\n\n   Create test files for your components. Write tests that render your components and simulate API responses using `msw`.\n\n   ```javascript\n   // src/components/__tests__/MyComponent.test.js\n   import React from 'react';\n   import { render, screen } from '@testing-library/react';\n   import MyComponent from '../MyComponent';\n\n   describe('MyComponent', () => {\n     it('fetches and displays data from API', async () => {\n       render(<MyComponent />);\n\n       // Simulate an API response using msw\n       server.use(\n         rest.get('/api/data', (req, res, ctx) => {\n           return res(ctx.json({ key: 'value' }));\n         })\n       );\n\n       // Wait for the component to render and the API response to be handled\n       const dataElement = await screen.findByText('Expected Data');\n       expect(dataElement).toBeInTheDocument();\n     });\n   });\n   ```\n\n4. **Run Tests:**\n\n   Run your tests using Jest:\n\n   ```bash\n   npx jest\n   ```\n\n   Jest will run your tests and show you the results.\n\nThis is a basic example of testing API interactions on the React.js side. Depending on your project and requirements, you can also write more comprehensive tests, including snapshot tests, testing different API responses, testing error handling, and more.\n\nRemember that testing is an ongoing process, and as your application evolves, you should continue to add and update tests to ensure its reliability and functionality.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 26
    },
    {
      "subject": "react",
      "title": "how to implement pub sub in reactjs",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "Implementing the Publish-Subscribe (Pub-Sub) pattern in React.js involves using a global state management library like Redux or Context API to facilitate communication between components. Here, I'll provide an example using the Context API to achieve Pub-Sub behavior in React:\n\n1. **Create a Pub-Sub Context:**\n\n   Start by creating a context for the Pub-Sub pattern. This context will manage the state and provide methods for subscribing to and publishing events.\n\n   ```javascript\n   // PubSubContext.js\n   import React, { createContext, useContext, useState } from 'react';\n\n   const PubSubContext = createContext();\n\n   export function PubSubProvider({ children }) {\n     const [subscribers, setSubscribers] = useState({});\n\n     function subscribe(event, callback) {\n       setSubscribers((prevSubscribers) => ({\n         ...prevSubscribers,\n         [event]: [...(prevSubscribers[event] || []), callback]\n       }));\n     }\n\n     function publish(event, data) {\n       if (subscribers[event]) {\n         subscribers[event].forEach((callback) => callback(data));\n       }\n     }\n\n     return (\n       <PubSubContext.Provider value={{ subscribe, publish }}>\n         {children}\n       </PubSubContext.Provider>\n     );\n   }\n\n   export function usePubSub() {\n     return useContext(PubSubContext);\n   }\n   ```\n\n2. **Subscribe to an Event:**\n\n   In a component that wants to listen for events, use the `usePubSub` hook to access the Pub-Sub methods and subscribe to the desired event.\n\n   ```javascript\n   // SubscriberComponent.js\n   import React, { useEffect, useState } from 'react';\n   import { usePubSub } from './PubSubContext';\n\n   function SubscriberComponent() {\n     const { subscribe } = usePubSub();\n     const [message, setMessage] = useState('');\n\n     useEffect(() => {\n       const unsubscribe = subscribe('customEvent', (data) => {\n         setMessage(data);\n       });\n\n       return () => {\n         unsubscribe();\n       };\n     }, []);\n\n     return (\n       <div>\n         <h2>Subscriber Component</h2>\n         <p>{message}</p>\n       </div>\n     );\n   }\n\n   export default SubscriberComponent;\n   ```\n\n3. **Publish an Event:**\n\n   In another component that wants to publish an event, use the `usePubSub` hook and call the `publish` method.\n\n   ```javascript\n   // PublisherComponent.js\n   import React from 'react';\n   import { usePubSub } from './PubSubContext';\n\n   function PublisherComponent() {\n     const { publish } = usePubSub();\n\n     const publishEvent = () => {\n       publish('customEvent', 'Event data from Publisher');\n     };\n\n     return (\n       <div>\n         <h2>Publisher Component</h2>\n         <button onClick={publishEvent}>Publish Event</button>\n       </div>\n     );\n   }\n\n   export default PublisherComponent;\n   ```\n\n4. **Wrap Components with Provider:**\n\n   Wrap your components with the `PubSubProvider` to provide the Pub-Sub context to your app.\n\n   ```javascript\n   // App.js\n   import React from 'react';\n   import PublisherComponent from './PublisherComponent';\n   import SubscriberComponent from './SubscriberComponent';\n   import { PubSubProvider } from './PubSubContext';\n\n   function App() {\n     return (\n       <PubSubProvider>\n         <div>\n           <PublisherComponent />\n           <SubscriberComponent />\n         </div>\n       </PubSubProvider>\n     );\n   }\n\n   export default App;\n   ```\n\nWith this implementation, when you click the \"Publish Event\" button in the `PublisherComponent`, the `SubscriberComponent` will receive the published event and update its content accordingly. This demonstrates the basic implementation of the Pub-Sub pattern in React using the Context API.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 27
    },
    {
      "subject": "react",
      "title": "React Performance",
      "ques": "",
      "links": [
        {
          "name": "https://www.dropbox.com/scl/fi/cdw5h5l2zybipq6zgqhlp/8-Performance-Optimization-Techniques-You-Should-Know-in-React-by-a-layan-Yan-ko-lu-Jotform-Tech.pdf?rlkey=zegymcnrve7ispszmc333kcgc&dl=0"
        },
        {
          "name": "https://www.dropbox.com/scl/fi/eqlx5ekt0gislvqcfxzf8/The-Key-to-Performance-Replacing-useEffect-with-Key-Changes-in-React-No-Seriously-by-Harry-Bloch-Medium.pdf?rlkey=jf1vi1zbsg9ukj2jefdm15pku&dl=0"
        },
        {
          "name": "https://www.dropbox.com/scl/fi/1wh4ehx7cut31hxjnf9k0/Use-Infinite-Scroll-in-React-Like-a-Pro-by-a-layan-Yan-ko-lu-Jotform-Tech.pdf?rlkey=ia7d9m3zexketdrq6qcxrk5u4&dl=0"
        }
      ],
      "tags": [
        {
          "name": "medium.com"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 28
    },
    {
      "subject": "react",
      "title": "Infinite scroll",
      "ques": "how to implement infinite scroll in reactjs. Explain each step with proper detailed code example",
      "links": [],
      "tags": [],
      "ans": "Implementing infinite scroll in React involves loading more content as the user scrolls down a page or component. Here's a detailed step-by-step example of how to achieve infinite scroll in a React application:\n\nAssumption: We'll fetch data from an API and display it using infinite scroll.\n\n1. **Create React App**:\n   Create a new React application using Create React App or your preferred setup.\n\n2. **Fetch Data from API**:\n   Create a function to fetch data from an API. For this example, we'll use the `axios` library for fetching data.\n\n   Install `axios`:\n\n   ```bash\n   npm install axios\n   ```\n\n   Create a file named `api.js`:\n\n   ```javascript\n   import axios from 'axios';\n\n   const API_URL = 'https://api.example.com/items'; // Replace with your API URL\n\n   export const fetchItems = async (page, pageSize) => {\n     const response = await axios.get(API_URL, {\n       params: {\n         page,\n         pageSize,\n       },\n     });\n     return response.data;\n   };\n   ```\n\n3. **InfiniteScroll Component**:\n   Create an `InfiniteScroll` component that fetches and displays items using infinite scroll.\n\n   ```javascript\n   import React, { useState, useEffect } from 'react';\n   import { fetchItems } from './api';\n\n   const InfiniteScroll = () => {\n     const pageSize = 10; // Number of items to fetch per request\n     const [items, setItems] = useState([]);\n     const [page, setPage] = useState(1);\n     const [loading, setLoading] = useState(false);\n     const [hasMore, setHasMore] = useState(true);\n\n     const loadMore = async () => {\n       if (loading || !hasMore) {\n         return;\n       }\n\n       setLoading(true);\n       const newItems = await fetchItems(page, pageSize);\n       setLoading(false);\n\n       if (newItems.length === 0) {\n         setHasMore(false);\n       } else {\n         setItems([...items, ...newItems]);\n         setPage(page + 1);\n       }\n     };\n\n     useEffect(() => {\n       loadMore();\n     }, []);\n\n     const handleScroll = () => {\n       const { scrollHeight, scrollTop, clientHeight } = document.documentElement;\n       if (scrollHeight - scrollTop === clientHeight) {\n         loadMore();\n       }\n     };\n\n     useEffect(() => {\n       window.addEventListener('scroll', handleScroll);\n       return () => {\n         window.removeEventListener('scroll', handleScroll);\n       };\n     }, []);\n\n     return (\n       <div>\n         <ul>\n           {items.map((item, index) => (\n             <li key={index}>{item.name}</li>\n           ))}\n         </ul>\n         {loading && <p>Loading...</p>}\n         {!loading && !hasMore && <p>No more items</p>}\n       </div>\n     );\n   };\n\n   export default InfiniteScroll;\n   ```\n\n4. **App Component**:\n   In your `App.js` or main component, use the `InfiniteScroll` component:\n\n   ```javascript\n   import React from 'react';\n   import './App.css';\n   import InfiniteScroll from './InfiniteScroll';\n\n   function App() {\n     return (\n       <div className=\"App\">\n         <h1>Infinite Scroll Example</h1>\n         <InfiniteScroll />\n       </div>\n     );\n   }\n\n   export default App;\n   ```\n\n5. **Styling (Optional)**:\n   You can add some basic styling to your components to make the list visually appealing.\n\n6. **Run the App**:\n   Run your React app using `npm start` and see the infinite scroll in action.\n\nIn this example, the `InfiniteScroll` component fetches more items as the user scrolls down. It maintains the current page and loading state and prevents loading duplicate items. The `handleScroll` function is responsible for detecting when the user has scrolled to the bottom of the page and triggers loading more items.\n\nRemember to adjust the API URL, data structure, and styling according to your needs. This example provides a foundation for implementing infinite scroll in your React application.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 29
    },
    {
      "subject": "react",
      "title": "Explain each and every reason and aspects to choose between Reactjs and Angular. Explain in detail with proper code examples",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "Choosing between React.js and Angular depends on various factors, including project requirements, team expertise, and personal preferences. Below, I'll provide a detailed comparison of both, highlighting reasons and aspects to consider when making a decision.\n\n**1. Learning Curve:**\n\n- **React:** React has a relatively lower learning curve compared to Angular. It's easier for developers familiar with JavaScript and HTML to get started quickly.\n\n```jsx\n// React Example\nimport React from 'react';\n\nfunction MyComponent() {\n  return <div>Hello, React!</div>;\n}\n```\n\n- **Angular:** Angular has a steeper learning curve, as it relies heavily on TypeScript and introduces concepts like decorators and modules.\n\n```typescript\n// Angular Example\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-my-component',\n  template: '<div>Hello, Angular!</div>',\n})\nexport class MyComponent {}\n```\n\n**2. Architecture:**\n\n- **React:** React is a library for building user interfaces. It focuses on the \"View\" part of the application. Developers have the flexibility to choose other libraries and tools (e.g., Redux for state management).\n\n```jsx\n// React with Redux for state management\nimport React from 'react';\nimport { connect } from 'react-redux';\n\nfunction MyComponent(props) {\n  return <div>{props.message}</div>;\n}\n\nconst mapStateToProps = (state) => ({\n  message: state.message,\n});\n\nexport default connect(mapStateToProps)(MyComponent);\n```\n\n- **Angular:** Angular is a full-fledged framework that provides a more opinionated architecture. It includes modules, components, services, and a powerful dependency injection system.\n\n```typescript\n// Angular Example with Dependency Injection\nimport { Component } from '@angular/core';\nimport { MyService } from './my.service';\n\n@Component({\n  selector: 'app-my-component',\n  template: '<div>{{ message }}</div>',\n})\nexport class MyComponent {\n  message: string;\n\n  constructor(private myService: MyService) {\n    this.message = myService.getMessage();\n  }\n}\n```\n\n**3. State Management:**\n\n- **React:** React leaves state management up to developers. You can use React's built-in state management or opt for external libraries like Redux, Mobx, or Recoil.\n\n```jsx\n// React Example with React's useState\nimport React, { useState } from 'react';\n\nfunction MyComponent() {\n  const [message, setMessage] = useState('Hello, React!');\n  return <div>{message}</div>;\n}\n```\n\n- **Angular:** Angular provides services and RxJS for state management, which allows you to manage application-wide state more easily.\n\n```typescript\n// Angular Example with RxJS\nimport { Component } from '@angular/core';\nimport { MyService } from './my.service';\n\n@Component({\n  selector: 'app-my-component',\n  template: '<div>{{ message }}</div>',\n})\nexport class MyComponent {\n  message: string;\n\n  constructor(private myService: MyService) {\n    this.myService.getMessage().subscribe((message) => {\n      this.message = message;\n    });\n  }\n}\n```\n\n**4. Community and Ecosystem:**\n\n- **React:** React has a large and active community, resulting in a vast ecosystem of libraries and tools, making it easier to find solutions and resources.\n\n- **Angular:** Angular also has a strong community, and it provides a more opinionated ecosystem with many official libraries and tools developed by Google.\n\n**5. Performance:**\n\n- **React:** React is known for its performance optimization through features like the Virtual DOM, which reduces the number of DOM manipulations.\n\n- **Angular:** Angular's change detection system and Ahead-of-Time (AOT) compilation can also lead to good performance. However, it may have a steeper learning curve when optimizing for performance.\n\n**6. Tooling:**\n\n- **React:** React has a simpler tooling setup, often relying on Create React App or other boilerplate projects for quick setup.\n\n- **Angular:** Angular offers its CLI (Command Line Interface), providing an extensive set of tools for generating code, running tests, and building projects.\n\n**7. Use Cases:**\n\n- **React:** React is versatile and suitable for a wide range of applications, from single-page applications (SPAs) to mobile app development (React Native).\n\n- **Angular:** Angular is well-suited for enterprise-level applications, large-scale projects, and projects that require strict adherence to architectural guidelines.\n\nUltimately, the choice between React and Angular depends on your project's requirements, your team's expertise, and your personal preferences. Both have their strengths and weaknesses, and there is no one-size-fits-all answer. It's essential to evaluate your specific needs and constraints when making a decision.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 30
    },
    {
      "subject": "react",
      "title": "",
      "ques": "Implement diff component from scratch",
      "links": [
        {
          "name": "https://stackblitz.com/edit/stackblitz-starters-jbo5zm"
        }
      ],
      "tags": [],
      "ans": "Creating a UI component in React to display the differences between two strings and highlight those changes can be achieved by breaking down the problem into several steps. We'll create a component that takes two input strings, compares them, and displays the differences using HTML markup for highlighting. Here's a step-by-step implementation:\n\n1. **Create a New React Component**:\n\n   Start by creating a new React component. You can name it something like `StringDifferenceHighlighter`.\n\n   ```jsx\n   import React from 'react';\n\n   function StringDifferenceHighlighter({ originalString, modifiedString }) {\n     // Your implementation will go here\n   }\n\n   export default StringDifferenceHighlighter;\n   ```\n\n2. **Split the Strings into Words**:\n\n   To compare the strings word by word, split both the `originalString` and `modifiedString` into arrays of words.\n\n   ```jsx\n   const originalWords = originalString.split(' ');\n   const modifiedWords = modifiedString.split(' ');\n   ```\n\n3. **Compare the Words**:\n\n   Compare the words in both arrays to find the differences. You can do this by iterating through the words and comparing them.\n\n   - If a word is present in `originalWords` but not in `modifiedWords`, it's considered deleted.\n   - If a word is present in `modifiedWords` but not in `originalWords`, it's considered added.\n   - If a word exists in both arrays but is different, it's considered updated.\n\n   ```jsx\n   const differences = [];\n   originalWords.forEach((originalWord, index) => {\n     const modifiedWord = modifiedWords[index];\n     if (!modifiedWord) {\n       differences.push({ type: 'deleted', word: originalWord });\n     } else if (originalWord !== modifiedWord) {\n       differences.push({ type: 'updated', originalWord, modifiedWord });\n     }\n   });\n\n   modifiedWords.slice(originalWords.length).forEach((addedWord) => {\n     differences.push({ type: 'added', word: addedWord });\n   });\n   ```\n\n4. **Render the Differences with HTML Markup**:\n\n   Render the differences as HTML elements with appropriate classes to highlight them.\n\n   ```jsx\n   return (\n     <div>\n       {differences.map((difference, index) => {\n         if (difference.type === 'added') {\n           return (\n             <span key={index} className=\"added\">\n               {difference.word}\n             </span>\n           );\n         } else if (difference.type === 'deleted') {\n           return (\n             <span key={index} className=\"deleted\">\n               {difference.word}\n             </span>\n           );\n         } else if (difference.type === 'updated') {\n           return (\n             <span key={index} className=\"updated\">\n               <del>{difference.originalWord}</del>\n               <ins>{difference.modifiedWord}</ins>\n             </span>\n           );\n         }\n       })}\n     </div>\n   );\n   ```\n\n5. **Apply CSS Styling**:\n\n   You can add CSS styles to your component to visually highlight the differences based on the classes you applied in the previous step.\n\n   ```css\n   .added {\n     background-color: lightgreen;\n   }\n\n   .deleted {\n     background-color: lightcoral;\n   }\n\n   .updated del {\n     text-decoration: line-through;\n   }\n\n   .updated ins {\n     text-decoration: underline;\n     background-color: lightyellow;\n   }\n   ```\n\n6. **Using the Component**:\n\n   Now you can use the `StringDifferenceHighlighter` component in your application by passing the `originalString` and `modifiedString` as props.\n\n   ```jsx\n   import React from 'react';\n   import StringDifferenceHighlighter from './StringDifferenceHighlighter';\n\n   function App() {\n     const originalString = 'The quick brown fox';\n     const modifiedString = 'A quick brown cat jumps over the fox';\n\n     return (\n       <div>\n         <StringDifferenceHighlighter\n           originalString={originalString}\n           modifiedString={modifiedString}\n         />\n       </div>\n     );\n   }\n\n   export default App;\n   ```\n\nWith this implementation, the `StringDifferenceHighlighter` component will render the differences between the two input strings and apply appropriate styling to highlight the changes. You can customize the CSS styling and further refine the logic based on your specific requirements.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 31
    }
  ],
  "redux": [],
  "performance": [],
  "sd": [
    {
      "subject": "sd",
      "title": "LRU cache implementation in Javascript",
      "ques": "",
      "links": [
        {
          "name": "https://stackoverflow.com/questions/996505/lru-cache-implementation-in-javascript"
        },
        {
          "name": "https://medium.com/dsinjs/implementing-lru-cache-in-javascript-94ba6755cda9"
        },
        {
          "name": "https://leetcode.com/problems/lru-cache/?envType=list&envId=rel0rvfm"
        }
      ],
      "tags": [
        {
          "name": "iCloud-note"
        },
        {
          "name": "medium.com"
        },
        {
          "name": "Leetcode"
        }
      ],
      "ans": "\nclass LRU {\n    constructor(max = 10) {\n        this.max = max;\n        this.cache = new Map();\n    }\n\n    get(key) {\n        let item = this.cache.get(key);\n        if (item) {\n            // refresh key\n            this.cache.delete(key);\n            this.cache.set(key, item);\n        }\n        return item;\n    }\n\n    set(key, val) {\n        // refresh key\n        if (this.cache.has(key)) this.cache.delete(key);\n        // evict oldest\n        else if (this.cache.size == this.max) this.cache.delete(this.first());\n        this.cache.set(key, val);\n    }\n\n    first() {\n        return this.cache.keys().next().value;\n    }\n}",
      "diff": 1,
      "imp": 1,
      "cate": [
        "caching"
      ],
      "id": 1
    },
    {
      "subject": "sd",
      "title": "How do I create a URL shortener(JS)?",
      "ques": "",
      "links": [
        {
          "name": "https://stackoverflow.com/questions/742013/how-do-i-create-a-url-shortener"
        }
      ],
      "tags": [
        {
          "name": "iCloud-note"
        },
        {
          "name": "stackoverflow"
        }
      ],
      "ans": "How to convert the ID to a shortened URL\n-----------------------------------------\nThink of an alphabet we want to use. In your case, that's [a-zA-Z0-9]. It contains 62 letters.\nTake an auto-generated, unique numerical key (the auto-incremented id of a MySQL table for example).\n\nFor this example, I will use 12510 (125 with a base of 10).\n\nNow you have to convert 12510 to X62 (base 62).\n\n12510 = 2×621 + 1×620 = [2,1]\n\nThis requires the use of integer division and modulo. A pseudo-code example:\n\ndigits = []\n\nwhile num > 0\n  remainder = modulo(num, 62)\n  digits.push(remainder)\n  num = divide(num, 62)\n\ndigits = digits.reverse\nNow map the indices 2 and 1 to your alphabet. This is how your mapping (with an array for example) could look like:\n\n0  → a\n1  → b\n...\n25 → z\n...\n52 → 0\n61 → 9\nWith 2 → c and 1 → b, you will receive cb62 as the shortened URL.\n\nhttp://shor.ty/cb\n\n\nHow to resolve a shortened URL to the initial ID\n---------------------------------------------------\nThe reverse is even easier. You just do a reverse lookup in your alphabet.\n\ne9a62 will be resolved to \"4th, 61st, and 0th letter in the alphabet\".\n\ne9a62 = [4,61,0] = 4×622 + 61×621 + 0×620 = 1915810\n\nNow find your database-record with WHERE id = 19158 and do the redirect.",
      "diff": 1,
      "imp": 1,
      "cate": [
        "general"
      ],
      "id": 2
    },
    {
      "subject": "sd",
      "title": "Encode and Decode TinyURL(Java)",
      "ques": "TinyURL is a URL shortening service where you enter a URL such as https://leetcode.com/problems/design-tinyurl and it returns a short URL such as http://tinyurl.com/4e9iAk. Design a class to encode a URL and decode a tiny URL.\n\nThere is no restriction on how your encode/decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL.\n\nImplement the Solution class:\n\nSolution() Initializes the object of the system.\nString encode(String longUrl) Returns a tiny URL for the given longUrl.\nString decode(String shortUrl) Returns the original long URL for the given shortUrl. It is guaranteed that the given shortUrl was encoded by the same object.",
      "links": [
        {
          "name": "https://leetcode.com/problems/encode-and-decode-tinyurl/"
        }
      ],
      "tags": [
        {
          "name": "Leetcode"
        }
      ],
      "ans": "\npackage com.company;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Random;\n\n// Approach #3 Using hashcode\nclass CodecX3 {\n    Map<Integer, String> map = new HashMap<>();\n\n    public String encode(String longUrl) {\n        map.put(longUrl.hashCode(), longUrl);\n        return \"http://tinyurl.com/\" + longUrl.hashCode();\n    }\n\n    public String decode(String shortUrl) {\n        return map.get(Integer.parseInt(shortUrl.replace(\"http://tinyurl.com/\", \"\")));\n    }\n}\n\n// Approach #2 Variable-length Encoding\nclass CodecX2 {\n    String chars = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    HashMap<String, String> map = new HashMap<>();\n    int count = 1;\n\n    public String getString() {\n        int c = count;\n        StringBuilder sb = new StringBuilder();\n        while (c > 0) {\n            c--;\n            sb.append(chars.charAt(c % 62));\n            c /= 62;\n        }\n        return sb.toString();\n    }\n\n    public String encode(String longUrl) {\n        String key = getString();\n        map.put(key, longUrl);\n        count++;\n        return \"http://tinyurl.com/\" + key;\n    }\n\n    public String decode(String shortUrl) {\n        return map.get(shortUrl.replace(\"http://tinyurl.com/\", \"\"));\n    }\n}\n\n// Approach #4 Using random number\nclass CodecX4 {\n    Map<Integer, String> map = new HashMap<>();\n    Random r = new Random();\n    int key = r.nextInt(Integer.MAX_VALUE);\n\n    public String encode(String longUrl) {\n        while (map.containsKey(key)) {\n            key = r.nextInt(Integer.MAX_VALUE);\n        }\n        map.put(key, longUrl);\n        return \"http://tinyurl.com/\" + key;\n    }\n\n    public String decode(String shortUrl) {\n        return map.get(Integer.parseInt(shortUrl.replace(\"http://tinyurl.com/\", \"\")));\n    }\n}\n\n// Approach #5 Random fixed-length encoding\nclass Codec {\n    String alphabet = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    HashMap<String, String> map = new HashMap<>();\n    Random rand = new Random();\n    String key = getRand();\n\n    public String getRand() {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < 6; i++) {\n            sb.append(alphabet.charAt(rand.nextInt(62)));\n        }\n        return sb.toString();\n    }\n\n    public String encode(String longUrl) {\n        while (map.containsKey(key)) {\n            key = getRand();\n        }\n        map.put(key, longUrl);\n        return \"http://tinyurl.com/\" + key;\n    }\n\n    public String decode(String shortUrl) {\n        return map.get(shortUrl.replace(\"http://tinyurl.com/\", \"\"));\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n\n        Codec c1 = new Codec();\n        String encodeURL = c1.encode(\"https://leetcode.com/problems/design-tinyurl\");\n        System.out.println(\"encodeURL ::\" + encodeURL);\n\n        String decodeURL = c1.decode(encodeURL);\n        System.out.println(\"decodeURL ::\" + decodeURL);\n\n\n    }\n}\n",
      "diff": 1,
      "imp": 1,
      "cate": [
        "general"
      ],
      "id": 3
    },
    {
      "subject": "sd",
      "title": "difference between webhook and SSE",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "Webhooks and Server-Sent Events (SSE) are both mechanisms used for server-to-client communication, but they have some key differences:\n\n**Webhooks:**\n\n1. **Client-initiated**: Webhooks are initiated by the client. The client registers a URL endpoint with the server and expects the server to make HTTP requests to that endpoint when certain events occur.\n\n2. **HTTP requests**: When an event occurs on the server, it sends an HTTP POST request to the registered webhook endpoint. The payload typically contains information related to the event.\n\n3. **One-time delivery**: Webhooks follow a one-time delivery model. Once the server sends the HTTP request to the webhook endpoint, it considers the task complete and does not retain any knowledge of the delivery status.\n\n4. **Payload control**: The server decides what information to include in the webhook payload. The client needs to handle the received payload and process it accordingly.\n\n5. **Flexible integration**: Webhooks can be integrated with various client applications and systems. The client needs to implement an endpoint to receive and process the webhook requests.\n\n**Server-Sent Events (SSE):**\n\n1. **Server-initiated**: SSE is initiated by the server. The client establishes a persistent connection with the server and waits for the server to send updates or events.\n\n2. **Event streams**: The server sends a continuous stream of events to the client over a single HTTP connection. Each event is sent as a separate message and can contain structured data.\n\n3. **Persistent connection**: SSE maintains a long-lived connection between the client and server, allowing the server to push updates to the client as they occur.\n\n4. **Automatic retry**: If the connection between the client and server is interrupted, SSE automatically attempts to reconnect and resume the event stream.\n\n5. **Event-driven**: SSE follows an event-driven model, where the server sends events to the client in real-time. The client can listen for specific event types and take appropriate actions.\n\n**Use Cases:**\n\n- Webhooks are commonly used for notifications, integrations, and triggering actions in external systems or services when specific events occur on the server-side.\n\n- SSE is suitable for scenarios where the client needs real-time updates from the server, such as live data feeds, chat applications, or real-time monitoring dashboards.\n\nIn summary, webhooks are client-initiated, one-time delivery mechanisms, while SSE is server-initiated with persistent connections, allowing the server to continuously send events to the client. The choice between webhooks and SSE depends on the requirements of your application and the type of communication model that best fits your use case.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 4
    },
    {
      "subject": "sd",
      "title": "460. LFU Cache",
      "ques": "",
      "links": [
        {
          "name": "https://leetcode.com/problems/lfu-cache/?envType=list&envId=rel0rvfm"
        }
      ],
      "tags": [
        {
          "name": "Leetcode"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 5
    },
    {
      "subject": "sd",
      "title": "588. Design In-Memory File System",
      "ques": "",
      "links": [
        {
          "name": "https://leetcode.com/problems/design-in-memory-file-system/?envType=list&envId=rel0rvfm"
        }
      ],
      "tags": [
        {
          "name": "Leetcode"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 6
    },
    {
      "subject": "sd",
      "title": "604. Design Compressed String Iterator",
      "ques": "",
      "links": [
        {
          "name": "https://leetcode.com/problems/design-compressed-string-iterator/?envType=list&envId=rel0rvfm"
        }
      ],
      "tags": [
        {
          "name": "Leetcode"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 7
    },
    {
      "subject": "sd",
      "title": "635. Design Log Storage System",
      "ques": "",
      "links": [
        {
          "name": "https://leetcode.com/problems/design-log-storage-system/?envType=list&envId=rel0rvfm"
        }
      ],
      "tags": [
        {
          "name": "Leetcode"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 8
    },
    {
      "subject": "sd",
      "title": "what is serverless artitecture, explain with proper example",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "Serverless architecture, also known as Function as a Service (FaaS), is a cloud computing model where the cloud provider manages the underlying infrastructure and automatically provisions and scales the resources needed to run functions or code snippets in response to events or triggers. In a serverless architecture, developers focus on writing and deploying individual functions without the need to manage or provision servers.\n\nHere's an example to illustrate serverless architecture:\n\nConsider a web application that allows users to upload images and automatically generate thumbnails. In a traditional server-based approach, you would need to set up and manage servers to handle incoming requests, process the images, and generate thumbnails.\n\nIn a serverless architecture, you would break down the functionality into smaller functions. Here's how it could work:\n\n1. User uploads an image to the web application.\n2. The web application triggers an event (e.g., file upload event) to a serverless function.\n3. The serverless function is designed to respond to this event. It retrieves the uploaded image, generates a thumbnail, and stores it in a storage service like Amazon S3 or Google Cloud Storage.\n4. Once the thumbnail is generated, the function's execution ends, and the resources are automatically released.\n5. The web application can then display the generated thumbnail to the user.\n\nIn this example, the serverless architecture eliminates the need to provision and manage servers continuously. The serverless functions are event-driven and executed in response to specific events or triggers, reducing the operational overhead and cost.\n\nBenefits of Serverless Architecture:\n- Scalability: Serverless platforms automatically scale functions based on incoming request volume, ensuring high availability and performance.\n- Cost-efficiency: You pay only for the actual execution time of functions, without the need to maintain idle servers.\n- Simplified Development: Developers can focus on writing and deploying functions, without worrying about server management or infrastructure provisioning.\n- Reduced Operational Overhead: Serverless architectures handle server and infrastructure management, automatic scaling, and other operational tasks, allowing developers to focus on application logic.\n- Faster Time-to-Market: Serverless architectures enable rapid development and deployment cycles due to their modular and scalable nature.\n\nIt's important to note that serverless architecture doesn't mean there are no servers involved; it means that the cloud provider abstracts away the underlying server management, allowing developers to focus solely on writing and deploying functions.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 9
    },
    {
      "subject": "sd",
      "title": "what are security concerns and solution for back-end applications",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "Security is of utmost importance for back-end applications. Here are some common security concerns and potential solutions for back-end applications:\n\n1. Injection Attacks:\nInjection attacks, such as SQL injection or OS command injection, occur when untrusted data is passed to interpreters or executed as commands. To mitigate injection attacks:\n\n- Use parameterized queries or prepared statements to prevent SQL injection.\n- Implement input validation and sanitization techniques to prevent other types of injection attacks.\n- Apply least privilege principles to database and system access.\n\n2. Authentication and Authorization:\nProper authentication and authorization mechanisms are critical for protecting back-end resources. To enhance security:\n\n- Implement secure user authentication, such as strong password policies, multi-factor authentication, and secure storage of credentials (hashed and salted).\n- Employ industry-standard protocols like OAuth or JWT for secure token-based authentication and session management.\n- Enforce proper authorization checks to ensure that authenticated users have appropriate access permissions.\n\n3. Cross-Site Scripting (XSS):\nXSS attacks occur when malicious scripts are injected into web pages, compromising user data and application integrity. To prevent XSS:\n\n- Implement output encoding or escaping to sanitize user-generated content.\n- Utilize Content Security Policy (CSP) to restrict the execution of scripts from unauthorized sources.\n- Use HTTP-only cookies to mitigate the risk of XSS attacks.\n\n4. Cross-Site Request Forgery (CSRF):\nCSRF attacks trick users into performing unwanted actions on authenticated websites. To prevent CSRF:\n\n- Implement CSRF tokens in forms or use SameSite cookies to prevent unauthorized requests.\n- Verify the origin and referer headers of incoming requests to ensure they match the expected values.\n\n5. Security Misconfigurations:\nImproperly configured servers, frameworks, or application settings can introduce security vulnerabilities. To address security misconfigurations:\n\n- Regularly update and patch software components, frameworks, and libraries to ensure they are free from known vulnerabilities.\n- Follow security best practices for server configuration, including secure default settings, access controls, and strong encryption protocols.\n- Implement secure communication using SSL/TLS for encrypting data in transit.\n\n6. Session Management:\nEffective session management is crucial to protect user sessions and prevent session hijacking or session fixation attacks. To ensure secure session management:\n\n- Implement session timeouts and session invalidation mechanisms.\n- Use secure session storage techniques, such as server-side session storage or encrypted session cookies.\n- Consider using session identifiers with sufficient entropy and rotation policies.\n\n7. Data Validation and Sanitization:\nEnsure that all user-provided data is properly validated and sanitized to prevent malicious input from causing security vulnerabilities. To achieve this:\n\n- Validate and sanitize user input on the server-side to prevent code injection, buffer overflows, or other attacks.\n- Employ input validation techniques such as whitelisting, blacklisting, and regular expression-based checks.\n\n8. Error Handling and Logging:\nProper error handling and logging are crucial for identifying and resolving security issues. To handle errors securely:\n\n- Implement secure error handling to avoid exposing sensitive information.\n- Log errors and system events securely, ensuring appropriate access controls and encryption.\n- Regularly monitor and analyze logs to identify and respond to potential security incidents.\n\n9. API Security:\nIf your back-end exposes APIs, secure API endpoints to prevent unauthorized access and protect sensitive data. To enhance API security:\n\n- Implement strong authentication and authorization mechanisms for API endpoints.\n- Use rate limiting, request throttling, and IP whitelisting to protect against excessive API requests and potential DDoS attacks.\n- Apply input validation and output encoding to prevent injection attacks through API inputs and outputs.\n\n10. Regular Security Audits and Testing:\nConduct regular security audits, vulnerability assessments, and penetration testing to identify and address potential security vulnerabilities. Follow industry best practices and guidelines for secure coding and secure application architecture.\n\nIt is crucial to stay updated\n\non emerging security threats and best practices to ensure the ongoing security of your back-end application. Regularly collaborate with security professionals, conduct security assessments, and stay vigilant to protect your application and its data from evolving security risks.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 10
    },
    {
      "subject": "sd",
      "title": "what are security concerns and solution for front-end applications",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "Security is a crucial aspect of front-end applications. Here are some common security concerns and potential solutions for front-end applications:\n\n1. Cross-Site Scripting (XSS):\nXSS occurs when malicious scripts are injected into web pages, compromising user data and application integrity. To mitigate XSS:\n\n- Use proper input validation and sanitization techniques.\n- Employ Content Security Policy (CSP) to restrict the execution of scripts from unauthorized sources.\n- Encode user input and output to prevent script injection.\n\n2. Cross-Site Request Forgery (CSRF):\nCSRF attacks trick users into performing unwanted actions on authenticated websites. To address CSRF:\n\n- Implement CSRF tokens in forms or use SameSite cookies to prevent unauthorized requests.\n- Verify the origin and referer headers of incoming requests to ensure they match the expected values.\n\n3. Clickjacking:\nClickjacking involves tricking users into clicking on hidden or invisible elements on a web page. To prevent clickjacking:\n\n- Utilize X-Frame-Options header with 'deny' or 'sameorigin' value to prevent embedding your application in iframes on other domains.\n- Implement frame-busting techniques such as the X-Frame-Options header with 'allow-from' value or JavaScript-based solutions.\n\n4. Injection Attacks:\nInjection attacks occur when malicious code is injected into user-provided data, targeting vulnerabilities in the application. To prevent injection attacks:\n\n- Use parameterized queries or prepared statements to avoid SQL injection.\n- Implement input validation and sanitization techniques to prevent OS command injection and other types of injection attacks.\n\n5. Insecure Direct Object References (IDOR):\nIDOR vulnerabilities allow unauthorized access to sensitive resources by manipulating direct object references. To mitigate IDOR:\n\n- Implement proper access controls and authorization mechanisms.\n- Avoid exposing sensitive identifiers in URLs and ensure server-side validation of user permissions.\n\n6. Insecure Communication:\nFront-end applications must ensure secure communication between the client and the server. To address insecure communication:\n\n- Use HTTPS (TLS/SSL) to encrypt data transmission and prevent eavesdropping and tampering.\n- Ensure that cookies and session data are marked as secure and HTTP-only.\n\n7. Authentication and Authorization:\nFront-end applications often handle user authentication and authorization. To enhance security:\n\n- Implement strong password policies, multi-factor authentication, and secure password storage (hashed and salted).\n- Employ session management best practices, including session timeouts, secure cookie handling, and session invalidation.\n\n8. Secure Coding Practices:\nAdhere to secure coding practices to minimize vulnerabilities:\n\n- Regularly update and patch libraries and frameworks to avoid known security vulnerabilities.\n- Follow secure coding guidelines and OWASP (Open Web Application Security Project) best practices.\n\n9. Content Security:\nPrevent unauthorized access to sensitive resources and protect against data leakage:\n\n- Implement proper access controls at both the front-end and back-end levels.\n- Apply authorization rules and implement role-based access control (RBAC) to restrict access to sensitive data.\n\n10. Regular Security Audits and Testing:\nConduct security audits and penetration testing to identify vulnerabilities and weaknesses in your application. Regularly test for security vulnerabilities and remediate them promptly.\n\nIt's essential to understand that front-end security is a shared responsibility with the back-end. Collaborate with back-end developers and security professionals to ensure end-to-end security across your application.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 11
    },
    {
      "subject": "sd",
      "title": "what are the things to consider while doing high level design for CI/CD",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "When designing a high-level Continuous Integration/Continuous Deployment (CI/CD) system, there are several important factors to consider. Here are key considerations:\n\n1. Source Code Management: Choose a version control system (e.g., Git) and establish best practices for branching, merging, and code review processes. Define how the code repository will be organized and managed.\n\n2. Build and Compilation: Determine how the application code will be built and compiled. Define the build process, including dependencies, build tools, and configuration files. Consider build automation tools like Jenkins, CircleCI, or GitLab CI/CD.\n\n3. Automated Testing: Define your testing strategy and determine the types of automated tests to be executed in the CI/CD pipeline. Consider unit tests, integration tests, end-to-end tests, and performance tests. Use testing frameworks and tools appropriate for your technology stack.\n\n4. Artifact Management: Establish a system for artifact management, ensuring that build artifacts, dependencies, and release packages are properly managed and versioned. Consider using artifact repositories like JFrog Artifactory or Nexus.\n\n5. Continuous Integration: Plan how code changes will be integrated and validated. Define the triggers for CI builds, such as commits to specific branches or pull requests. Automate the build, test, and static code analysis processes.\n\n6. Continuous Deployment: Determine how the application will be deployed and released to different environments (e.g., development, staging, production). Define deployment scripts, configuration management, and release strategies. Consider using deployment automation tools like Ansible, Kubernetes, or AWS CodeDeploy.\n\n7. Environment Management: Establish a strategy for managing different environments, including infrastructure provisioning and configuration. Define how environments will be replicated and kept in sync. Consider using infrastructure-as-code tools like Terraform or CloudFormation.\n\n8. Continuous Monitoring and Feedback: Integrate monitoring and feedback mechanisms into your CI/CD pipeline. Define how logs, metrics, and alerts will be collected and utilized to track the health, performance, and stability of your application.\n\n9. Security and Compliance: Incorporate security measures and compliance checks into your CI/CD pipeline. Plan for vulnerability scanning, code analysis, and security testing. Ensure that security practices are followed throughout the development and deployment processes.\n\n10. Rollback and Rollforward: Define strategies for rollback and rollforward in case of failed deployments or critical issues. Determine how to revert to a previous stable version or promote newer versions in a controlled manner.\n\n11. Documentation and Collaboration: Document the CI/CD pipeline design, including workflows, configurations, and deployment processes. Communicate the CI/CD practices and guidelines to the development team. Foster collaboration and knowledge sharing.\n\n12. Continuous Improvement: Embrace a culture of continuous improvement. Regularly assess and refine your CI/CD processes. Collect feedback from the team and stakeholders to identify areas for improvement and implement necessary changes.\n\nBy considering these factors during the high-level design phase of your CI/CD system, you can establish an efficient, automated, and reliable software delivery pipeline. Adapt these considerations to your specific project requirements, technology stack, and organizational constraints.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 12
    },
    {
      "subject": "sd",
      "title": "what are the things to consider while doing high level design on back end side?",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "When undertaking high-level design on the back-end side, there are several important factors to consider. Here are key considerations:\n\n1. System Architecture: Determine the overall system architecture for your back-end. Consider the appropriate architectural patterns such as monolithic, microservices, serverless, or a combination. Define the components, their responsibilities, and the interactions between them.\n\n2. Scalability and Performance: Design your back-end to handle scalability and high performance. Consider techniques like load balancing, caching, horizontal scaling, and vertical scaling. Plan for handling increased traffic and data volumes.\n\n3. Data Storage and Persistence: Determine the data storage and persistence mechanisms for your back-end. Consider relational databases, NoSQL databases, or a combination based on the data requirements. Plan for data modeling, indexing, and efficient querying.\n\n4. APIs and Integration: Define the API design and integration points for your back-end. Consider RESTful APIs, GraphQL, or other suitable API styles. Plan for authentication, authorization, versioning, error handling, and API documentation.\n\n5. Security: Incorporate security measures into your back-end design. Consider techniques such as encryption, secure communication (HTTPS), input validation, parameterized queries, and protection against common vulnerabilities (e.g., SQL injection, cross-site scripting).\n\n6. Authentication and Authorization: Plan the authentication and authorization mechanisms for your back-end. Consider techniques like token-based authentication (JWT), OAuth, or session-based authentication. Define user roles, permissions, and access control policies.\n\n7. Error Handling and Logging: Design your back-end to handle errors gracefully. Plan for proper error handling, logging, and monitoring. Consider logging frameworks, centralized log management, and error notification mechanisms.\n\n8. Caching: Plan for caching strategies to improve performance. Identify which data can be cached and determine the appropriate caching mechanism (e.g., in-memory cache, distributed cache) to reduce unnecessary data retrieval and processing.\n\n9. Messaging and Asynchronous Processing: Consider the use of messaging systems or queues for asynchronous processing and decoupling of components. Plan for handling message broker systems like RabbitMQ, Apache Kafka, or cloud-based services.\n\n10. Testing and Quality Assurance: Define your testing strategy for the back-end. Plan for unit testing, integration testing, and system testing. Consider tools like JUnit, Postman, or testing frameworks specific to your technology stack.\n\n11. Monitoring and Metrics: Design your back-end to enable monitoring and gather relevant metrics. Plan for tools and frameworks that can track system health, performance, and user behavior. Consider log analysis, application performance monitoring (APM), and error tracking solutions.\n\n12. Documentation: Document your high-level back-end design decisions, including architectural diagrams, data flow diagrams, API specifications, and deployment considerations. Provide clear documentation to guide developers who will work on the back-end.\n\nBy considering these factors during the high-level design phase of your back-end, you can ensure a well-structured, scalable, secure, performant, and maintainable system. Adapt these considerations to your specific project requirements and technology stack.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 13
    },
    {
      "subject": "sd",
      "title": "what are the things to consider while doing low level design on front end side?",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "When performing low-level design on the front-end side, there are several important factors to consider. Here are key considerations:\n\n1. Component Structure: Break down your user interface into smaller components. Consider the granularity and reusability of these components. Identify common patterns and create reusable components to promote code modularity and maintainability.\n\n2. Data Management: Determine how data will be managed within your front-end application. Consider the data flow, state management libraries/frameworks (such as Redux, MobX, or React Context), and how data will be fetched, cached, and synchronized with the server.\n\n3. Interaction and Event Handling: Define how user interactions and events will be handled. Consider the event-driven nature of your application and how different components will respond to user actions. Plan for event propagation, event delegation, and handling asynchronous events.\n\n4. Navigation and Routing: Determine how users will navigate through your application. Plan the navigation hierarchy, URL routing, and handling of browser history. Consider using libraries like React Router or Vue Router to manage routing efficiently.\n\n5. UI/UX Patterns and Guidelines: Establish consistent UI/UX patterns and guidelines for your application. Consider typography, color schemes, spacing, alignment, and the overall visual hierarchy. Ensure that your design aligns with brand guidelines and accessibility standards.\n\n6. Responsive Layout: Design your front-end application to be responsive and adaptable to different screen sizes and orientations. Consider using responsive CSS frameworks (like Bootstrap or Tailwind CSS) or implementing custom media queries and layout techniques.\n\n7. Error Handling and Validation: Define how errors and validation will be handled in your application. Plan for form validation, error messaging, and handling of server-side validation errors. Implement appropriate feedback mechanisms to guide users and handle errors gracefully.\n\n8. Performance Optimization: Optimize the performance of your front-end application. Consider techniques such as code splitting, lazy loading, caching, and minification to reduce load times. Optimize image sizes and utilize performance monitoring tools to identify and address bottlenecks.\n\n9. Accessibility: Ensure that your front-end design is accessible to users with disabilities. Consider standards like WCAG (Web Content Accessibility Guidelines) and implement features such as proper semantic HTML, keyboard navigation support, and assistive technologies compatibility.\n\n10. Internationalization and Localization: Plan for internationalization and localization of your front-end application. Consider how text translations, date/time formats, currency symbols, and locale-specific content will be managed. Utilize libraries like react-intl or vue-i18n for efficient internationalization.\n\n11. Testing: Define your testing strategy for the front-end application. Plan for unit testing, integration testing, and end-to-end testing. Consider tools like Jest, React Testing Library, or Cypress for efficient and comprehensive testing coverage.\n\n12. Documentation: Document your low-level design decisions, including architecture diagrams, component APIs, code conventions, and guidelines. Provide clear and concise documentation for developers who will work on the codebase in the future.\n\nBy considering these factors during the low-level design phase, you can ensure a well-structured, scalable, maintainable, performant, and user-friendly front-end application. Adapt these considerations to your specific project requirements and technology stack.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 14
    },
    {
      "subject": "sd",
      "title": "micro-service and monolithic system",
      "ques": "Explain what is micro-service and how it is different from monolithic system. Explain the key advantages of both micro-service and monolithic system. Also discuss when and where to use what type of systems",
      "links": [],
      "tags": [],
      "ans": "A microservice architecture and a monolithic system are two contrasting approaches to building software applications. Let's explore the definitions of each, highlight their key differences, discuss their advantages, and consider the scenarios in which each approach is suitable.\n\nMonolithic System:\nA monolithic system is an application architecture where all the components and functionalities are tightly integrated into a single codebase and deployed as a single unit. In a monolithic architecture, the application is typically built as a single executable or deployment artifact.\n\nAdvantages of Monolithic Systems:\n1. Simplicity: Monolithic systems are relatively straightforward to develop, test, and deploy since all components are bundled together.\n2. Performance: Monolithic systems can have better performance as there is no overhead of inter-service communication.\n3. Easier Development Environment: Developers have access to the entire codebase and can make changes without worrying about separate services or APIs.\n\nMicroservice Architecture:\nA microservice architecture is an architectural style where an application is divided into a set of small, loosely coupled, and independently deployable services. Each service focuses on a specific business capability and communicates with other services through lightweight protocols (e.g., HTTP, messaging).\n\nDifferences between Microservice and Monolithic Systems:\n1. Size and Complexity: Monolithic systems are large and contain all functionalities within a single codebase, whereas microservice architectures consist of multiple small services.\n2. Deployment and Scalability: In a monolithic system, the entire application is deployed as a single unit and scaled as a whole. In contrast, microservices can be deployed and scaled independently, allowing for better flexibility and resource utilization.\n3. Technology Diversity: Microservices allow the usage of different technologies and programming languages for different services, whereas monolithic systems typically use a single technology stack.\n\nAdvantages of Microservice Architecture:\n1. Scalability: Microservices can scale independently, allowing you to allocate resources precisely where they are needed, improving performance and cost-efficiency.\n2. Agility and Flexibility: Microservices enable teams to work autonomously on individual services, promoting faster development, deployment, and updates. This flexibility also facilitates technology exploration and adoption.\n3. Fault Isolation: In a microservice architecture, failures in one service do not cascade to others, enhancing fault isolation and resilience.\n4. Independent Deployment and Continuous Delivery: Each microservice can be deployed and updated independently, enabling more frequent releases and facilitating continuous integration and delivery practices.\n\nWhen to Use Monolithic Systems:\nMonolithic architectures are suitable when:\n- The application is small and straightforward, without complex business domains.\n- Rapid development and time-to-market are critical.\n- The team is small, and development resources are limited.\n- The application's functionalities are tightly coupled and do not require independent scaling or technology diversity.\n\nWhen to Use Microservice Architecture:\nMicroservice architectures are suitable when:\n- The application's functionalities are complex and can be modularized into independent services.\n- Independent scalability, fault isolation, and flexibility in technology choices are important.\n- Multiple teams are involved in development, and each can work on separate services.\n- Continuous delivery and frequent updates are desired.\n\nChoosing between monolithic and microservice architectures depends on the specific requirements, complexities, team structure, and scalability needs of the application. It's important to carefully evaluate the trade-offs and consider factors like development resources, deployment environments, and long-term maintenance before deciding on the architecture that best suits your project.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 15
    },
    {
      "subject": "sd",
      "title": "Can you explain the SOLID principles and how they can be applied in software development?",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "Sure! I can help you prepare for an interview for the position of Principal Software Developer. Let's go through a few technical and managerial questions and provide detailed answers with relevant code examples.\n\nQuestion 1: Can you explain the SOLID principles and how they can be applied in software development?\n\nAnswer:\nThe SOLID principles are a set of design principles that help in building maintainable, scalable, and flexible software systems. Here's a brief explanation of each principle along with an example:\n\n1. Single Responsibility Principle (SRP): A class or module should have only one reason to change. It should have a single responsibility.\n   Example:\n   ```java\n   // Bad example\n   class User {\n     void create() { ... }\n     void update() { ... }\n     void delete() { ... }\n   }\n\n   // Good example\n   class UserCreation {\n     void create() { ... }\n   }\n\n   class UserUpdate {\n     void update() { ... }\n   }\n\n   class UserDeletion {\n     void delete() { ... }\n   }\n   ```\n\n2. Open-Closed Principle (OCP): Software entities (classes, modules, functions) should be open for extension but closed for modification.\n   Example:\n   ```java\n   // Bad example\n   class ReportGenerator {\n     void generateReport(String type) {\n       if (type.equals(\"pdf\")) {\n         // Generate PDF report\n       } else if (type.equals(\"csv\")) {\n         // Generate CSV report\n       }\n     }\n   }\n\n   // Good example\n   interface ReportGenerator {\n     void generateReport();\n   }\n\n   class PdfReportGenerator implements ReportGenerator {\n     void generateReport() {\n       // Generate PDF report\n     }\n   }\n\n   class CsvReportGenerator implements ReportGenerator {\n     void generateReport() {\n       // Generate CSV report\n     }\n   }\n   ```\n\n3. Liskov Substitution Principle (LSP): Subtypes should be substitutable for their base types without affecting the correctness of the program.\n   Example:\n   ```java\n   // Bad example\n   class Rectangle {\n     void setWidth(int width) { ... }\n     void setHeight(int height) { ... }\n     int getArea() { ... }\n   }\n\n   class Square extends Rectangle {\n     void setWidth(int width) {\n       super.setWidth(width);\n       super.setHeight(width);\n     }\n\n     void setHeight(int height) {\n       super.setWidth(height);\n       super.setHeight(height);\n     }\n   }\n\n   // Good example\n   abstract class Shape {\n     abstract int getArea();\n   }\n\n   class Rectangle extends Shape {\n     void setWidth(int width) { ... }\n     void setHeight(int height) { ... }\n     int getArea() { ... }\n   }\n\n   class Square extends Shape {\n     void setSideLength(int sideLength) { ... }\n     int getArea() { ... }\n   }\n   ```\n\n4. Interface Segregation Principle (ISP): Clients should not be forced to depend on interfaces they do not use.\n   Example:\n   ```java\n   // Bad example\n   interface Payment {\n     void makePayment();\n     void refundPayment();\n     void processInvoice();\n   }\n\n   // Good example\n   interface Payment {\n     void makePayment();\n     void refundPayment();\n   }\n\n   interface InvoiceProcessing {\n     void processInvoice();\n   }\n   ```\n\n5. Dependency Inversion Principle (DIP): High-level modules should not depend on low-level modules. Both should depend on abstractions.\n   Example:\n   ```java\n   // Bad example\n   class PaymentService {\n     PaymentGateway paymentGateway;\n\n     void processPayment() {\n       paymentGateway.makePayment();\n     }\n   }\n\n   // Good example\n   interface PaymentGateway {\n     void makePayment();\n   }\n\n   class PaymentService {\n     PaymentGateway paymentGateway;\n\n     PaymentService(PaymentGateway paymentGateway) {\n       this.paymentGateway = paymentGateway;\n     }\n\n     void processPayment() {\n       paymentGateway.makePayment();\n     }\n   }\n   ```\n\nImplementing these SOLID principles helps in achieving modular, maintainable, and extensible code, making it easier to add new features or make changes without affecting the entire system.\n\nQuestion 2: Can you explain the difference between synchronous and asynchronous programming and provide an example?\n\nAnswer:\nSynchronous programming involves executing tasks sequentially, where each task must complete before the next one starts. Asynchronous programming, on the other hand, allows tasks to run independently, enabling concurrent execution. Here's an example in JavaScript:\n\n```javascript\n// Synchronous Example\nfunction synchronousTask() {\n  console.log('Start');\n  console.log('Task 1');\n  console.log('Task 2');\n  console.log('Task 3');\n  console.log('End');\n}\n\nsynchronousTask();\n```\n\nIn the above example, the tasks are executed sequentially. The output will be:\n\n```\nStart\nTask 1\nTask 2\nTask 3\nEnd\n```\n\n```javascript\n// Asynchronous Example\nfunction asynchronousTask() {\n  console.log('Start');\n  setTimeout(() => {\n    console.log('Task 1');\n  }, 1000);\n  setTimeout(() => {\n    console.log('Task 2');\n  }, 500);\n  setTimeout(() => {\n    console.log('Task 3');\n  }, 200);\n  console.log('End');\n}\n\nasynchronousTask();\n```\n\nIn the asynchronous example, tasks are scheduled to run independently using `setTimeout` functions. The output will be:\n\n```\nStart\nEnd\nTask 3\nTask 2\nTask 1\n```\n\nNote that the \"End\" is logged first, as it doesn't wait for the timeouts to complete. The timeouts introduce delays, and the tasks execute in the order specified by the timeouts.\n\nAsynchronous programming is beneficial when dealing with time-consuming tasks like network requests or file I/O operations, as it allows other parts of the application to continue executing without waiting for a task to complete. This helps improve responsiveness and efficiency, especially in scenarios where multiple tasks can be executed concurrently.\n\nQuestion 3: As a Principal Software Developer, how would you handle a conflict within your development team? Provide an example of a conflict resolution approach you would take.\n\nAnswer:\nHandling conflicts within a development team requires effective communication and conflict resolution skills. Here's an example of an approach to resolving conflicts:\n\n1. Understand the Issue: Start by understanding the root cause of the conflict. Listen to all parties involved and ensure that everyone has an opportunity to express their concerns and perspectives.\n\n2. Facilitate Open Discussion: Organize a meeting or discussion where team members can openly communicate their thoughts and feelings about the conflict. Encourage active listening and constructive dialogue.\n\n3. Find Common Ground: Identify areas of agreement and shared goals among team members. Encourage collaboration and emphasize the importance of working together towards a common objective.\n\n4. Seek Compromise: Encourage team members to find a middle ground or compromise that addresses the concerns of all parties involved. Brainstorm potential solutions and evaluate their feasibility and impact.\n\n5. Encourage Empathy: Foster an environment of empathy and understanding. Encourage team members to put themselves in each other's shoes to gain perspective and develop empathy towards their colleagues' viewpoints.\n\n6. Mediation if Necessary: If the conflict persists and a resolution cannot be reached through open discussions, consider involving a neutral mediator, such as a project manager or a senior team member, who can help facilitate the resolution process and find a fair compromise.\n\n7. Document and Learn: Document the conflict, its resolution, and any agreed-up\n\non actions or changes. Encourage the team to learn from the experience and implement processes or guidelines to prevent similar conflicts in the future.\n\nEffective conflict resolution promotes a healthy and productive team environment, enhancing collaboration and team morale.\n\nThese are just a few examples of the types of questions that may arise during an interview for the position of Principal Software Developer. Remember to provide detailed and thoughtful answers, supporting them with relevant code examples and real-life scenarios. Good luck with your interview!",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 16
    },
    {
      "subject": "sd",
      "title": "what are difference between 2XX, 4XX and 5XX http errors/",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "The main differences between 2xx, 4xx, and 5xx HTTP response status codes are:\n\n2xx Success\n- Indicates the request was successfully received, accepted, and processed by the server.\n- Example: 200 OK, 201 Created, 204 No Content\n\n4xx Client Error \n- Indicates there was a problem with the request sent by the client.\n- Example: 400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found\n\n5xx Server Error\n- Indicates there was a problem with the server while processing the request. \n- Example: 500 Internal Server Error, 503 Service Unavailable\n\nSome key differences:\n\n- 2xx codes indicate success. The request was accepted and handled properly.\n- 4xx codes indicate a client-side problem. There was an issue with the request itself.\n- 5xx codes indicate a server-side problem. The server failed to fulfill a valid request.\n\nCommon 2xx codes:\n- 200 OK - Request succeeded, response sent successfully.\n- 201 Created - Request succeeded, new resource created.\n- 204 No Content - Request succeeded, empty response sent. \n\nCommon 4xx codes:\n- 400 Bad Request - Malformed request, syntax error.\n- 401 Unauthorized - Authentication required, invalid credentials.  \n- 403 Forbidden - Server refused to authorize request.\n- 404 Not Found - Requested resource could not be found.\n\nCommon 5xx codes:\n- 500 Internal Server Error - Generic server failure.\n- 503 Service Unavailable - Server temporarily overloaded.\n\nSo in summary, 2xx is success, 4xx is client error, 5xx is server error. Knowing the common codes in each range helps debug issues.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 17
    },
    {
      "subject": "sd",
      "title": "what are ways to improve performance on server side?",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "Improving performance on the server side is crucial to ensure efficient handling of requests, reduced response times, and better scalability. Here are several ways to enhance server-side performance:\n\n1. **Optimize Database Queries:**\n   - Use indexing on frequently queried fields to speed up database searches.\n   - Avoid SELECT * queries and only retrieve the necessary data to reduce data transfer.\n   - Optimize complex queries and joins to minimize the database load.\n\n2. **Caching:**\n   - Implement caching mechanisms to store frequently accessed data in memory, reducing the need for repetitive computations or database queries.\n   - Use caching technologies like Redis or Memcached for efficient data storage and retrieval.\n\n3. **Load Balancing:**\n   - Distribute incoming requests across multiple server instances using load balancers to prevent overload on a single server.\n   - Implement auto-scaling to dynamically adjust the number of server instances based on demand.\n\n4. **Compress Responses:**\n   - Compress large responses, such as JSON or XML, before sending them to the client using techniques like Gzip or Brotli compression.\n   - Reducing the response size can significantly improve data transfer times.\n\n5. **Asynchronous Processing:**\n   - Use asynchronous programming to handle time-consuming tasks in the background while responding to other requests.\n   - Utilize technologies like message queues to decouple and process tasks asynchronously.\n\n6. **Optimized Code and Algorithms:**\n   - Write efficient and optimized code to reduce CPU and memory usage.\n   - Use algorithms with lower time complexity for data processing and computations.\n\n7. **Connection Pooling:**\n   - Use connection pooling to reuse established connections to the database, reducing the overhead of establishing new connections for each request.\n\n8. **Reverse Proxy:**\n   - Implement a reverse proxy like Nginx or Apache to handle static content delivery and offload tasks from the application server.\n\n9. **HTTP/2 and HTTP/3:**\n   - Upgrade to the latest HTTP protocols (HTTP/2 or HTTP/3) to leverage features like multiplexing, server push, and reduced latency.\n\n10. **GPGPU (General-Purpose Graphics Processing Unit):**\n    - Offload computational tasks to GPU cores, especially for parallelizable tasks like image processing or scientific computations.\n\n11. **Optimized Hosting Environment:**\n    - Choose a hosting provider that offers optimized hardware, network, and data centers to reduce latency and ensure high availability.\n\n12. **Monitoring and Profiling:**\n    - Regularly monitor server performance using tools like New Relic or Prometheus to identify bottlenecks and areas for improvement.\n    - Profile your application's code to identify areas that consume more resources and optimize them.\n\nImplementing these server-side performance optimization techniques will help ensure that your application can handle increasing traffic, reduce response times, and deliver a better user experience. Always remember to measure the impact of each optimization to ensure that it yields the desired improvements.\n\n\n------------\n\nHere are some effective ways to improve server-side performance:\n\n- **Use caching** - Cache repeated queries or computationally intensive operations using Redis, Memcached etc. This avoids unnecessary processing. \n\n- **Enable compression** - Use gzip compression for API responses and static assets. This reduces payload size over the network.\n\n- **Do less work** - Query only needed fields, add indexes to avoid full collection scans, batch insert operations. Minimize work done per request.\n\n- **Use a CDN** - Distribute static assets using a content delivery network. This reduces server load and latency.\n\n- **Scale horizontally** - Distribute load across multiple application servers. Allows handling higher loads and redundancy.\n\n- **Profile and optimize queries** - Identify slow queries using database profiling tools. Add indexes, optimize joins, caching to improve them.\n\n- **Limit resource usage** - Set limits on memory, CPU usage per process. Restart processes periodically to release resources.\n\n- **Use faster database** - Consider a faster database like Redis for caching, MongoDB for speed and scalability.\n\n- **Distribute processing** - Use message queues (RabbitMQ, Kafka) to distribute heavy processing across workers.\n\n- **Go serverless** - Use serverless architecture where possible. Services like AWS Lambda scale automatically.\n\n- **Monitor performance** - Use APM tools to identify bottlenecks. Stress test regularly for peak loads.\n\n- **Tune Linux kernel** - Adjust kernel settings for networking, file handles, processes etc. for high loads.\n\nSo in summary, identify your performance bottlenecks and use a combination of caching, scaling, profiling, database optimizations, and other techniques to improve server-side speed.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 18
    },
    {
      "subject": "sd",
      "title": "what are ways to improve performance on python side?",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "Improving performance on the Python side involves optimizing code, using appropriate data structures, and leveraging Python's features and libraries effectively. Here are several ways to enhance Python performance:\n\n1. **Use Built-in Functions and Libraries:**\n   - Utilize Python's built-in functions and standard libraries whenever possible, as they are usually optimized for performance and efficiency.\n\n2. **Choose the Right Data Structures:**\n   - Select the most appropriate data structures for your specific use case. Lists, sets, dictionaries, and tuples have different performance characteristics depending on the operation.\n\n3. **List Comprehensions and Generators:**\n   - Use list comprehensions and generators instead of traditional loops to create and process data more efficiently.\n\n4. **Avoid Global Variables:**\n   - Minimize the use of global variables as they can lead to unexpected side effects and performance issues.\n\n5. **Optimize Loops and Conditionals:**\n   - Reduce unnecessary iterations and conditions within loops to improve execution speed.\n\n6. **Use NumPy for Numeric Operations:**\n   - For numerical computations, use NumPy, a powerful library for efficient array operations.\n\n7. **Use Built-in Set Operations:**\n   - Utilize set operations such as union, intersection, and difference when working with sets.\n\n8. **Avoid Unnecessary Recomputation:**\n   - Cache and reuse computed results to avoid unnecessary recalculations.\n\n9. **Profile Your Code:**\n   - Use Python's built-in `cProfile` or external profilers like `line_profiler` or `memory_profiler` to identify performance bottlenecks.\n\n10. **Optimize String Concatenation:**\n    - Avoid using repeated string concatenation within loops. Instead, use `join()` or f-strings for more efficient concatenation.\n\n11. **Consider Using Numba or Cython:**\n    - For computationally intensive tasks, consider using Numba or Cython to compile Python code to native machine code, providing a significant speed boost.\n\n12. **Use Data Serialization:**\n    - Serialize data using formats like JSON, MessagePack, or Protocol Buffers to reduce the overhead of data transmission.\n\n13. **Implement Multithreading or Multiprocessing:**\n    - For CPU-bound tasks, use multithreading or multiprocessing to take advantage of multiple CPU cores.\n\n14. **Use Async/Await for I/O Bound Operations:**\n    - For I/O-bound tasks, use Python's `asyncio` module with async/await to enable asynchronous processing and avoid blocking calls.\n\n15. **Optimize File Operations:**\n    - Minimize the number of file reads and writes and use buffered I/O for better performance.\n\n16. **Use Data Streaming:**\n    - When processing large datasets, consider using data streaming techniques to avoid loading the entire dataset into memory at once.\n\nBy implementing these Python performance optimization techniques, you can make your code more efficient, reduce execution time, and improve overall application performance. Remember to measure the impact of each optimization to ensure it aligns with your specific use case and delivers the desired improvements.\n\n--------\n\nHere are some effective ways to improve performance in Python code:\n\n- Use built-in functions instead of pure Python code where possible - they are highly optimized (e.g. map(), filter(), etc).\n\n- Use NumPy and Pandas for numerical data - they provide fast vectorized operations.\n\n- Use generators and iterators for lazy evaluations instead of materializing full lists.\n\n- Use multiprocessing to distribute CPU-bound tasks across multiple processes.\n\n- Use threading for I/O-bound tasks to benefit from asynchronous processing. \n\n- Use Python typed annotations for static type checking - avoids dynamic overhead.\n\n- Cache frequently used results with memoization decorators or lru_cache.\n\n- Pre-allocate memory for results with numpy.zeros() instead of appends.\n\n- Profile code with cProfile, line_profiler to identify bottlenecks.\n\n- Optimize inner loops and performance critical code first. Move out constants, use local variables.\n\n- Avoid too many petty function calls. Reuse objects instead of recreating them.\n\n- Use Python bytecode compilers like Cython, Numba, PyPy to compile hotspots to C.\n\n- Optimize data pipelines with Dask for parallel execution on clusters.\n\n- Simplify code logic and remove redundancies - do less work overall.\n\n- Use a production-grade web framework like Django instead of raw WSGI.\n\n- Enable GZip compression in web apps. Use asynchronous workers like Celery.\n\nSo in summary, take advantage of Python's optimized libraries, distribute work efficiently, optimize hot code areas, and simplify unnecessary processing.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 19
    },
    {
      "subject": "sd",
      "title": "Explain IP, TCP, UDP, ARP, PING, HTTP in such a manner that one can crack a networking interview. ",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "Sure, I'd be happy to explain these networking concepts in a way that would be helpful for a networking interview.\n\n1. **IP (Internet Protocol)**:\n   IP is a fundamental protocol that enables data packets to be sent and received across networks. It provides the addressing scheme for devices in a network, allowing them to communicate with each other. IP addresses consist of two parts: network portion and host portion. The IPv4 address is the most common format (e.g., 192.168.1.1), while IPv6 provides a larger address space due to the exhaustion of IPv4 addresses.\n\n   Real-Life Example: IP addresses are like postal addresses. Imagine sending a letter to a friend. The street address represents the network part, and the house/apartment number represents the host part. This helps the postal service route the letter correctly.\n\n2. **TCP (Transmission Control Protocol)**:\n   TCP is a connection-oriented protocol that ensures reliable and ordered delivery of data packets between devices. It establishes a connection, splits data into packets, sends acknowledgments, and handles retransmissions if packets are lost.\n\n   Real-Life Example: Think of TCP as a telephone conversation. When you talk to someone on the phone, you expect them to confirm they received your message before proceeding. If a part of the message is unclear, they ask you to repeat it.\n\n3. **UDP (User Datagram Protocol)**:\n   UDP is a connectionless protocol that provides faster data transmission by sending packets without establishing a connection or requiring acknowledgments. It's used for time-sensitive applications where speed is crucial.\n\n   Real-Life Example: UDP is like sending postcards. You jot down the message, send it without worrying about confirmation, and don't mind if some cards get lost.\n\n4. **ARP (Address Resolution Protocol)**:\n   ARP is used to map IP addresses to MAC addresses in a local network. It helps devices find the physical address of a target device based on its IP address.\n\n   Real-Life Example: ARP is like asking for directions in an office. If you know someone's name (IP), you might ask colleagues to find out their desk number (MAC).\n\n5. **PING**:\n   PING (Packet Internet Groper) is a utility to test network connectivity between two devices. It sends an ICMP echo request and waits for an echo reply. It's often used to check if a host is reachable and estimate network latency.\n\n   Real-Life Example: PING is similar to shouting \"Hello!\" across a canyon. If you hear the echo back, you know the other side is reachable.\n\n6. **HTTP (Hypertext Transfer Protocol)**:\n   HTTP is a protocol used for transferring data over the web. It defines how clients (browsers) request resources and servers provide responses. HTTPS is the secure version that uses encryption.\n\n   Real-Life Example: HTTP is like ordering food in a restaurant. You send a request (order) to the waiter (server), and they bring you the food (response) you requested.\n\nFor detailed visual explanations and examples, you can refer to websites like:\n\n- [Computer Networking Basics](https://www.computer-networking.info/)\n- [TCP/IP Guide](https://www.tcpipguide.com/)\n- [NetworkLessons.com](https://networklessons.com/)\n\nThese resources provide diagrams, examples, and walkthroughs that can help you better understand these concepts for your networking interview preparation.\n\n\n\n======================>>>>>>>>>>\n\n\n\n    IP (Internet Protocol) is a set of rules that govern the way data is sent and received between computers on the internet. It is responsible for addressing and routing data packets across the network.\n    TCP (Transmission Control Protocol) is a connection-oriented protocol that guarantees the delivery of data. It does this by establishing a connection between the sender and receiver, and then sending the data in a series of packets. Each packet is acknowledged by the receiver, and if a packet is lost, it is resent.\n    UDP (User Datagram Protocol) is a connectionless protocol that does not guarantee the delivery of data. It is faster than TCP, but it is also less reliable. UDP is often used for applications where the reliability of the data is not as important, such as streaming audio and video.\n    ARP (Address Resolution Protocol) is a protocol that is used to resolve IP addresses to MAC addresses. MAC addresses are the physical addresses of network devices, and they are used by the network hardware to deliver data packets to the correct destination.\n    PING (Packet Internet Groper) is a utility used to test the reachability of a host on a network. It sends a small packet of data to the host and waits for a response. If the host responds, then the PING command is successful.\n    HTTP (Hypertext Transfer Protocol) is the protocol used to transfer web pages over the internet. It is a request-response protocol, where the client sends a request to the server, and the server sends a response back.\n\nHere are some additional details about these protocols that may be helpful for a networking interview:\n\n    IP addresses are 32-bit numbers that uniquely identify each device on a network. They are divided into classes, with Class A, Class B, and Class C being the most common.\n    TCP ports are numbers that identify the application that is sending or receiving data. For example, the HTTP port is 80, and the HTTPS port is 443.\n    UDP ports are also used to identify applications, but they are not as strictly defined as TCP ports.\n    ARP requests are broadcast to all devices on the network. The device with the matching IP address will respond with its MAC address.\n    PING uses ICMP (Internet Control Message Protocol) packets to send and receive data.\n    HTTP is a stateless protocol, which means that each request is independent of the previous request.\n",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 20
    },
    {
      "subject": "sd",
      "title": "Token & sessions",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "Ques - In token based authentication, what are best practices to store and use token for front-end applications?\n ==> Token-based authentication is a popular approach for securing frontend applications. When implementing token-based authentication, it's important to follow best practices to ensure the security and effectiveness of the authentication process. Here are some best practices for storing and using tokens in frontend applications:\n\n**1. Use HTTPS:** Always use HTTPS for communication between the frontend application and the backend server. This ensures that tokens are transmitted securely over encrypted connections, preventing eavesdropping and man-in-the-middle attacks.\n\n**2. Store Tokens Securely:**\n\n   - **Use HttpOnly and Secure Flags:** When storing tokens in cookies, set the HttpOnly and Secure flags. HttpOnly prevents JavaScript access to the token, reducing the risk of XSS attacks. The Secure flag ensures that cookies are only sent over HTTPS connections.\n   \n   - **LocalStorage vs. SessionStorage vs. Cookies:** Avoid storing tokens in localStorage or sessionStorage, as they are accessible through JavaScript and vulnerable to XSS attacks. Instead, consider using cookies with proper flags or browser's built-in storage mechanisms that offer better security.\n\n   - **Token Expiration:** Tokens should have a short expiration time to limit their potential for misuse if stolen. The frontend should handle token expiration gracefully by refreshing or reacquiring tokens as needed.\n\n   - **Protect Against CSRF:** Implement measures to protect against Cross-Site Request Forgery (CSRF) attacks, such as using anti-CSRF tokens.\n\n**3. Implement Token Refresh:** Use refresh tokens to extend the lifetime of access tokens without requiring users to log in again. This helps maintain user sessions while minimizing the risk of storing long-lived access tokens.\n\n**4. Avoid Storing Sensitive Data:** Tokens should not contain sensitive user data like passwords or personally identifiable information (PII). Keep tokens lightweight and store user-related information on the server, fetching it as needed using the token as an identifier.\n\n**5. Implement Token Revocation:** Provide a mechanism for users to revoke their tokens in case they suspect unauthorized access. This may involve implementing a token blacklist or a logout feature that invalidates tokens.\n\n**6. Secure Token Renewal:** When renewing or refreshing tokens, ensure that the process is secure and requires appropriate authentication. Use strong authentication mechanisms to verify the identity of the user requesting token renewal.\n\n**7. Rate Limit Token Requests:** Implement rate limiting on token-related endpoints to protect against abuse and DoS attacks.\n\n**8. Token Rotation:** Rotate refresh tokens and access tokens periodically. This helps mitigate the risk of long-lived tokens being compromised.\n\n**9. Secure Authentication Flow:** Implement secure authentication flows, such as the OAuth 2.0 Authorization Code Flow or Implicit Flow, depending on your application's requirements.\n\n**10. Implement Proper Error Handling:** Handle token-related errors gracefully, providing meaningful error messages to users while avoiding the exposure of sensitive information.\n\n**11. Regular Security Audits:** Conduct regular security audits and penetration testing of your frontend application to identify vulnerabilities and address them promptly.\n\n**12. Keep Libraries and Dependencies Updated:** Keep frontend libraries and dependencies up to date to ensure that known security vulnerabilities are patched.\n\n**13. Educate Developers:** Ensure that your development team is educated about best practices for token-based authentication and understands potential security risks.\n\nBy following these best practices, you can enhance the security and reliability of token-based authentication in your frontend applications and protect sensitive user data from unauthorized access.\n\n\n\nQues - what are best practices to store token in browser? Explain in details and proper code example in javascript\n\n==> Storing tokens securely in a browser is crucial to prevent unauthorized access and protect user data. Here are some best practices for securely storing tokens in a browser, along with code examples in JavaScript:\n\n**1. Use HttpOnly and Secure Cookies:**\n\n   - **Explanation:** Cookies with the HttpOnly and Secure flags are a secure way to store tokens in the browser. The HttpOnly flag prevents JavaScript access to the cookie, reducing the risk of XSS attacks. The Secure flag ensures that cookies are only sent over HTTPS connections.\n\n   - **JavaScript Code Example (Server-Side):**\n     When setting cookies on the server-side using a Node.js application, you can use the `httpOnly` and `secure` options:\n\n     ```javascript\n     const express = require('express');\n     const cookieParser = require('cookie-parser');\n     const app = express();\n\n     app.use(cookieParser());\n\n     app.get('/set-cookie', (req, res) => {\n       // Generate and set a secure HttpOnly cookie with a token\n       res.cookie('authToken', 'your_token_value', {\n         httpOnly: true,\n         secure: true, // Set this in a production environment with HTTPS\n         sameSite: 'strict', // Recommended to prevent CSRF attacks\n       });\n\n       res.send('Cookie set successfully');\n     });\n\n     app.listen(3000, () => {\n       console.log('Server is running on port 3000');\n     });\n     ```\n\n**2. Local Storage and Session Storage Considerations:**\n\n   - **Explanation:** Avoid storing tokens in localStorage or sessionStorage, as they are accessible through JavaScript and vulnerable to XSS attacks.\n\n**3. Token Expiration and Renewal:**\n\n   - **Explanation:** Tokens should have a short expiration time to limit their potential for misuse if stolen. Implement a mechanism for token renewal or refresh to maintain user sessions without requiring users to log in again.\n\n   - **JavaScript Code Example (Frontend - Token Renewal with Fetch API):**\n\n     ```javascript\n     // Function to renew an expired token\n     async function renewToken() {\n       try {\n         const response = await fetch('/token-renew', {\n           method: 'POST',\n           headers: {\n             'Content-Type': 'application/json',\n           },\n           // Include the expired token for validation on the server\n           body: JSON.stringify({ token: 'expired_token_here' }),\n         });\n\n         if (response.ok) {\n           const data = await response.json();\n           // Store the new token in a secure way (e.g., HttpOnly cookie)\n           document.cookie = `authToken=${data.newToken}; HttpOnly; Secure; SameSite=Strict`;\n         } else {\n           console.error('Token renewal failed');\n         }\n       } catch (error) {\n         console.error('Error renewing token:', error);\n       }\n     }\n     ```\n\n**4. Secure Token Rotation:**\n\n   - **Explanation:** Rotate refresh tokens and access tokens periodically to reduce the risk of long-lived tokens being compromised.\n\n**5. Token Revocation:**\n\n   - **Explanation:** Implement a mechanism for users to revoke their tokens in case they suspect unauthorized access.\n\n**6. Secure Token Storage Libraries:**\n\n   - **Explanation:** Consider using third-party libraries specifically designed for token storage and management. These libraries often provide additional security features.\n\nRemember that security is a multi-layered approach. Storing tokens securely in the browser is just one aspect of securing your application. You should also focus on server-side security, secure token handling on the server, and other security practices to ensure a comprehensive security posture.\n\n\nQues. how storing token in cookies prevent XSS, explain in detail with proper code example\n\n==> Storing tokens in HttpOnly cookies can help mitigate the risk of Cross-Site Scripting (XSS) attacks by preventing JavaScript from accessing the token directly. Here's a detailed explanation of how this works and a code example in JavaScript:\n\n**1. HttpOnly Cookies and XSS Mitigation:**\n\n- **Explanation:** Cross-Site Scripting (XSS) attacks occur when an attacker injects malicious scripts into a web application. These scripts run in the context of the victim's browser, potentially accessing sensitive data, such as authentication tokens, and performing actions on behalf of the user.\n\n- **Mitigation:** HttpOnly cookies are a security feature of web browsers that restrict JavaScript access to cookies. When a cookie is marked as HttpOnly, JavaScript running in the browser cannot read or modify its value. This means that even if an XSS vulnerability exists in your application, an attacker won't be able to directly access the token stored in an HttpOnly cookie.\n\n**2. Code Example:**\n\nLet's create a simple example to demonstrate how to set and read an HttpOnly cookie containing an authentication token using JavaScript and Node.js:\n\n**Server-Side Code (Node.js):**\n\n```javascript\nconst express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\n\napp.use(cookieParser());\n\napp.get('/set-cookie', (req, res) => {\n  // Simulate token generation (replace this with your actual token)\n  const authToken = 'your_auth_token';\n\n  // Set an HttpOnly cookie with the token\n  res.cookie('authToken', authToken, {\n    httpOnly: true, // Mark the cookie as HttpOnly\n    secure: true, // Set this in a production environment with HTTPS\n    sameSite: 'strict', // Recommended to prevent CSRF attacks\n  });\n\n  res.send('Cookie set successfully');\n});\n\napp.get('/get-cookie', (req, res) => {\n  // Read the authToken from the HttpOnly cookie\n  const authToken = req.cookies.authToken;\n\n  if (authToken) {\n    // Perform token validation and authentication here\n    res.send(`Authenticated with token: ${authToken}`);\n  } else {\n    res.status(401).send('Unauthorized');\n  }\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});\n```\n\n**Client-Side Code (JavaScript):**\n\nOn the client side, you typically don't need to write any special JavaScript code to handle HttpOnly cookies because the browser automatically manages them. However, you can make requests to the server to authenticate using the stored cookie, as shown in the `/get-cookie` route in the server-side code above.\n\nIn this example, we have an `/set-cookie` endpoint that sets an HttpOnly cookie with the authentication token, and an `/get-cookie` endpoint that reads and validates the token from the cookie.\n\nBy marking the cookie as HttpOnly, even if an attacker injects malicious JavaScript through an XSS vulnerability, they won't be able to access the token stored in the cookie, enhancing the security of your authentication mechanism.\n\n\nQues. does web cookies get shared automaticaly with each request ?\n\n==> Web cookies are automatically shared with each HTTP request made to the same domain and path from which the cookie was set. Cookies are an essential mechanism for maintaining state and session information in web applications. Here's how cookies work with HTTP requests:\n\n1. **Cookie Creation:** When a web server responds to an HTTP request, it can include a \"Set-Cookie\" header in the response. This header contains information about the cookie, including its name, value, expiration time, domain, and path.\n\n2. **Cookie Storage:** The web browser receives the \"Set-Cookie\" header and stores the cookie on the user's device. The browser maintains a cookie store, where it keeps track of all cookies associated with specific domains and paths.\n\n3. **Automatic Inclusion:** Whenever the user makes subsequent HTTP requests to the same domain and path, the browser automatically includes the cookies associated with that domain and path in the \"Cookie\" header of the request.\n\n4. **Server-Side Handling:** On the server side, the web application can read the \"Cookie\" header of incoming requests to access the values of cookies associated with the current user's session.\n\nThis automatic inclusion of cookies in each request allows web applications to maintain session information, user authentication, and other stateful data across multiple interactions with the user. It enables features like keeping users logged in, storing shopping cart contents, and tracking user preferences.\n\nIt's important to note that cookies are subject to various security and privacy considerations. For instance:\n\n- Cookies should be used for legitimate purposes, and sensitive data should not be stored directly in cookies.\n- Cookies can have attributes like \"HttpOnly\" and \"Secure\" to enhance security.\n- Cookies can be manipulated by attackers if not properly protected against Cross-Site Scripting (XSS) and Cross-Site Request Forgery (CSRF) attacks.\n- User privacy concerns have led to regulations like the General Data Protection Regulation (GDPR), which require informed consent and transparent cookie usage policies.\n\nAs a developer, it's important to be aware of these considerations when using cookies in web applications and to follow best practices for cookie security and privacy compliance.\n\n\nQues. what are best practices to store token in mobile devices? Explain in details and proper code example in javascript\n\n==> Storing tokens securely on mobile devices is critical for maintaining the security and privacy of user authentication and authorization. Here are best practices for securely storing tokens on mobile devices, along with code examples in JavaScript for both iOS and Android platforms:\n\n**1. Use Native Storage Solutions:**\n\n- **Explanation:** Leverage platform-specific storage mechanisms provided by iOS and Android for storing sensitive data like tokens. These mechanisms are designed with security in mind and are more difficult to access compared to general storage options.\n\n**2. iOS: Keychain Services**\n\n- **Explanation:** On iOS, use the Keychain Services API to securely store sensitive data like tokens. The Keychain is a secure and encrypted storage space dedicated to storing sensitive information.\n\n**Code Example (Swift):**\n\n```swift\nimport UIKit\nimport Security\n\n// Store token in Keychain\nfunc storeTokenInKeychain(token: String) {\n    if let data = token.data(using: .utf8) {\n        let query = [\n            kSecClass: kSecClassGenericPassword,\n            kSecAttrAccount: \"your_app_token_account\",\n            kSecValueData: data\n        ] as [CFString: Any]\n\n        SecItemDelete(query as CFDictionary)\n        SecItemAdd(query as CFDictionary, nil)\n    }\n}\n\n// Retrieve token from Keychain\nfunc retrieveTokenFromKeychain() -> String? {\n    let query = [\n        kSecClass: kSecClassGenericPassword,\n        kSecAttrAccount: \"your_app_token_account\",\n        kSecReturnData: kCFBooleanTrue!,\n        kSecMatchLimit: kSecMatchLimitOne\n    ] as [CFString: Any]\n\n    var data: AnyObject?\n    if SecItemCopyMatching(query as CFDictionary, &data) == noErr {\n        if let tokenData = data as? Data, let token = String(data: tokenData, encoding: .utf8) {\n            return token\n        }\n    }\n    return nil\n}\n```\n\n**3. Android: SharedPreferences or EncryptedSharedPreferences**\n\n- **Explanation:** On Android, you can use SharedPreferences for basic data storage or EncryptedSharedPreferences for enhanced security. EncryptedSharedPreferences encrypts the data stored in SharedPreferences, making it more secure.\n\n**Code Example (Java/Kotlin):**\n\n```java\nimport android.content.Context;\nimport android.content.SharedPreferences;\nimport androidx.security.crypto.EncryptedSharedPreferences;\nimport androidx.security.crypto.MasterKeys;\n\n// Store token using EncryptedSharedPreferences\npublic void storeTokenInSharedPreferences(Context context, String token) {\n    try {\n        String masterKeyAlias = MasterKeys.getOrCreate(MasterKeys.AES256_GCM_SPEC);\n        SharedPreferences sharedPreferences = EncryptedSharedPreferences.create(\n            \"your_app_token_prefs\",\n            masterKeyAlias,\n            context,\n            EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,\n            EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM\n        );\n\n        SharedPreferences.Editor editor = sharedPreferences.edit();\n        editor.putString(\"authToken\", token);\n        editor.apply();\n    } catch (Exception e) {\n        // Handle encryption error\n    }\n}\n\n// Retrieve token from EncryptedSharedPreferences\npublic String retrieveTokenFromSharedPreferences(Context context) {\n    try {\n        String masterKeyAlias = MasterKeys.getOrCreate(MasterKeys.AES256_GCM_SPEC);\n        SharedPreferences sharedPreferences = EncryptedSharedPreferences.create(\n            \"your_app_token_prefs\",\n            masterKeyAlias,\n            context,\n            EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,\n            EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM\n        );\n\n        return sharedPreferences.getString(\"authToken\", null);\n    } catch (Exception e) {\n        // Handle decryption error\n        return null;\n    }\n}\n```\n\n**4. Use Biometric Authentication (Optional):**\n\n- **Explanation:** For added security, consider implementing biometric authentication (e.g., fingerprint or face recognition) to protect access to the stored tokens. This ensures that only authorized users can access sensitive data.\n\n**5. Implement Token Expiry and Renewal:**\n\n- **Explanation:** Ensure that tokens have a short expiration time and implement a mechanism to renew tokens when they expire. This minimizes the risk associated with long-lived tokens stored on the device.\n\n**6. Protect Against Jailbreaking/Rooting:**\n\n- **Explanation:** Detect if a device is jailbroken (iOS) or rooted (Android) and implement additional security measures or prevent the use of the app on such devices.\n\n**7. Regularly Update Dependencies:**\n\n- **Explanation:** Keep your mobile app and any third-party libraries or SDKs up to date to ensure that known security vulnerabilities are patched.\n\nBy following these best practices, you can enhance the security of token storage on mobile devices and reduce the risk of unauthorized access to sensitive user data.\n\n\nQues. \n\n\n",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 21
    },
    {
      "subject": "sd",
      "title": "what does scalbility ?",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "In the context of frontend applications, scalability refers to the ability of the application to handle an increasing number of users, requests, or concurrent connections while maintaining acceptable performance and responsiveness. Scalability is essential for ensuring that your frontend can handle growth in user traffic without degrading the user experience.\n\nScalability in frontend applications can encompass various aspects:\n\n1. **Performance:** As user traffic grows, a scalable frontend application should continue to provide fast response times and smooth user interactions. This includes minimizing page load times, rendering components efficiently, and optimizing client-side code for speed.\n\n2. **Concurrency:** Scalable frontend applications should handle a large number of simultaneous connections and user interactions without becoming unresponsive or crashing. This often involves managing asynchronous operations, such as handling multiple HTTP requests, user interactions, and events concurrently.\n\n3. **Resource Management:** Efficiently manage resources like memory and CPU usage to ensure the application can run smoothly even under heavy loads. Properly managing resource utilization helps prevent memory leaks, crashes, and slowdowns.\n\n4. **Caching:** Implement client-side and server-side caching strategies to reduce the need for redundant requests and data fetching. Caching can significantly improve the frontend's ability to handle increased traffic.\n\n5. **Load Balancing:** Distribute incoming requests across multiple frontend servers or instances to balance the load and prevent any single server from becoming a bottleneck. Load balancers help ensure even distribution of traffic.\n\n6. **Content Delivery:** Use content delivery networks (CDNs) to serve static assets like images, stylesheets, and JavaScript files from edge locations closer to the end users. CDNs improve the delivery speed of these assets and reduce the load on your frontend servers.\n\n7. **State Management:** Implement efficient state management solutions, such as client-side state management libraries or frameworks like Redux or Mobx, to handle application state in a scalable manner. Proper state management helps avoid performance bottlenecks and ensures a consistent user experience.\n\n8. **Optimization:** Continuously monitor and optimize your frontend code, assets, and dependencies. Minimize the size of JavaScript bundles, use code splitting, and lazy loading to reduce initial page load times.\n\n9. **Scalable Architecture:** Design the frontend application with a scalable architecture that allows for modularization and componentization. This enables teams to work on different parts of the application independently, facilitating collaboration and faster development.\n\n10. **Auto-scaling:** In cloud environments, consider implementing auto-scaling mechanisms that automatically provision additional frontend resources (e.g., servers or containers) during traffic spikes and scale down during periods of lower demand.\n\n11. **Testing and Profiling:** Use performance testing and profiling tools to identify bottlenecks, memory leaks, or inefficient code early in the development process. This helps you address scalability issues proactively.\n\n12. **Monitoring and Alerting:** Implement monitoring and alerting solutions to track the health and performance of your frontend application in real-time. This allows you to detect and respond to issues promptly.\n\nScalability in frontend applications is crucial for ensuring a positive user experience, especially as your application attracts more users and experiences increased traffic. A well-designed and scalable frontend can adapt to changing demands and provide consistent performance and responsiveness.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 22
    },
    {
      "subject": "sd",
      "title": "why do we use Adaptor design pattern?",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "The Adapter design pattern is used to bridge the gap between two incompatible interfaces or classes by providing a wrapper that allows them to work together seamlessly. It is a structural design pattern that is particularly useful in scenarios where you need to integrate new or existing components that have interfaces or behaviors that are incompatible with each other. Here are some common reasons for using the Adapter design pattern:\n\n1. **Legacy Code Integration:** When you have existing code or components that use an older or incompatible interface, you can create adapters to make them compatible with newer code or interfaces. This allows you to leverage existing functionality without having to rewrite or modify the legacy code.\n\n2. **Third-Party Library Integration:** When you want to use a third-party library or service that has an interface that doesn't align with your application's requirements, you can create an adapter to make it compatible. This avoids the need to modify the third-party library's code.\n\n3. **Interface Standardization:** In situations where you have multiple classes or components with varying interfaces, you can create adapters to standardize their interfaces. This simplifies the interaction between different parts of your system.\n\n4. **Interoperability:** When you need to make different components or systems work together, especially in a heterogeneous environment, adapters can mediate the communication and data exchange between them. This is common in distributed systems and integration scenarios.\n\n5. **Testing and Mocking:** In testing, you may want to create mock objects or stubs to simulate the behavior of real objects. Adapters can be used to create mock objects that implement the same interface as the real objects but provide custom behavior for testing purposes.\n\n6. **Version Compatibility:** When you need to maintain compatibility with different versions of a component or interface, you can create adapters that adapt the behavior of your code to work with different versions of the same interface.\n\n7. **Separation of Concerns:** Adapters help keep concerns separate by isolating the code required to make two incompatible interfaces work together. This promotes modularity and maintainability in your codebase.\n\n8. **Plug-and-Play Components:** Adapters enable you to create plug-and-play components that can be easily replaced or upgraded without affecting the rest of the system. New components can be designed to conform to a standardized interface that existing adapters can work with.\n\n**Example:**\n\nConsider a scenario where you have a legacy database system with its own API, and you want to use this database in a modern web application that interacts with databases using a different interface. You can create an adapter that translates the calls made by the web application into calls that the legacy database system can understand. This adapter allows the web application to work seamlessly with the legacy database without modifying the database code.\n\nIn summary, the Adapter design pattern is used to make incompatible interfaces or classes work together without changing their source code. It promotes reusability, flexibility, and maintainability by enabling the integration of components with differing interfaces and behaviors.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 23
    },
    {
      "subject": "sd",
      "title": "what are OpenStack technologies",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "OpenStack is an open-source cloud computing platform that provides a set of technologies and services for building and managing private and public clouds. OpenStack is designed to offer flexibility, scalability, and interoperability, making it a popular choice for organizations looking to create and manage their cloud infrastructure. Here are some of the core OpenStack technologies and services:\n\n1. **Nova (Compute):** Nova is the OpenStack compute service responsible for provisioning and managing virtual machines (VMs) and instances. It provides APIs for launching, resizing, and terminating VMs.\n\n2. **Swift (Object Storage):** Swift is a scalable and highly available object storage system. It is designed to store and retrieve large amounts of unstructured data, such as images, videos, and backups.\n\n3. **Cinder (Block Storage):** Cinder is the block storage service that manages and provides block-level storage volumes for use with VMs. It offers features like snapshots and volume backups.\n\n4. **Neutron (Networking):** Neutron is the networking service in OpenStack, responsible for managing network resources and connectivity for VMs. It provides networking APIs for creating and configuring virtual networks, routers, subnets, and more.\n\n5. **Horizon (Dashboard):** Horizon is the web-based dashboard for managing and monitoring OpenStack resources. It offers a graphical user interface (GUI) for administrators and users to interact with OpenStack services.\n\n6. **Keystone (Identity):** Keystone is the identity and authentication service for OpenStack. It manages user authentication, authorization, and service catalog information. Keystone integrates with various identity sources, including LDAP and Active Directory.\n\n7. **Glance (Image Service):** Glance is the image service that allows you to store and manage virtual machine images. It provides a repository for VM images, making it easy to deploy new instances.\n\n8. **Heat (Orchestration):** Heat is the orchestration service that enables you to define and manage cloud infrastructure as code. It uses templates to describe the relationships and dependencies between resources, making it easier to automate the deployment of complex applications.\n\n9. **Ceilometer (Telemetry):** Ceilometer is the telemetry and monitoring service that collects data about the usage and performance of OpenStack services and resources. It can be integrated with various monitoring tools and services.\n\n10. **Aodh (Alarming):** Aodh is the alarming service that works in conjunction with Ceilometer to provide alarm and notification functionality based on collected telemetry data.\n\n11. **Trove (Database Service):** Trove is the database service that offers database-as-a-service (DBaaS) functionality. It allows users to provision and manage database instances easily.\n\n12. **Sahara (Data Processing):** Sahara is the data processing service for OpenStack. It provides a framework for provisioning and managing big data clusters and processing frameworks like Hadoop and Spark.\n\n13. **Magnum (Container Orchestration):** Magnum is the container orchestration service that enables the management of container clusters using popular container orchestration engines like Docker Swarm, Kubernetes, and Apache Mesos.\n\n14. **Zun (Container Management):** Zun is a container management service that complements Magnum by providing container lifecycle management for Docker and Kubernetes containers.\n\n15. **Barbican (Key Management):** Barbican is the key management service, providing secure key storage and management for encryption and security-related operations.\n\n16. **Ironic (Bare Metal Provisioning):** Ironic is the bare-metal provisioning service in OpenStack. It allows you to manage and provision physical servers as well as virtual instances.\n\nThese are some of the key technologies and services within the OpenStack ecosystem. OpenStack is highly modular, allowing organizations to select and deploy the components that best fit their cloud infrastructure needs, whether it's for private clouds, public clouds, or hybrid cloud environments.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 24
    },
    {
      "subject": "sd",
      "title": "how checksum is used, Explain each steps with code example in javascript",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "Checksums are used in various computing applications to verify the integrity of data, especially during transmission or storage. A checksum is a value computed from the data that is used to detect errors or changes in the data. Here's how checksums are typically used, along with a JavaScript code example to calculate a simple checksum.\n\n**Step 1: Data Preparation**\n1. You start with a piece of data that you want to verify, such as a file, message, or packet of data.\n\n**Step 2: Checksum Calculation**\n2. Calculate a checksum value from the data using a specific algorithm or formula. Common checksum algorithms include CRC32, MD5, SHA-1, and SHA-256.\n\n**Step 3: Attachment or Storage**\n3. Attach the checksum value to the data or store it separately. This is typically done by appending the checksum to the data, transmitting it alongside the data, or storing it in a database or metadata.\n\n**Step 4: Data Transmission or Storage**\n4. Transmit or store the data, along with the calculated checksum value.\n\n**Step 5: Data Retrieval**\n5. When the data is received or retrieved, the receiver or user recalculates the checksum from the received data using the same algorithm used in step 2.\n\n**Step 6: Comparison**\n6. Compare the recalculated checksum value with the received checksum value (the one attached to the data or transmitted separately).\n\n**Step 7: Verification**\n7. If the recalculated checksum matches the received checksum, the data is considered valid and has not been tampered with during transmission or storage. If there is a mismatch, it indicates potential corruption or tampering, and appropriate action can be taken (e.g., requesting a retransmission or rejecting the data).\n\nHere's a JavaScript code example that calculates a simple checksum for a string using a basic checksum algorithm:\n\n```javascript\n// Function to calculate a simple checksum for a string\nfunction calculateChecksum(input) {\n  let checksum = 0;\n\n  // Iterate through each character in the input string\n  for (let i = 0; i < input.length; i++) {\n    checksum += input.charCodeAt(i);\n  }\n\n  return checksum;\n}\n\n// Example data\nconst data = \"Hello, checksum!\";\n\n// Calculate the checksum for the data\nconst checksum = calculateChecksum(data);\n\nconsole.log(`Data: \"${data}\"`);\nconsole.log(`Checksum: ${checksum}`);\n```\n\nIn this example, the `calculateChecksum` function computes the checksum by adding up the ASCII values of the characters in the input string. The resulting checksum is then printed to the console.\n\nPlease note that this example is overly simplistic and should not be used for critical applications. Real-world checksum algorithms, like CRC32 or cryptographic hash functions (e.g., SHA-256), provide stronger error-checking capabilities and security.\n\n============>>>>>>>>>>>\n\n\n\nChecksums are indeed used to protect the integrity of data, but they are not intended to provide security against deliberate tampering. The primary purpose of a checksum is to detect accidental errors or corruption in data during transmission or storage. While checksums can help detect data tampering in some cases, they are not a foolproof method for ensuring data security.\n\nHere are some key points to understand about checksums and their limitations:\n\n1. **Accidental Errors:** Checksums are effective at detecting accidental errors that can occur due to issues like data transmission over unreliable networks, disk drive malfunctions, or memory corruption. In these cases, changes to the data are typically unintentional.\n\n2. **Limited Security:** Checksums are not designed to protect against deliberate tampering or attacks by malicious actors. If an attacker knows the checksum algorithm being used, they can potentially modify the data and recalculate the checksum to match the tampered data. This is why checksums are not suitable for ensuring data security in security-critical applications.\n\n3. **Cryptographic Hash Functions:** For security purposes, cryptographic hash functions (e.g., SHA-256, SHA-3) are used instead of simple checksums. Cryptographic hash functions are designed to be resistant to tampering, preimage attacks, and collisions. They are used to verify the integrity of data and ensure that the data has not been altered intentionally.\n\n4. **Checksum Algorithms:** Different checksum algorithms provide varying levels of error detection capability. For example, cyclic redundancy check (CRC) algorithms are commonly used for error detection in network communication because they can efficiently detect common types of errors. However, they are not suitable for security-critical applications.\n\nIn summary, checksums are beneficial for detecting accidental errors in data and ensuring data integrity in non-security-critical applications. However, for security purposes and to protect against deliberate tampering, cryptographic hash functions and digital signatures are used. These cryptographic techniques provide a higher level of security by making it computationally infeasible for an attacker to tamper with data and generate matching hash values.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 25
    },
    {
      "subject": "sd",
      "title": "",
      "ques": "Etag",
      "links": [],
      "tags": [],
      "ans": "An ETag (Entity Tag) is an HTTP header used to determine whether the content of a resource has changed since it was last requested. ETags are used for a variety of purposes in web applications and HTTP communication. Here's why ETags are used:\n\n1. **Efficient Caching:** ETags are commonly used in conjunction with caching mechanisms to improve the efficiency of web applications. When a client (e.g., web browser) requests a resource from a web server, the server can generate an ETag based on the content of the resource. The ETag is sent along with the response. The client can then use this ETag for subsequent requests. If the resource hasn't changed (as indicated by a matching ETag), the server can respond with a 304 Not Modified status code, and the client can use its cached copy of the resource, reducing unnecessary data transfer and improving performance.\n\n2. **Conditional Requests:** ETags are used in conditional requests, such as `If-Match` and `If-None-Match` headers in HTTP. These headers allow clients to specify conditions for a request. For example, a client can include an `If-None-Match` header with an ETag value to request a resource only if it has changed since the client's last request.\n\n3. **Concurrency Control:** ETags are used for concurrency control in scenarios where multiple clients may be trying to update the same resource simultaneously. By including an ETag in a request, a client can indicate that it wants to perform an operation (e.g., update) only if the resource's ETag matches the one it has. This helps prevent conflicts and data corruption.\n\n4. **Resource Validation:** ETags are used to validate the freshness and correctness of cached resources. When a cached resource has an associated ETag, the client can include that ETag in subsequent requests to check if the cached resource is still valid or if it needs to be updated.\n\n5. **Partial Content (Range Requests):** ETags can be used in combination with the `Range` header to support partial content requests. Clients can include an ETag in a request for a specific range of a resource. If the server supports partial content and the ETag matches, it can respond with the requested partial content.\n\nHere's a simple example in JavaScript that demonstrates how to use the `If-None-Match` header with an ETag to check if a resource has been modified:\n\n```javascript\nconst fetch = require('node-fetch'); // Assuming Node.js environment\n\n// URL of the resource\nconst url = 'https://example.com/resource';\n\n// ETag value from a previous response or cache\nconst cachedETag = '123456789';\n\n// Make a conditional request using the ETag\nfetch(url, {\n  headers: {\n    'If-None-Match': cachedETag,\n  },\n})\n  .then((response) => {\n    if (response.status === 304) {\n      console.log('Resource not modified; using cached copy.');\n    } else if (response.status === 200) {\n      console.log('Resource has changed; updating cached copy.');\n      // Process and update the resource\n    }\n  })\n  .catch((error) => {\n    console.error('Error:', error);\n  });\n```\n\nIn this example, the client sends a request with the `If-None-Match` header containing the cached ETag value. If the server responds with a 304 status code, it means the resource has not changed, and the client can continue using the cached copy. If the server responds with a 200 status code, it means the resource has been modified, and the client can update its cached copy.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 26
    }
  ],
  "shell": [
    {
      "subject": "shell",
      "title": "Check Disk Space",
      "ques": "How to Check Disk Space in Linux?",
      "links": [
        {
          "name": "https://phoenixnap.com/kb/linux-check-disk-space"
        }
      ],
      "tags": [
        {
          "name": "General"
        },
        {
          "name": "linux"
        }
      ],
      "ans": "\n/*\nThe df command stands for disk free, and it shows you the amount of space taken up by \ndifferent drives. By default, df displays values in 1-kilobyte blocks.\n*/\ndf\n\n\n/* Display Usage in Megabytes and Gigabytes */\ndf -h\n\n/* Understanding the Output Format */\n\nFilesystem         Size      Used     Avail    Use%    Mounted on\n\nudev               210M        0        210M     0%       /dev\n\ntmpfs              49M       1004K      48M      3%       /run\n\n/dev/sda2          7.9G       4.3G      3.2G     58%      /\n\nYour output may have more entries. The columns should be self-explanatory:-\n\nFilesystem – This is the name of each particular drive. This includes physical hard drives, \nlogical (partitioned) drives, and virtual or temporary drives.\nSize – The size of the filesystem.\nUsed – Amount of space used on each filesystem.\nAvail – The amount of unused (free) space on the filesystem.\nUse% – Shows the percent of the disk used.\nMounted on – This is the directory where the file system is located. This is also sometimes \ncalled a mount point.\n\nThe list of filesystems includes your physical hard drive, as well as virtual hard drives:-\n\n/dev/sda2 – This is your physical hard drive. It may be listed as /sda1, /sda0, or you may even have more than one. /dev stands for device.\nudev – This is a virtual directory for the /dev directory. This is part of the Linux operating \nsystem.\ntmpfs – You may have several of these. These are used by /run and other Linux processes as \ntemporary filesystems for running the operating system. For example, the tmpfs /run/lock is \nused to create lockfiles. These are the files that prevent multiple users from changing the \nsame file at the same time.\n\n\n/* Display a Specific File System */\ndf -h /dev/sda2\ndf -h /\n\n/* Display File Systems by Type */\ndf -ht ext4\n\n/* Display Size in 1000 Instead of 1024 */\ndu -H\n\n/*\nCheck Disk Space in Linux With du Command\nThe du command displays disk usage\n*/\ndu\ndu -h\ndu -hs\ndu -hs /etc\nsudo du -hs /etc\n\n\n/* HELP */\ndf --help or du --help.\n",
      "diff": 1,
      "imp": 1,
      "cate": [
        "disk"
      ],
      "id": 1
    }
  ],
  "git": [
    {
      "subject": "git",
      "title": "Git general commands",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "git remote -v\n\ngit push origin HEAD\n\ngit fetch --tags --force\n\ngit fetch -t\n\ngit tag\n\ngit checkout -b \"<branch_name>\" -t origin/master\n\ngit pull --rebase\n\ngit rebase -i HEAD~2 // Squash",
      "diff": 3,
      "imp": 3,
      "cate": [
        "general"
      ],
      "id": 1
    }
  ],
  "py": [
    {
      "subject": "py",
      "title": "what are standard code interview question related to python. Provide detailed answer for each question with example",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "Sure! Here are some standard code interview questions related to Python along with detailed answers and examples:\n\nQuestion 1: Reverse a String\nWrite a Python function to reverse a given string.\n\nAnswer:\n```python\ndef reverse_string(input_string):\n    return input_string[::-1]\n\n# Example usage\nprint(reverse_string(\"Hello, World!\"))  # Output: \"!dlroW ,olleH\"\n```\n\nQuestion 2: Check if a String is Palindrome\nWrite a Python function to check if a given string is a palindrome (reads the same forwards and backwards).\n\nAnswer:\n```python\ndef is_palindrome(input_string):\n    return input_string == input_string[::-1]\n\n# Example usage\nprint(is_palindrome(\"radar\"))  # Output: True\nprint(is_palindrome(\"python\"))  # Output: False\n```\n\nQuestion 3: Find the Largest Number in a List\nWrite a Python function to find the largest number in a given list.\n\nAnswer:\n```python\ndef find_largest_number(numbers):\n    return max(numbers)\n\n# Example usage\nnumbers = [3, 9, 5, 2, 8, 1]\nprint(find_largest_number(numbers))  # Output: 9\n```\n\nQuestion 4: Count the Occurrences of Each Element in a List\nWrite a Python function to count the occurrences of each element in a given list and return a dictionary with the counts.\n\nAnswer:\n```python\ndef count_elements(lst):\n    count_dict = {}\n    for item in lst:\n        if item in count_dict:\n            count_dict[item] += 1\n        else:\n            count_dict[item] = 1\n    return count_dict\n\n# Example usage\nnumbers = [1, 2, 3, 2, 1, 3, 3, 4]\nprint(count_elements(numbers))  # Output: {1: 2, 2: 2, 3: 3, 4: 1}\n```\n\nQuestion 5: Find the Factorial of a Number\nWrite a Python function to calculate the factorial of a given number.\n\nAnswer:\n```python\ndef factorial(n):\n    if n == 0 or n == 1:\n        return 1\n    else:\n        return n * factorial(n - 1)\n\n# Example usage\nprint(factorial(5))  # Output: 120\n```\n\nQuestion 6: Determine if a Number is Prime\nWrite a Python function to check if a given number is prime.\n\nAnswer:\n```python\ndef is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\n# Example usage\nprint(is_prime(17))  # Output: True\nprint(is_prime(10))  # Output: False\n```\n\nThese are just a few examples of standard code interview questions related to Python. They cover a range of concepts including string manipulation, list manipulation, mathematical calculations, and logical operations. It's important to practice coding these types of questions to improve your problem-solving skills and familiarity with the Python programming language.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 1
    },
    {
      "subject": "py",
      "title": "how to implement custom exception in python?",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "In Python, you can implement a custom exception by creating a new class that inherits from one of the existing exception classes provided by Python, such as `Exception`, `ValueError`, or `RuntimeError`. By creating a custom exception class, you can define your own exception type with specific attributes and behavior that suit your application's needs.\n\nHere's a step-by-step guide to implementing a custom exception in Python:\n\n1. Define a new class for your custom exception:\n   - You can choose to inherit from the base `Exception` class or any other relevant built-in exception class, depending on the nature of your custom exception.\n\n2. Optionally, add any additional attributes or methods to your custom exception class:\n   - You may want to include specific attributes or methods to provide additional information about the exception or customize its behavior.\n\n3. Raise your custom exception when needed:\n   - In your code, use the `raise` statement to raise an instance of your custom exception when a specific error condition occurs.\n\nHere's an example of how to implement a custom exception in Python:\n\n```python\n# Step 1: Define a new class for the custom exception\nclass MyCustomException(Exception):\n    def __init__(self, message=\"An error occurred.\"):\n        super().__init__(message)\n        self.additional_info = \"Additional information about the error.\"\n\n# Step 2: Optionally, add attributes or methods to the custom exception class\n\n# Step 3: Raise your custom exception when needed\ndef divide(a, b):\n    if b == 0:\n        raise MyCustomException(\"Division by zero is not allowed.\")\n    return a / b\n\ntry:\n    result = divide(10, 0)\nexcept MyCustomException as ex:\n    print(f\"Custom Exception caught: {ex}\")\n    print(ex.additional_info)\n```\n\nIn this example, we define a custom exception class `MyCustomException` that inherits from the base `Exception` class. The `MyCustomException` class has an optional `message` argument, which allows you to provide a custom error message when raising the exception.\n\nIn the `divide(a, b)` function, we check if the value of `b` is `0`. If it is, we raise an instance of the `MyCustomException` with a specific error message.\n\nWhen we call the `divide(10, 0)` function inside the `try` block, it raises the `MyCustomException`, and the code inside the corresponding `except` block will be executed. The `except` block catches the `MyCustomException` and prints the custom error message along with the additional information provided by the `additional_info` attribute.\n\nBy creating custom exceptions, you can make your error handling more informative and tailored to your application's requirements.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 2
    },
    {
      "subject": "py",
      "title": "how to handle exception in python? explain with raise",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "In Python, you can handle exceptions using the `try`, `except` block. The `try` block is used to wrap the code that may raise an exception, and the `except` block is used to catch and handle the exception if it occurs.\n\nHere's a simple explanation of how to handle exceptions using the `try` and `except` block, along with an example using the `raise` statement to raise a custom exception:\n\n```python\ntry:\n    # Code that may raise an exception\n    result = 10 / 0  # Division by zero to intentionally raise an exception\nexcept Exception as e:\n    # Exception handling code\n    print(f\"An error occurred: {e}\")\n```\n\nIn the above code example, we have a `try` block that contains a division operation `10 / 0`. Since dividing by zero is not allowed in Python and will raise a `ZeroDivisionError`, the code inside the `except` block will be executed.\n\nWhen an exception occurs inside the `try` block, the code execution will immediately jump to the corresponding `except` block. In this case, the `except` block will catch the `ZeroDivisionError` and print an error message indicating that an error occurred.\n\nYou can also use the `raise` statement to raise custom exceptions to indicate specific error conditions in your code. Here's an example of how to raise a custom exception:\n\n```python\ndef divide(a, b):\n    if b == 0:\n        raise ValueError(\"Division by zero is not allowed.\")\n    return a / b\n\ntry:\n    result = divide(10, 0)\nexcept ValueError as ve:\n    print(f\"An error occurred: {ve}\")\n```\n\nIn this example, we define a function `divide(a, b)` that takes two arguments and performs division. If the value of `b` is `0`, the function raises a `ValueError` with a custom error message.\n\nWhen we call the `divide(10, 0)` function inside the `try` block, it will raise a `ValueError`, and the code inside the corresponding `except` block will be executed. The `except` block will catch the `ValueError` and print the custom error message.\n\nUsing `try`, `except`, and `raise` allows you to gracefully handle exceptions and provide appropriate error messages or take specific actions based on the type of exception that occurred in your Python code.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 3
    },
    {
      "subject": "py",
      "title": "",
      "ques": "explain this code -\n[\n with pytest.raises(\n            Exception,\n            match=r'.*Content Source *'  \n            ):\n            self.exec_work()   \n]",
      "links": [],
      "tags": [],
      "ans": "The code you provided appears to be written in Python and uses the `pytest` library to write tests. Let's break down the code step by step:\n\n1. `pytest.raises(Exception, match=r'.*Content Source *'):`: This part of the code is using the `pytest.raises()` context manager. It is used to test that a specific exception is raised when a certain piece of code is executed. In this case, it is checking if an exception of type `Exception` is raised during the execution of the code block inside the context manager.\n\n2. `match=r'.*Content Source *'`: The `match` argument in `pytest.raises()` is used to specify a regular expression pattern. The test will pass if the exception message matches this regular expression pattern. In this case, the pattern is `' .*Content Source *'`, which means it will match any string that contains the substring \"Content Source\" with possible leading and trailing spaces.\n\n3. `self.exec_work()`: This line of code is calling the `exec_work()` method on the current object (usually a test class instance). It is the code that is being tested to see if it raises the expected exception.\n\nPutting it all together, the code snippet is essentially a test case using `pytest` to check if calling the `self.exec_work()` method raises an exception of type `Exception` with a message that contains the substring \"Content Source\". If the exception is raised with the expected message, the test case will pass; otherwise, it will fail.\n\nKeep in mind that this explanation assumes the presence of the appropriate imports and the definition of the `exec_work()` method elsewhere in the test code or the class being tested. Also, the actual behavior of the test case depends on the implementation details of the `exec_work()` method and how it may raise the `Exception` and its message.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 4
    },
    {
      "subject": "py",
      "title": "What is inbuilt exceptions in python?",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "In Python, there are several built-in exceptions (also known as standard exceptions) provided by the language to handle common error scenarios. These exceptions represent different types of errors that can occur during the execution of a Python program. When an exceptional situation occurs, Python will raise the corresponding built-in exception, which can be caught and handled using try-except blocks.\n\nHere are some of the commonly used built-in exceptions in Python:\n\n1. `ZeroDivisionError`: Raised when dividing by zero.\n\n2. `TypeError`: Raised when an operation or function is applied to an object of an inappropriate type.\n\n3. `ValueError`: Raised when a built-in operation or function receives an argument of the correct type but an inappropriate value.\n\n4. `IndexError`: Raised when a sequence subscript is out of range.\n\n5. `KeyError`: Raised when a dictionary key is not found.\n\n6. `NameError`: Raised when a local or global name is not found.\n\n7. `FileNotFoundError`: Raised when a file or directory is requested but cannot be found.\n\n8. `IOError`: Raised when an I/O operation (e.g., reading/writing a file) fails.\n\n9. `AssertionError`: Raised when an `assert` statement fails.\n\n10. `ImportError`: Raised when an import statement cannot find the specified module.\n\n11. `OverflowError`: Raised when the result of an arithmetic operation is too large to be expressed.\n\n12. `RuntimeError`: Raised when an error does not fall under any other category.\n\n13. `Exception`: The base class for all built-in exceptions. It is generally not recommended to catch this exception explicitly, as it can catch unintended errors.\n\nThese are just a few examples of the many built-in exceptions provided by Python. Each of these exceptions is designed to provide specific information about the error, making it easier to identify and handle exceptional cases in your code.\n\nHere's an example of how you can use try-except blocks to catch and handle a `ZeroDivisionError`:\n\n```python\ntry:\n    result = 10 / 0\nexcept ZeroDivisionError as e:\n    print(\"Error:\", e)\n    # Handle the exception here\n```\n\nIn this example, if the code inside the `try` block encounters a division by zero, it will raise a `ZeroDivisionError`. The `except` block will catch the exception and print an error message.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 5
    },
    {
      "subject": "py",
      "title": "what is the difference between staticmethod and classmethod decorator in python?",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "In Python, both `staticmethod` and `classmethod` are decorators used to define methods in classes. They are similar in that they allow you to define methods that are bound to the class rather than an instance of the class. However, they have different behaviors and use cases. Let's explore the differences between `staticmethod` and `classmethod`:\n\n**1. Static Method:**\n\n- A method decorated with `staticmethod` does not have access to the instance (`self`) or the class (`cls`) as its first argument. It behaves like a regular function within the class namespace, and it doesn't depend on any instance-specific or class-specific data.\n- Static methods are often used when a method is logically related to the class but doesn't depend on instance-specific or class-specific attributes.\n- They can be called directly on the class without creating an instance of the class.\n\n**Example of static method:**\n\n```python\nclass MyClass:\n    @staticmethod\n    def my_static_method(arg):\n        return arg * 2\n\n# Calling the static method directly on the class\nresult = MyClass.my_static_method(10)\nprint(result)  # Output: 20\n```\n\n**2. Class Method:**\n\n- A method decorated with `classmethod` has access to the class itself (`cls`) as its first argument. This allows the method to work with class-level attributes or perform actions related to the class as a whole.\n- Class methods are often used when you need to perform operations that involve the class itself and not specific instances of the class.\n- They can also be called directly on the class without creating an instance of the class.\n\n**Example of class method:**\n\n```python\nclass MyClass:\n    class_variable = 10\n\n    @classmethod\n    def my_class_method(cls):\n        return cls.class_variable\n\n# Calling the class method directly on the class\nresult = MyClass.my_class_method()\nprint(result)  # Output: 10\n```\n\n**Key Differences:**\n\n- `staticmethod`: Doesn't have access to `self` or `cls`. Behaves like a regular function within the class and doesn't depend on instance or class-specific data.\n- `classmethod`: Has access to `cls`, allowing it to work with class-level attributes. Useful for operations related to the class itself.\n\nBoth `staticmethod` and `classmethod` have their use cases, and choosing one over the other depends on whether you need access to the class (for class-level operations) or not (for instance-independent operations).",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 6
    },
    {
      "subject": "py",
      "title": "what is the use of property decorator in python?",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "In Python, the `property` decorator is a built-in function used to create \"getter,\" \"setter,\" and \"deleter\" methods for class attributes. It allows you to control how attribute values are accessed, modified, and deleted. The `property` decorator provides a way to implement computed attributes or enforce certain constraints on attribute values without changing the existing class interface.\n\n**The `property` decorator is used for the following purposes:**\n\n1. **Getter Method:**\n   - When you decorate a method with `@property`, it becomes a getter method for a specific attribute. This method is called whenever the attribute is accessed, allowing you to compute and return the attribute value dynamically.\n\n2. **Setter Method:**\n   - When you define a method with the same name as the getter method but use `@<getter_method>.setter`, it becomes a setter method for the attribute. It is called whenever an attempt is made to modify the attribute value.\n\n3. **Deleter Method:**\n   - When you define a method with the same name as the getter method but use `@<getter_method>.deleter`, it becomes a deleter method for the attribute. It is called whenever an attempt is made to delete the attribute.\n\n**Example of using the `property` decorator:**\n\n```python\nclass Circle:\n    def __init__(self, radius):\n        self._radius = radius\n\n    @property\n    def radius(self):\n        print(\"Getting radius\")\n        return self._radius\n\n    @radius.setter\n    def radius(self, value):\n        print(\"Setting radius\")\n        if value >= 0:\n            self._radius = value\n        else:\n            raise ValueError(\"Radius must be non-negative\")\n\n    @radius.deleter\n    def radius(self):\n        print(\"Deleting radius\")\n        del self._radius\n\n# Creating an instance of the Circle class\ncircle = Circle(5)\n\n# Accessing the radius attribute (calls the getter method)\nprint(circle.radius)  # Output: Getting radius \\n 5\n\n# Modifying the radius attribute (calls the setter method)\ncircle.radius = 10    # Output: Setting radius\n\n# Accessing the modified radius attribute\nprint(circle.radius)  # Output: Getting radius \\n 10\n\n# Attempting to set a negative radius (raises ValueError)\ncircle.radius = -5    # Output: Setting radius \\n Deleting radius \\n ValueError: Radius must be non-negative\n\n# Deleting the radius attribute (calls the deleter method)\ndel circle.radius     # Output: Deleting radius\n\n# Accessing the deleted radius attribute (raises AttributeError)\nprint(circle.radius)  # Output: AttributeError: 'Circle' object has no attribute '_radius'\n```\n\nIn the above example, the `radius` attribute of the `Circle` class is implemented using the `property` decorator. The `@property` decorator creates a getter method that computes and returns the attribute value. The `@radius.setter` decorator creates a setter method that checks if the new value is non-negative before modifying the attribute. The `@radius.deleter` decorator creates a deleter method that allows deleting the attribute. These methods provide control over how the `radius` attribute is accessed, modified, and deleted, allowing for validation and custom behavior.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 7
    },
    {
      "subject": "py",
      "title": "how to implement global variable in python?",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "In Python, you can implement a global variable by declaring it outside of any function or class, making it accessible throughout the entire module or script. This way, the variable will be available in all functions defined within that module.\n\nTo create a global variable, follow these steps:\n\n1. **Declare the Global Variable:**\n   - Place the variable outside of any function or class, at the top level of your script or module. This ensures that the variable has a global scope.\n\n2. **Access the Global Variable in Functions:**\n   - In any function where you want to use the global variable, you can directly access it without declaring it again. Python will recognize the variable as a global one, provided you don't assign a new value to it within the function.\n\nHere's an example to illustrate the implementation of a global variable:\n\n```python\n# Global variable declaration\nglobal_var = 10\n\ndef my_function():\n    # Access the global variable within the function\n    print(\"Inside my_function: global_var =\", global_var)\n\ndef another_function():\n    # Access the global variable within another function\n    print(\"Inside another_function: global_var =\", global_var)\n\n# Modify the global variable outside the functions\nglobal_var = 20\n\n# Call the functions to see the value of the global variable\nmy_function()         # Output: Inside my_function: global_var = 20\nanother_function()    # Output: Inside another_function: global_var = 20\n```\n\nIn this example, `global_var` is a global variable that is defined outside any function. Both `my_function()` and `another_function()` can access and use the value of `global_var` without any issues. When the value of `global_var` is changed to `20` outside the functions, it reflects in both function calls.\n\nKeep in mind that using global variables should be done with caution, as they can make the code harder to maintain and test. Whenever possible, prefer passing variables as function arguments and returning values from functions instead of relying heavily on global variables. This promotes better encapsulation and improves the overall structure of your code.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 8
    },
    {
      "subject": "py",
      "title": "how to Automatically Generate Swagger Docs in django, Explain each steps in details",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "To automatically generate Swagger documentation for a Django project, you can use the `drf-yasg` (Yet Another Swagger Generator) library. This library simplifies the process of creating and serving Swagger documentation for your Django Rest Framework (DRF) APIs. Here's a step-by-step guide to setting it up:\n\n1. **Install Dependencies**:\n   Open your project directory in the terminal and install the necessary package:\n\n   ```bash\n   pip install drf-yasg\n   ```\n\n2. **Configure Django Settings**:\n   Add `'drf_yasg'` to your `INSTALLED_APPS` in your Django project's `settings.py`:\n\n   ```python\n   INSTALLED_APPS = [\n       # ...\n       'drf_yasg',\n       # ...\n   ]\n   ```\n\n3. **Generate Swagger Docs**:\n   Create a `swagger` folder within one of your Django app directories. Inside this folder, create a file named `swagger.py`.\n\n4. **Configure Swagger Settings**:\n   In your `swagger.py` file, configure the Swagger settings and generate API documentation. Here's an example configuration:\n\n   ```python\n   from rest_framework import permissions\n   from drf_yasg.views import get_schema_view\n   from drf_yasg import openapi\n   from django.urls import path\n\n   schema_view = get_schema_view(\n       openapi.Info(\n           title=\"Your API\",\n           default_version='v1',\n           description=\"Your API Description\",\n           terms_of_service=\"https://www.example.com/terms/\",\n           contact=openapi.Contact(email=\"contact@example.com\"),\n           license=openapi.License(name=\"Your License\"),\n       ),\n       public=True,\n       permission_classes=(permissions.AllowAny,),\n   )\n\n   urlpatterns = [\n       path('swagger/', schema_view.with_ui('swagger', cache_timeout=0), name='schema-swagger-ui'),\n   ]\n   ```\n\n   Replace `\"Your API\"`, `\"v1\"`, `\"Your API Description\"`, and other placeholders with your actual API information.\n\n5. **URL Configuration**:\n   Make sure you've added the `swagger` app's URLs to your project's URL configuration. In your project's `urls.py`:\n\n   ```python\n   from django.contrib import admin\n   from django.urls import path, include\n\n   urlpatterns = [\n       path('admin/', admin.site.urls),\n       path('api/', include('your_app.urls')),  # Replace 'your_app' with your actual app name\n       path('', include('swagger.urls')),  # Include the swagger URLs\n   ]\n   ```\n\n6. **Run Your Django Server**:\n   Start your Django development server:\n\n   ```bash\n   python manage.py runserver\n   ```\n\n7. **Access Swagger Docs**:\n   Open a web browser and navigate to `http://localhost:8000/swagger/`. You should see the Swagger UI interface with automatically generated API documentation based on your Django Rest Framework views and serializers.\n\nBy following these steps, you can automatically generate Swagger documentation for your Django Rest Framework APIs using the `drf-yasg` library. This documentation provides an interactive interface for exploring and interacting with your API endpoints.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 9
    },
    {
      "subject": "py",
      "title": "how to use lamda in python?",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "In Python, `lambda` is used to create small, anonymous functions, also known as lambda functions or lambda expressions. These functions are often used for short, simple operations where defining a full function using `def` would be unnecessarily verbose. Lambda functions can take any number of arguments but can only have one expression.\n\nHere's the basic syntax of a lambda function:\n\n```python\nlambda arguments: expression\n```\n\nHere's an example of using a lambda function to create a simple function that adds two numbers:\n\n```python\nadd = lambda x, y: x + y\nresult = add(3, 5)\nprint(result)  # Output: 8\n```\n\nIn this example, `lambda x, y: x + y` defines a lambda function that takes two arguments `x` and `y` and returns their sum. The `add` variable is assigned this lambda function, and you can call it like a regular function, as shown in `add(3, 5)`.\n\nLambda functions are often used in situations where you need to pass a small function as an argument to another function, like `map()`, `filter()`, and `sorted()`:\n\n1. Using `map()` with a lambda function:\n\n```python\nnumbers = [1, 2, 3, 4, 5]\nsquared = list(map(lambda x: x ** 2, numbers))\nprint(squared)  # Output: [1, 4, 9, 16, 25]\n```\n\n2. Using `filter()` with a lambda function:\n\n```python\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]\neven_numbers = list(filter(lambda x: x % 2 == 0, numbers))\nprint(even_numbers)  # Output: [2, 4, 6, 8]\n```\n\n3. Using `sorted()` with a lambda function to sort a list of tuples by the second element:\n\n```python\ndata = [(1, 5), (3, 2), (2, 8), (4, 1)]\nsorted_data = sorted(data, key=lambda x: x[1])\nprint(sorted_data)  # Output: [(4, 1), (3, 2), (1, 5), (2, 8)]\n```\n\nLambda functions are concise and useful for simple operations, but for more complex functions, it's often better to use a regular `def` function for clarity and maintainability.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 10
    },
    {
      "subject": "py",
      "title": "How to print all keys of dict in python?",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "To print all the keys of a dictionary in Python, you can use one of the following methods:\n\n1. Using a `for` loop:\n\n```python\nmy_dict = {'a': 1, 'b': 2, 'c': 3}\n\nfor key in my_dict:\n    print(key)\n```\n\n2. Using the `keys()` method of the dictionary:\n\n```python\nmy_dict = {'a': 1, 'b': 2, 'c': 3}\n\nfor key in my_dict.keys():\n    print(key)\n```\n\n3. Using a list comprehension:\n\n```python\nmy_dict = {'a': 1, 'b': 2, 'c': 3}\n\nkeys = [key for key in my_dict]\nfor key in keys:\n    print(key)\n```\n\nAll of these methods will output:\n\n```\na\nb\nc\n```\n\nYou can choose the method that you find most readable or convenient for your specific use case.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 11
    },
    {
      "subject": "py",
      "title": "Unit test using pytest",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "Pytest is a popular testing framework in Python for writing and running unit tests. To use pytest for unit testing in Python, you need to set up your project and configure pytest initially, and then you can write and run your tests. Here are the steps involved, along with code examples:\n\n### Initial Configuration:\n\n1. **Install pytest:**\n\n   You need to install pytest first if you haven't already. You can do this using `pip`:\n\n   ```bash\n   pip install pytest\n   ```\n\n2. **Project Structure:**\n\n   Organize your project structure with your source code in one directory and your test code in another. A common convention is to create a `tests` directory within your project directory.\n\n   ```\n   my_project/\n   ├── my_module.py       # Your source code\n   └── tests/\n       ├── test_my_module.py  # Your test code\n   ```\n\n3. **Create a Test File:**\n\n   Inside the `tests` directory, create a Python file (e.g., `test_my_module.py`) to write your test cases.\n\n### Writing and Running Tests:\n\nNow, let's write and run some sample tests using pytest:\n\n1. **Write Test Functions:**\n\n   In your test file (e.g., `test_my_module.py`), define test functions using the `test_` prefix or use the `@pytest.mark` decorator to mark test functions.\n\n   ```python\n   # test_my_module.py\n\n   import my_module  # Import the module you want to test\n   import pytest\n\n   def test_addition():\n       assert my_module.add(2, 3) == 5\n\n   @pytest.mark.parametrize(\"input, expected\", [(1, 2), (2, 4), (3, 6)])\n   def test_multiply_by_two(input, expected):\n       assert my_module.multiply_by_two(input) == expected\n   ```\n\n2. **Run Tests:**\n\n   You can run pytest from the command line, specifying the directory where your tests are located. By default, pytest discovers and runs all test files that match the pattern `test_*.py` or `*_test.py`.\n\n   ```bash\n   pytest tests/\n   ```\n\n   Pytest will discover and run your test functions and provide a summary of the test results, including any failures or errors.\n\n3. **Assertions:**\n\n   Use Python's `assert` statements to check the correctness of your code. If an assertion fails, pytest will report it as a test failure.\n\n4. **Test Discovery:**\n\n   Pytest automatically discovers and runs your test functions, so you don't need to manually specify each test case. It follows naming conventions for test functions and test files.\n\n5. **Fixtures (Optional):**\n\n   Pytest provides a powerful fixture mechanism for setting up and tearing down test resources. You can define fixtures to be reused across multiple tests.\n\nHere's a simple example of a module and its corresponding test file:\n\n```python\n# my_module.py\n\ndef add(x, y):\n    return x + y\n\ndef multiply_by_two(x):\n    return x * 2\n```\n\n```python\n# test_my_module.py\n\nimport my_module\nimport pytest\n\ndef test_addition():\n    assert my_module.add(2, 3) == 5\n\n@pytest.mark.parametrize(\"input, expected\", [(1, 2), (2, 4), (3, 6)])\ndef test_multiply_by_two(input, expected):\n    assert my_module.multiply_by_two(input) == expected\n```\n\nRun the tests:\n\n```bash\npytest tests/\n```\n\nPytest will execute the tests and report the results. You can further explore pytest's features, such as fixtures, markers, and plugins, to enhance your testing capabilities.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 12
    }
  ],
  "java": [],
  "oth": [
    {
      "subject": "oth",
      "title": "what are standard mongodb queries used? explain with detailed code examples",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "MongoDB, being a NoSQL database, utilizes a different query language called MongoDB Query Language (MQL). Here are some commonly used MongoDB queries along with detailed code examples:\n\n1. Find Documents:\nThe `find()` method is used to retrieve documents from a MongoDB collection based on specified criteria. Here's an example:\n\n```javascript\ndb.collection_name.find({ key: value });\n```\n\nExample:\n```javascript\ndb.customers.find({ city: \"New York\" });\n```\n\n2. Insert Documents:\nThe `insertOne()` and `insertMany()` methods are used to insert one or multiple documents into a MongoDB collection. Here are the examples:\n\n```javascript\ndb.collection_name.insertOne({ document });\ndb.collection_name.insertMany([{ document1 }, { document2 }]);\n```\n\nExample:\n```javascript\ndb.customers.insertOne({ name: \"John Doe\", age: 30, city: \"London\" });\n```\n\n3. Update Documents:\nThe `updateOne()` and `updateMany()` methods are used to update existing documents in a MongoDB collection. Here's an example:\n\n```javascript\ndb.collection_name.updateOne({ filter }, { $set: { key: value } });\ndb.collection_name.updateMany({ filter }, { $set: { key: value } });\n```\n\nExample:\n```javascript\ndb.customers.updateOne({ name: \"John Doe\" }, { $set: { age: 31 } });\n```\n\n4. Delete Documents:\nThe `deleteOne()` and `deleteMany()` methods are used to remove documents from a MongoDB collection. Here's an example:\n\n```javascript\ndb.collection_name.deleteOne({ filter });\ndb.collection_name.deleteMany({ filter });\n```\n\nExample:\n```javascript\ndb.customers.deleteOne({ age: { $gt: 50 } });\n```\n\n5. Aggregation Pipeline:\nThe aggregation pipeline provides a powerful way to process and transform data in MongoDB. It allows you to perform multiple operations on the data, such as filtering, grouping, projecting, and aggregating. Here's an example:\n\n```javascript\ndb.collection_name.aggregate([\n  { $match: { key: value } },\n  { $group: { _id: \"$field\", total: { $sum: \"$value\" } } },\n]);\n```\n\nExample:\n```javascript\ndb.orders.aggregate([\n  { $match: { status: \"completed\" } },\n  { $group: { _id: \"$customer_id\", total: { $sum: \"$amount\" } } },\n]);\n```\n\n6. Indexing:\nIndexes in MongoDB improve query performance by facilitating faster data retrieval. Here's an example of creating an index:\n\n```javascript\ndb.collection_name.createIndex({ field: 1 });\n```\n\nExample:\n```javascript\ndb.customers.createIndex({ name: 1 });\n```\n\nThese are just a few examples of standard MongoDB queries. MongoDB's query language offers a rich set of operators and features that enable flexible and efficient data retrieval and manipulation. The specific queries you use will depend on your data model, application requirements, and the nature of the data you're working with.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 1
    },
    {
      "subject": "oth",
      "title": "what are standard sql queries used? explain with detailed code examples",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "There are several standard SQL queries that are commonly used for various data manipulation tasks. Here are some of the most frequently used SQL queries, along with detailed code examples:\n\n1. SELECT Statement:\nThe SELECT statement is used to retrieve data from a database table. It allows you to specify the columns you want to retrieve and apply filtering conditions. Here's an example:\n\n```sql\nSELECT column1, column2 FROM table_name WHERE condition;\n```\n\nExample:\n```sql\nSELECT name, age FROM customers WHERE city = 'New York';\n```\n\n2. INSERT Statement:\nThe INSERT statement is used to insert new records into a database table. It specifies the columns and the values to be inserted. Here's an example:\n\n```sql\nINSERT INTO table_name (column1, column2) VALUES (value1, value2);\n```\n\nExample:\n```sql\nINSERT INTO customers (name, age, city) VALUES ('John Doe', 30, 'London');\n```\n\n3. UPDATE Statement:\nThe UPDATE statement is used to modify existing records in a database table. It sets new values for specified columns based on given conditions. Here's an example:\n\n```sql\nUPDATE table_name SET column1 = value1, column2 = value2 WHERE condition;\n```\n\nExample:\n```sql\nUPDATE customers SET age = 31 WHERE name = 'John Doe';\n```\n\n4. DELETE Statement:\nThe DELETE statement is used to remove records from a database table based on specified conditions. Here's an example:\n\n```sql\nDELETE FROM table_name WHERE condition;\n```\n\nExample:\n```sql\nDELETE FROM customers WHERE age > 50;\n```\n\n5. JOIN Statement:\nThe JOIN statement is used to combine rows from multiple tables based on related columns. It allows you to retrieve data from multiple tables in a single query. Here's an example:\n\n```sql\nSELECT columns FROM table1 JOIN table2 ON table1.column = table2.column;\n```\n\nExample:\n```sql\nSELECT customers.name, orders.order_number FROM customers JOIN orders ON customers.id = orders.customer_id;\n```\n\n6. GROUP BY Statement:\nThe GROUP BY statement is used to group rows based on one or more columns. It is typically used in conjunction with aggregate functions like SUM, AVG, COUNT, etc. Here's an example:\n\n```sql\nSELECT column1, aggregate_function(column2) FROM table_name GROUP BY column1;\n```\n\nExample:\n```sql\nSELECT city, COUNT(*) FROM customers GROUP BY city;\n```\n\nThese are just a few examples of standard SQL queries. SQL provides a wide range of functionalities to query, manipulate, and analyze data stored in relational databases. The specific queries you use will depend on the requirements of your application and the data you need to work with.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 2
    },
    {
      "subject": "oth",
      "title": "how to implement k8s create cluster using ansible? explain in details using example",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "To implement the creation of a Kubernetes cluster using Ansible, you can leverage the Ansible playbooks and modules to automate the provisioning and configuration of the necessary resources. Here's a step-by-step guide with an example:\n\nStep 1: Install Ansible\nEnsure that Ansible is installed on your control machine. You can install Ansible using package managers like apt or yum, or use pip for Python-based installation. Refer to the Ansible documentation for detailed installation instructions.\n\nStep 2: Set up Ansible Inventory\nCreate an inventory file to define the target hosts for your Kubernetes cluster. This file specifies the IP addresses or hostnames of the machines you'll use as master and worker nodes. For example, create a file called `inventory.ini` with the following content:\n\n```plaintext\n[masters]\nmaster.example.com\n\n[workers]\nworker1.example.com\nworker2.example.com\n```\n\nReplace `master.example.com`, `worker1.example.com`, and `worker2.example.com` with the actual IP addresses or hostnames of your machines.\n\nStep 3: Create an Ansible Playbook\nCreate an Ansible playbook that defines the tasks to provision and configure your Kubernetes cluster. For simplicity, let's assume you're using kubeadm to set up the cluster. Create a file called `create_cluster.yaml` with the following content:\n\n```yaml\n- hosts: masters\n  become: true\n  tasks:\n    - name: Initialize Kubernetes cluster\n      command: kubeadm init --pod-network-cidr=10.244.0.0/16\n\n    - name: Copy kubeconfig to user's .kube directory\n      become_user: \"{{ ansible_user }}\"\n      command: |\n        mkdir -p $HOME/.kube\n        sudo cp /etc/kubernetes/admin.conf $HOME/.kube/config\n        sudo chown -R $HOME/.kube\n\n    - name: Install Flannel network plugin\n      become_user: \"{{ ansible_user }}\"\n      command: |\n        kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml\n\n    - name: Generate and display join command for workers\n      command: kubeadm token create --print-join-command\n      register: join_command\n      changed_when: false\n\n    - debug:\n        var: join_command.stdout_lines[0]\n\n- hosts: workers\n  become: true\n  tasks:\n    - name: Join the Kubernetes cluster\n      shell: \"{{ hostvars['masters'][ansible_default_ipv4.address] }}:6443\"\n      when: \"'kubeadm join' in join_command.stdout_lines[0]\"\n```\n\nThis playbook consists of two plays. The first play runs on the master node, initializes the Kubernetes cluster using `kubeadm`, installs the Flannel network plugin, and generates the join command for the worker nodes. The second play runs on the worker nodes and joins them to the cluster.\n\nStep 4: Run the Ansible Playbook\nRun the Ansible playbook using the following command:\n\n```bash\nansible-playbook -i inventory.ini create_cluster.yaml\n```\n\nAnsible will connect to the target hosts defined in the inventory file and execute the tasks specified in the playbook.\n\nOnce the playbook execution completes, you should have a Kubernetes cluster with the master node and worker nodes joined to it. You can verify the cluster status using the `kubectl get nodes` command on the master node.\n\nNote: This example assumes that you have already set up the necessary prerequisites on the target hosts, such as installing Docker and configuring network settings. Additionally, you may need to customize the playbook to match your specific requirements, such as using different network plugins or customizing the cluster initialization options.\n\nBy using Ansible, you can automate\n\nthe process of creating a Kubernetes cluster, making it repeatable and scalable. Ansible allows you to define and manage infrastructure as code, simplifying the deployment and management of complex environments.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 3
    },
    {
      "subject": "oth",
      "title": "what helm chart, explain with proper code example",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "Helm is a package manager for Kubernetes that helps you manage and deploy applications on a cluster. A Helm chart is a collection of files that describes a set of Kubernetes resources and their configurations. It provides a convenient way to package, version, and deploy applications on Kubernetes. Here's an example of a Helm chart for a simple Nginx web server deployment:\n\nStep 1: Install Helm\nBefore you can create a Helm chart, you need to install Helm on your local machine. Refer to the official Helm documentation for installation instructions specific to your operating system.\n\nStep 2: Create a Helm Chart\nCreate a new directory for your Helm chart and navigate into it. Run the following command to create a new Helm chart named \"my-nginx\":\n\n```bash\nhelm create my-nginx\n```\n\nThis command generates the basic structure and files for your Helm chart.\n\nStep 3: Customize the Chart\nNavigate into the `my-nginx` directory and modify the files to customize the Helm chart for your application.\n\n- Update `values.yaml` to specify configurable values such as image repository, tag, and port.\n- Modify `templates/deployment.yaml` to define your deployment. Here's an example:\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: {{ include \"my-nginx.fullname\" . }}\n  labels:\n    app: {{ include \"my-nginx.name\" . }}\nspec:\n  replicas: {{ .Values.replicaCount }}\n  selector:\n    matchLabels:\n      app: {{ include \"my-nginx.name\" . }}\n  template:\n    metadata:\n      labels:\n        app: {{ include \"my-nginx.name\" . }}\n    spec:\n      containers:\n        - name: {{ .Chart.Name }}\n          image: \"{{ .Values.image.repository }}:{{ .Values.image.tag }}\"\n          ports:\n            - containerPort: {{ .Values.service.port }}\n```\n\nStep 4: Deploy the Chart\nTo deploy the Helm chart to your Kubernetes cluster, run the following command:\n\n```bash\nhelm install my-nginx ./my-nginx\n```\n\nThis command deploys the chart with the release name \"my-nginx\". You can choose any name you prefer.\n\nStep 5: Verify the Deployment\nCheck if the deployment was successful by running the following commands:\n\n```bash\nkubectl get deployments\nkubectl get pods\n```\n\nYou should see the Nginx deployment and the associated pods running.\n\nStep 6: Upgrade or Uninstall the Chart\nTo upgrade the deployed chart to a new version, use the following command:\n\n```bash\nhelm upgrade my-nginx ./my-nginx\n```\n\nTo uninstall the chart and delete all associated resources, use the following command:\n\n```bash\nhelm uninstall my-nginx\n```\n\nBy creating and using Helm charts, you can easily package and deploy complex applications with all their required resources and configurations in a consistent and repeatable manner. Helm simplifies the management of Kubernetes deployments and enables version control and easy sharing of application configurations.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 4
    },
    {
      "subject": "oth",
      "title": "How to create a cluster K8s, explain in details with code example",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "Creating a Kubernetes (K8s) cluster involves several steps, including setting up the necessary infrastructure, configuring the cluster, and deploying worker nodes. Here's a detailed guide on creating a Kubernetes cluster with code examples:\n\nStep 1: Choose a Cloud Provider or Set up Bare Metal Servers\nYou can create a Kubernetes cluster on a cloud provider like AWS, GCP, Azure, or set up your own infrastructure using bare metal servers. For this example, let's assume you're using a cloud provider.\n\nStep 2: Install and Set up Kubernetes CLI (kubectl)\nInstall the Kubernetes command-line tool (kubectl) on your local machine. The exact steps may vary based on your operating system. Refer to the official Kubernetes documentation for installation instructions.\n\nStep 3: Provision Master Node\nCreate the master node, which will control the cluster. This step depends on your cloud provider. For example, on AWS, you can use Elastic Kubernetes Service (EKS), on GCP, you can use Google Kubernetes Engine (GKE), and so on.\n\nStep 4: Configure kubectl to Connect to the Cluster\nAfter setting up the master node, configure your local kubectl to connect to the cluster. Run the following command:\n\n```bash\ngcloud container clusters get-credentials <cluster-name> --region <region> --project <project-id>\n```\n\nReplace `<cluster-name>`, `<region>`, and `<project-id>` with the appropriate values for your cluster.\n\nStep 5: Provision Worker Nodes\nCreate worker nodes that will run your applications. Again, the process varies depending on the cloud provider. You typically use the provider's tools or APIs to create worker nodes and join them to the cluster.\n\nStep 6: Verify Cluster Connectivity\nEnsure that the master and worker nodes are connected correctly. Run the following command to view the nodes:\n\n```bash\nkubectl get nodes\n```\n\nYou should see a list of nodes in your cluster, including the master and worker nodes.\n\nStep 7: Deploy Applications to the Cluster\nOnce your cluster is up and running, you can start deploying applications. Here's an example of deploying a sample application using a Kubernetes deployment:\n\nCreate a file called `sample-deployment.yaml` and add the following content:\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: sample-app\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: sample-app\n  template:\n    metadata:\n      labels:\n        app: sample-app\n    spec:\n      containers:\n      - name: sample-app\n        image: your-docker-image:tag\n        ports:\n        - containerPort: 80\n```\n\nReplace `your-docker-image:tag` with the Docker image and tag you want to deploy.\n\nTo create the deployment, run the following command:\n\n```bash\nkubectl apply -f sample-deployment.yaml\n```\n\nKubernetes will create three replicas of your sample application.\n\nStep 8: Verify Application Deployment\nCheck if the application deployment was successful. Run the following command:\n\n```bash\nkubectl get deployments\n```\n\nYou should see the `sample-app` deployment with the desired number of replicas.\n\nStep 9: Expose the Application\nTo access your application externally, you need to expose it using a Kubernetes service. Create a file called `sample-service.yaml` and add the following content:\n\n```yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: sample-service\nspec:\n  selector:\n    app: sample-app\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 80\n  type: LoadBalancer\n```\n\nTo create the service, run the following command:\n\n```bash\nkubectl apply -f sample",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 5
    },
    {
      "subject": "oth",
      "title": "what is graphql?",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "GraphQL is an open-source query language and runtime for APIs (Application Programming Interfaces) developed by Facebook. It provides a flexible and efficient approach to data fetching and manipulation, allowing clients to request specific data from a server rather than relying on predetermined structures.\n\nWith GraphQL, clients can send requests to a GraphQL server specifying the exact data they need, and the server responds with the requested data in a predictable and hierarchical JSON-like format. This eliminates the problem of over-fetching or under-fetching data that is commonly encountered with traditional RESTful APIs.\n\nOne of the key features of GraphQL is its ability to retrieve multiple related data points in a single request, reducing the number of round trips between the client and server. Clients have the power to define the shape and structure of the response they receive, enabling them to efficiently gather all the necessary data for their specific use case.\n\nAdditionally, GraphQL enables introspection, allowing clients to query the schema of the API to discover available types, fields, and relationships. This self-documentation feature makes it easier for developers to understand and interact with the API.\n\nGraphQL has gained popularity due to its flexibility, performance, and developer-friendly nature. It is widely used by many companies and has extensive support in various programming languages and frameworks.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 6
    },
    {
      "subject": "oth",
      "title": "why write unit-test, explain with real life example",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "Writing unit tests is crucial in software development for several reasons. Let's explore a real-life example to understand the importance of unit tests.\n\nImagine you're building a banking application that allows users to transfer funds between accounts. One of the critical functions of this application is the transfer funds operation. Without proper unit testing, bugs in this function can go undetected, resulting in serious financial consequences for users.\n\nHere's why unit tests are essential in this scenario:\n\n1. Early Bug Detection: Unit tests allow you to catch bugs early in the development process. By writing tests for the transfer funds function, you can ensure that it performs as expected under various scenarios, such as sufficient balance, invalid account numbers, or network failures. Identifying and fixing issues during development is more efficient and cost-effective than discovering them in a production environment.\n\n2. Code Refactoring and Maintenance: Unit tests act as a safety net when you need to refactor or modify your codebase. They provide confidence that your changes haven't introduced unintended side effects. For example, if you decide to optimize the transfer funds function, unit tests will help ensure that the logic remains intact and the behavior doesn't change inadvertently.\n\n3. Collaboration and Code Quality: Unit tests promote collaboration among developers. When multiple developers work on a project, having a comprehensive suite of tests ensures that everyone can make changes confidently without breaking existing functionality. Additionally, writing tests encourages writing modular and testable code, leading to better overall code quality.\n\n4. Regression Prevention: Unit tests help prevent regressions. Whenever you make changes to the transfer funds function or any related code, you can rerun the unit tests to ensure that all existing functionality remains intact. This prevents unintended regressions that could occur due to new code conflicting with existing code.\n\n5. Documentation and Understanding: Unit tests serve as documentation for your codebase. Well-written tests provide insights into how the code is intended to be used and can act as a reference point for future development or debugging. They also help new team members understand the codebase and its expected behavior.\n\nBy writing thorough unit tests for the transfer funds function and other critical parts of the banking application, you can confidently deliver a robust and reliable product. Testing not only ensures the correctness of your code but also improves collaboration, code quality, and maintainability throughout the software development lifecycle.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 7
    }
  ],
  "node": [
    {
      "subject": "node",
      "title": "Express API references",
      "ques": "",
      "links": [
        {
          "name": "https://expressjs.com/en/4x/api.html"
        }
      ],
      "tags": [
        {
          "name": "express"
        }
      ],
      "ans": "var express = require(\"express\");\nvar app = express();\nvar bodyParser = require(\"body-parser\");\nvar mongoose = require(\"mongoose\");\nvar router = express.Router();\nvar userSchema = mongoose.Schema({\n  name: String,\n});\nvar User = mongoose.model(\"User\", userSchema);\n\nvar albumSchema = mongoose.Schema({\n  performer: String,\n  title: String,\n  cost: Number,\n});\nvar Album = mongoose.model(\"Album\", albumSchema);\n\nvar puchaseSchema = mongoose.Schema({\n  user: { type: mongoose.Schema.Types.ObjectId, ref: \"User\" },\n  album: { type: mongoose.Schema.Types.ObjectId, ref: \"Album\" },\n});\nvar Purchase = mongoose.model(\"Purchase\", puchaseSchema);\n\napp.use(bodyParser.json());\napp.listen(3000);\n\n// TODO: GET /albums\napp.get(\"/albums\", (req, res) => {\n  Album.find((err, albs) => {\n    if (err) {\n      return err;\n    }\n    res.json(200, { data: albs });\n  });\n});\n\n// TODO: GET /albums/:id\napp.get(\"/albums/:id\", (req, res) => {\n  let id = req.params.id;\n  Album.findById(id, (err, albs) => {\n    if (err) {\n      return err;\n    }\n    res.json(200, { data: albs });\n  });\n});\n\n// TODO: POST /albums\napp.post(\"/albums\", (request, response) => {\n  let payload = request.body;\n  let album = new Album(payload);\n  album.save((err, alb) => {\n    if (err) {\n      return err;\n    }\n    response.json(200, { data: alb });\n  });\n});\n\n// TODO: PUT /albums/:id\napp.put(\"/albums/:id\", (request, response) => {\n  let id = request.params.id;\n  let payload = request.body;\n\n  Album.findOneAndUpdate({ _id: id }, payload, { new: true }, (err, alb) => {\n    if (err) {\n      return err;\n    }\n    response.json(200, { data: alb });\n  });\n});\n\n// TODO: DELETE /albums/:id\napp.delete(\"/albums/:id\", (req, res) => {\n  let id = req.params.id;\n  Album.remove({ _id: id }, (err, albs) => {\n    if (err) {\n      return err;\n    }\n    res.sendStatus(204);\n  });\n});\n\n// TODO: POST /purchases\napp.post(\"/purchases\", (request, response) => {\n  let payload = request.body;\n  let purchase = new Purchase(payload);\n  purchase.save((err, pur) => {\n    if (err) {\n      return err;\n    }\n\n    Purchase.findOne({ _id: pur._id })\n      .populate(\"user\")\n      .populate(\"album\")\n      .exec((err, data) => {\n        if (err) {\n          return err;\n        }\n        response.json(200, { data: data });\n      });\n  });\n});\n\napp.use(\"/\", router);",
      "diff": 1,
      "imp": 1,
      "cate": [
        "framework"
      ],
      "id": 1
    },
    {
      "subject": "node",
      "title": "Node.js buffer: A complete guide",
      "ques": "",
      "links": [
        {
          "name": "https://www.w3schools.com/nodejs/ref_buffer.asp"
        },
        {
          "name": "https://blog.logrocket.com/node-js-buffer-complete-guide/"
        }
      ],
      "tags": [
        {
          "name": "buffer"
        }
      ],
      "ans": "In Node.js, the Buffer module is used to handle binary data and perform operations on raw binary data. It provides a way to work with data streams, file system operations, network communications, and other I/O operations that involve handling binary data.\n\nHere's why and how you can use the Buffer module in Node.js:\n\n1. Binary Data Handling: The Buffer module allows you to create and manipulate binary data, such as reading from or writing to binary files, working with network protocols, or interacting with binary data formats. It provides methods for encoding and decoding data in various formats, such as UTF-8, ASCII, Base64, and more.\n\n2. Buffer Creation: You can create a Buffer object using various methods provided by the Buffer module. For example, you can create a new Buffer from a string, an array of bytes, or by specifying the size of the buffer. Once created, you can read from and write to the buffer using its methods.\n\n   ```javascript\n   // Creating a new Buffer\n   const buffer = Buffer.from('Hello, World!', 'utf8');\n\n   // Reading from the buffer\n   console.log(buffer.toString('utf8')); // Output: Hello, World!\n\n   // Writing to the buffer\n   buffer.write('Node.js');\n   console.log(buffer.toString('utf8')); // Output: Node.js, World!\n   ```\n\n3. Buffer Manipulation: The Buffer module provides methods for manipulating buffer data, such as copying, slicing, concatenating, and comparing buffers. These methods allow you to extract specific portions of the buffer, combine multiple buffers, or perform comparisons and equality checks.\n\n4. Efficient Data Transfer: Buffer objects are used extensively for efficient data transfer between different parts of a Node.js application. For example, when handling network communication or file system operations, data is often read or written in chunks using buffers to minimize memory overhead and improve performance.\n\n   ```javascript\n   // Reading a file into a buffer\n   const fs = require('fs');\n   const buffer = Buffer.alloc(1024); // Create a buffer of size 1024 bytes\n\n   fs.open('file.txt', 'r', (err, fd) => {\n     fs.read(fd, buffer, 0, buffer.length, 0, (err, bytesRead, buffer) => {\n       console.log(buffer.toString('utf8', 0, bytesRead));\n       fs.close(fd, (err) => {\n         // Handle close operation\n       });\n     });\n   });\n   ```\n\nThe Buffer module is particularly useful when dealing with binary data, such as reading or writing files, working with network protocols, handling streams, or performing low-level I/O operations. It provides a way to efficiently handle binary data, manipulate buffers, and convert between different data formats.\n\nIt's important to note that the Buffer module has undergone changes and improvements over different versions of Node.js. In recent versions (starting from Node.js 6.0.0), the Buffer constructor is deprecated, and the recommended way to create buffers is using the `Buffer.from()`, `Buffer.alloc()`, or `Buffer.allocUnsafe()` methods. Be sure to refer to the official Node.js documentation for the version you're using to ensure you're following the recommended practices.",
      "diff": 1,
      "imp": 1,
      "cate": [
        "node_core"
      ],
      "id": 2
    },
    {
      "subject": "node",
      "title": "Node.js child process",
      "ques": "",
      "links": [
        {
          "name": "https://medium.com/@diego.coder/child-processes-in-node-js-37429fb54670"
        },
        {
          "name": "https://blog.logrocket.com/node-js-child-process-launch-external-programs/"
        },
        {
          "name": "https://www.freecodecamp.org/news/node-js-child-processes-everything-you-need-to-know-e69498fe970a/"
        }
      ],
      "tags": [
        {
          "name": "child Process"
        }
      ],
      "ans": "Node.js provides several ways to use child processes, allowing you to spawn and communicate with external processes from your Node.js applications. Here are the different ways to use child processes in Node.js:\n\n1. `child_process.spawn()`: This method is used to spawn a new process and provides a straightforward way to execute a command in a separate process. It returns a `ChildProcess` object that allows you to communicate with the spawned process through its `stdin`, `stdout`, and `stderr` streams.\n\n   ```javascript\n   const { spawn } = require('child_process');\n\n   const child = spawn('ls', ['-l']); // Spawning the 'ls -l' command\n\n   child.stdout.on('data', (data) => {\n     console.log(`Output: ${data}`);\n   });\n\n   child.stderr.on('data', (data) => {\n     console.error(`Error: ${data}`);\n   });\n\n   child.on('close', (code) => {\n     console.log(`Child process exited with code ${code}`);\n   });\n   ```\n\n2. `child_process.exec()`: This method is similar to `child_process.spawn()`, but it uses a shell to execute the command. It allows you to execute shell commands, and it buffers the command's output in memory. It also provides a callback to handle the command's output and errors.\n\n   ```javascript\n   const { exec } = require('child_process');\n\n   exec('ls -l', (error, stdout, stderr) => {\n     if (error) {\n       console.error(`Error: ${error.message}`);\n       return;\n     }\n     if (stderr) {\n       console.error(`Error: ${stderr}`);\n       return;\n     }\n     console.log(`Output: ${stdout}`);\n   });\n   ```\n\n3. `child_process.execFile()`: This method is similar to `child_process.exec()`, but it executes a file instead of a shell command. It is useful when you want to run an executable file directly.\n\n   ```javascript\n   const { execFile } = require('child_process');\n\n   execFile('myScript.sh', (error, stdout, stderr) => {\n     if (error) {\n       console.error(`Error: ${error.message}`);\n       return;\n     }\n     if (stderr) {\n       console.error(`Error: ${stderr}`);\n       return;\n     }\n     console.log(`Output: ${stdout}`);\n   });\n   ```\n\n4. `child_process.fork()`: This method is specifically designed for creating child processes that run Node.js modules. It allows you to communicate between the parent and child processes using inter-process communication (IPC). The child process can send messages to the parent process, and vice versa.\n\n   Parent process:\n   ```javascript\n   const { fork } = require('child_process');\n   const child = fork('child.js');\n\n   child.on('message', (message) => {\n     console.log(`Received message from child: ${message}`);\n   });\n\n   child.send('Hello from parent');\n   ```\n\n   Child process (`child.js`):\n   ```javascript\n   process.on('message', (message) => {\n     console.log(`Received message from parent: ${message}`);\n   });\n\n   process.send('Hello from child');\n   ```\n\nThese are the main ways to use child processes in Node.js. Depending on your use case, you can choose the most suitable method to spawn and communicate with child processes effectively.",
      "diff": 1,
      "imp": 1,
      "cate": [
        "node_core"
      ],
      "id": 3
    },
    {
      "subject": "node",
      "title": "Asyncjs",
      "ques": "",
      "links": [
        {
          "name": "http://caolan.github.io/async/v3/"
        }
      ],
      "tags": [],
      "ans": "In Node.js, the `async` module is a powerful utility library that provides various functions for handling asynchronous operations. It simplifies working with callbacks, promises, and control flow, making asynchronous code more readable and maintainable. Here are some of the commonly used methods available in the `async` module, along with code examples:\n\n1. `async.series(tasks, callback)`: Runs an array of functions in series, each passing their results to the next function in the array. The final callback is called with the results of the last function.\n\n   ```javascript\n   const async = require('async');\n\n   async.series([\n     (callback) => {\n       setTimeout(() => {\n         console.log('Task 1');\n         callback(null, 'Result 1');\n       }, 2000);\n     },\n     (callback) => {\n       setTimeout(() => {\n         console.log('Task 2');\n         callback(null, 'Result 2');\n       }, 1000);\n     },\n     (callback) => {\n       setTimeout(() => {\n         console.log('Task 3');\n         callback(null, 'Result 3');\n       }, 1500);\n     }\n   ], (err, results) => {\n     console.log('Final callback:', results);\n   });\n   ```\n\n2. `async.parallel(tasks, callback)`: Runs an array of functions in parallel, and calls the callback with the results after all the functions have completed or encountered an error.\n\n   ```javascript\n   const async = require('async');\n\n   async.parallel([\n     (callback) => {\n       setTimeout(() => {\n         console.log('Task 1');\n         callback(null, 'Result 1');\n       }, 2000);\n     },\n     (callback) => {\n       setTimeout(() => {\n         console.log('Task 2');\n         callback(null, 'Result 2');\n       }, 1000);\n     },\n     (callback) => {\n       setTimeout(() => {\n         console.log('Task 3');\n         callback(null, 'Result 3');\n       }, 1500);\n     }\n   ], (err, results) => {\n     console.log('Final callback:', results);\n   });\n   ```\n\n3. `async.waterfall(tasks, callback)`: Runs an array of functions in a waterfall manner, passing the result of each function as an argument to the next function. The final callback receives the result of the last function.\n\n   ```javascript\n   const async = require('async');\n\n   async.waterfall([\n     (callback) => {\n       setTimeout(() => {\n         console.log('Task 1');\n         callback(null, 'Result 1', 'Result 2');\n       }, 2000);\n     },\n     (arg1, arg2, callback) => {\n       setTimeout(() => {\n         console.log('Task 2', arg1, arg2);\n         callback(null, 'Result 3');\n       }, 1000);\n     },\n     (arg3, callback) => {\n       setTimeout(() => {\n         console.log('Task 3', arg3);\n         callback(null, 'Final Result');\n       }, 1500);\n     }\n   ], (err, result) => {\n     console.log('Final callback:', result);\n   });\n   ```\n\n4. `async.each(collection, iterator, callback)`: Applies an asynchronous function to each item in a collection in parallel.\n\n   ```javascript\n   const async = require('async');\n\n   const items = ['item1', 'item2', 'item3'];\n\n   async.each(items, (item, callback) => {\n     console.log('Processing:', item);\n     setTimeout(() => {\n       callback();\n     }, 1000);\n   }, (err) => {\n     if (err) {\n       console.error('Error:', err);\n     } else {\n",
      "diff": 1,
      "imp": 1,
      "cate": [
        "library"
      ],
      "id": 4
    },
    {
      "subject": "node",
      "title": "Create folder and write json",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "const fs = require('fs');\nconst path = require('path');\n\nfunction createFolderIfNotExists(folderPath) {\n  if (!fs.existsSync(folderPath)) {\n    fs.mkdirSync(folderPath);\n    console.log(`Folder created at ${folderPath}`);\n  } else {\n    console.log(`Folder already exists at ${folderPath}`);\n  }\n}\n\nfs.mkdir(\"/Users/vijaykumar/Apps/nodePrac/socket/VJ/test1/test2\", {recursive: true} ,(err, result) => {\n    if(err){\n        console.error(err)\n    } else{\n        console.log(\"*** result ::\", result)\n    }\n})\n\n// Example usage\nconst folderPath = path.join(__dirname, 'myFolder');\n\ncreateFolderIfNotExists(folderPath);\n\n\nconst fs = require('fs');\n\nconst data = {\n  name: 'John Doe',\n  age: 30,\n  email: 'johndoe@example.com'\n};\n\nconst jsonData = JSON.stringify(data, null, 2);\n\nfs.writeFile('data.json', jsonData, 'utf8', (err) => {\n  if (err) {\n    console.error('Error writing JSON file:', err);\n    return;\n  }\n  console.log('JSON file has been written successfully.');\n});",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 5
    },
    {
      "subject": "node",
      "title": "What is event-driven programming in Node.js?",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "Event-driven programming is a programming paradigm that focuses on the flow of a program being driven by events. In an event-driven model, the program responds to events or signals that occur during its execution. These events can be triggered by user actions, system notifications, or other sources.\n\nIn the context of Node.js, event-driven programming is fundamental to its architecture. Node.js is built on an event-driven, non-blocking I/O model, which means that the execution flow is driven by events rather than being strictly sequential. This allows Node.js to handle large numbers of concurrent connections efficiently.\n\nNode.js uses the EventEmitter module to facilitate event-driven programming. The EventEmitter provides an implementation of the observer pattern, allowing objects (known as \"emitters\") to emit named events and register listeners (also known as \"event handlers\") to respond to those events.\n\nHere's a basic example to illustrate event-driven programming in Node.js:\n\n```javascript\nconst EventEmitter = require('events');\n\n// Create an instance of EventEmitter\nconst myEmitter = new EventEmitter();\n\n// Register an event listener for the 'myEvent' event\nmyEmitter.on('myEvent', (data) => {\n  console.log('Event occurred:', data);\n});\n\n// Emit the 'myEvent' event\nmyEmitter.emit('myEvent', 'Hello, World!');\n```\n\nIn this example, we create an instance of the EventEmitter class, `myEmitter`. We register an event listener using the `on()` method to listen for the 'myEvent' event. When the event is emitted using `emit()`, the listener function is invoked and the specified data is logged to the console.\n\nEvent-driven programming in Node.js allows you to build applications that are highly responsive, scalable, and efficient, particularly for scenarios involving I/O operations, networking, and real-time communication. By leveraging event-driven architecture, Node.js maximizes resource utilization and enables non-blocking, asynchronous handling of multiple operations concurrently.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 6
    },
    {
      "subject": "node",
      "title": "top nodejs interview questions with answer",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "Here are some commonly asked Node.js interview questions along with their answers:\n\n1. What is Node.js?\n   Answer: Node.js is an open-source, server-side JavaScript runtime environment built on Chrome's V8 JavaScript engine. It allows developers to run JavaScript code on the server, enabling them to build scalable and high-performance web applications.\n\n2. What is the difference between Node.js and JavaScript?\n   Answer: Node.js is a runtime environment that allows the execution of JavaScript code outside the browser, typically on a server. JavaScript, on the other hand, is a programming language used for creating interactive elements within web browsers.\n\n3. What is the role of package.json in Node.js?\n   Answer: package.json is a metadata file in Node.js projects that contains information about the project, its dependencies, and other configurations. It helps manage dependencies, scripts, project metadata, and versioning.\n\n4. What is npm?\n   Answer: npm (Node Package Manager) is the default package manager for Node.js. It allows developers to discover, install, and manage third-party packages and libraries in their Node.js projects.\n\n5. What is Express.js?\n   Answer: Express.js is a popular web application framework for Node.js. It provides a set of robust features and middleware to simplify the development of web applications and APIs.\n\n6. What is callback hell? How can it be avoided?\n   Answer: Callback hell refers to the situation where multiple asynchronous operations are nested inside each other, resulting in code that is difficult to read and maintain. It can be avoided by using techniques such as Promises, async/await, or using control flow libraries like async.js.\n\n7. What is middleware in Express.js?\n   Answer: Middleware in Express.js are functions that have access to the request and response objects. They can perform operations on the request or response, modify data, and pass control to the next middleware function in the stack. Middleware can be used for tasks such as logging, authentication, error handling, and more.\n\n8. What is event-driven programming in Node.js?\n   Answer: Event-driven programming is a programming paradigm where the flow of the program is determined by events. In Node.js, the core APIs and modules are built around event-driven architecture, utilizing event emitters and listeners to handle asynchronous operations effectively.\n\n9. How can you handle errors in Node.js?\n   Answer: In Node.js, errors can be handled using try-catch blocks for synchronous code. For asynchronous operations, error handling can be done using callback functions, Promises, or async/await with try-catch blocks. Express.js provides middleware for error handling using the `app.use()` method.\n\n10. What is the purpose of the `require()` function in Node.js?\n    Answer: The `require()` function is used in Node.js to import and use external modules or files. It allows you to include functionality from other modules into your application by providing the path or module name to import.\n\nThese are just a few examples of Node.js interview questions. It's important to note that interview questions can vary based on the specific role, company, and level of expertise being evaluated. It's always a good practice to study and prepare for the specific requirements of the position you are interviewing for.\n\n\nCertainly! Here are some top Node.js interview questions along with detailed explanations:\n\n1. What is Node.js?\n   Answer: Node.js is an open-source, server-side JavaScript runtime environment built on Chrome's V8 JavaScript engine. It allows developers to execute JavaScript code outside the browser, making it possible to build scalable and high-performance web applications.\n\n2. Explain the concept of non-blocking I/O in Node.js.\n   Answer: Non-blocking I/O (input/output) is a key feature of Node.js. It means that while the program is performing I/O operations, it can still continue executing other code without waiting for the I/O operation to complete. This is achieved through the use of asynchronous callbacks and event-driven architecture, which allows Node.js to handle multiple connections and operations concurrently, resulting in high scalability and performance.\n\n3. What is npm and what is its significance in Node.js?\n   Answer: npm (Node Package Manager) is the default package manager for Node.js. It is a command-line tool that allows developers to discover, install, and manage third-party libraries and packages in their Node.js projects. npm simplifies dependency management, making it easy to include external libraries and share code with other developers. It also provides versioning, script execution, and publishing capabilities.\n\n4. What is the role of the package.json file in Node.js projects?\n   Answer: package.json is a metadata file used in Node.js projects. It includes project-specific information such as the project name, version, author, dependencies, and scripts. It serves as a central configuration file that npm uses to manage project dependencies and scripts. Developers can also specify project-specific settings, build processes, and other metadata in the package.json file.\n\n5. Explain the concept of middleware in Express.js.\n   Answer: Middleware in Express.js are functions that have access to the request (`req`) and response (`res`) objects. They can perform operations on the request or response, modify data, and control the flow of the request-handling process. Middleware functions can be added to the application's request-response cycle using the `app.use()` or `app.METHOD()` functions. Middleware is often used for tasks like logging, authentication, error handling, and parsing request bodies.\n\n6. What is callback hell and how can it be avoided in Node.js?\n   Answer: Callback hell refers to the situation where multiple asynchronous operations are nested inside each other, leading to code that is difficult to read and maintain. It can be avoided by using techniques such as Promises, async/await, or using control flow libraries like async.js. Promises provide a cleaner way to handle asynchronous operations, while async/await allows writing asynchronous code in a synchronous-like manner, improving readability and maintainability.\n\n7. Explain the concept of streams in Node.js.\n   Answer: Streams in Node.js provide an interface for efficiently handling data that can be read or written sequentially, in chunks, rather than loading the entire data into memory. Streams are used for processing large files, network communication, and other I/O operations. They improve memory efficiency and reduce response times by enabling data to be processed as it arrives, rather than waiting for the entire data to be available.\n\n8. How does error handling work in Node.js?\n   Answer: Error handling in Node.js can be done using try-catch blocks for synchronous code. For asynchronous operations, errors are typically handled using callback functions, Promises, or async/await with try-catch blocks. In Express.js, error handling middleware can be used to catch and handle errors that occur during the request-response cycle. Proper error handling is important for detecting and gracefully handling errors, preventing application crashes, and providing meaningful error messages to users.\n\n9. What is clustering in Node.js and why is it useful?\n   Answer: Clustering in Node.js\n\n allows for the creation of multiple child processes (workers) that can share the same server port. It helps distribute the incoming workload across multiple CPUs or cores, enabling efficient utilization of system resources and improving application performance and scalability. Clustering is particularly useful for handling concurrent requests, improving response times, and ensuring high availability of Node.js applications.\n\n10. What are the differences between `require()` and `import` in Node.js?\n    Answer: `require()` is the CommonJS module system used in Node.js, while `import` is part of the ES6 (ECMAScript 2015) module system. `require()` is used to load modules synchronously, while `import` allows for asynchronous module loading. Additionally, `import` supports advanced features like named imports and tree shaking, which enables bundlers to eliminate unused code during the build process. Node.js has started to support `import` with the introduction of the \"ES Modules\" feature in recent versions.\n\nThese explanations should provide you with a good understanding of the concepts and topics typically covered in Node.js interviews. However, it's essential to prepare and study further based on the specific requirements of the position and the company you're interviewing with.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 7
    },
    {
      "subject": "node",
      "title": "what is the difference between async series and async waterfall in asyncjs?",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "The main difference between `async.series` and `async.waterfall` in the `async` module is in how they handle the flow of asynchronous tasks and pass the results between them.\n\n1. `async.series`:\n   - Executes an array of functions in series, one after another.\n   - Each function in the series receives a callback function as an argument, which it must call to indicate completion and pass the result to the next function in the series.\n   - The final callback is called with the results of the last function in the series.\n   - The result of each function is passed as an argument to the next function.\n   - If any function encounters an error, the series stops executing, and the final callback is immediately called with the error.\n\n   ```javascript\n   async.series([\n     (callback) => {\n       // Task 1\n       callback(null, 'Result 1');\n     },\n     (callback) => {\n       // Task 2\n       callback(null, 'Result 2');\n     },\n     // ...\n   ], (err, results) => {\n     // Final callback\n   });\n   ```\n\n2. `async.waterfall`:\n   - Executes an array of functions in a waterfall manner, passing the result of each function as an argument to the next function.\n   - Each function in the waterfall receives one or more arguments (the result of the previous function(s)) and a callback function.\n   - The callback function must be called to indicate completion and pass the result to the next function in the waterfall.\n   - The final callback is called with the result of the last function in the waterfall.\n   - If any function encounters an error, the waterfall stops executing, and the final callback is immediately called with the error.\n\n   ```javascript\n   async.waterfall([\n     (callback) => {\n       // Task 1\n       callback(null, 'Result 1');\n     },\n     (arg1, callback) => {\n       // Task 2, receives arg1 as the result of Task 1\n       callback(null, 'Result 2');\n     },\n     // ...\n   ], (err, result) => {\n     // Final callback\n   });\n   ```\n\nIn summary, `async.series` executes functions in series, passing the results between them as arguments, while `async.waterfall` executes functions in a waterfall manner, passing the result of each function as an argument to the next function. The choice between them depends on the specific requirements of your async code flow.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 8
    },
    {
      "subject": "node",
      "title": "Socket.io in nodejs",
      "ques": "",
      "links": [
        {
          "name": "https://chat.openai.com/share/5833dd0c-08ff-4009-80f1-5f56b2dae5bc"
        }
      ],
      "tags": [],
      "ans": "To implement socket.io when the Node.js server and React client are on different ports, you'll need to configure the server and client to allow cross-origin connections. Here's how you can do it:\n\nServer-side (Node.js):\n\n1. Install the `cors` and `socket.io` libraries by running the following command in your Node.js project directory:\n   ```\n   npm install cors socket.io\n   ```\n\n2. Update your server-side code (`server.js`) to include the `cors` middleware and configure CORS for socket.io:\n\n   ```javascript\n   const express = require('express');\n   const http = require('http');\n   const socketIO = require('socket.io');\n   const cors = require('cors');\n\n   const app = express();\n   const server = http.createServer(app);\n   const io = socketIO(server);\n\n   // Apply CORS middleware\n   app.use(cors());\n\n   // Handle socket connection\n   io.on('connection', (socket) => {\n     console.log('Client connected.');\n\n     // Handle incoming messages from clients\n     socket.on('message', (data) => {\n       console.log('Received:', data);\n\n       // Broadcast the message to all connected clients\n       io.emit('message', data);\n     });\n\n     // Handle client disconnection\n     socket.on('disconnect', () => {\n       console.log('Client disconnected.');\n     });\n   });\n\n   // Start the server\n   const port = 3001; // choose any available port\n   server.listen(port, () => {\n     console.log(`Server listening on port ${port}`);\n   });\n   ```\n\nClient-side (React):\n\n1. In your React component, e.g., `Chat.js`, import the `socket.io-client` library and create a socket connection:\n\n   ```jsx\n   import React, { useEffect, useState } from 'react';\n   import socketIOClient from 'socket.io-client';\n\n   const Chat = () => {\n     // ...\n\n     useEffect(() => {\n       const socket = socketIOClient('http://localhost:3001'); // Change the URL to your server's URL\n\n       // ...\n     }, []);\n\n     // ...\n   };\n   ```\n\n   In the `socketIOClient` function, provide the URL of your Node.js server, including the correct port number.\n\n   Note: By default, `socket.io-client` will attempt to connect using the WebSocket transport. If the server and client are on different ports, make sure the server allows WebSocket connections.\n\nEnsure that the Node.js server and the React client are running simultaneously on their respective ports. The server should have CORS configured to allow cross-origin requests, and the client should connect to the correct server URL.\n\nWith these configurations, the React client should be able to establish a socket.io connection with the Node.js server, even if they are on different ports.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 9
    },
    {
      "subject": "node",
      "title": "what are file operations possible in nodejs",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "Node.js provides several built-in modules for performing file operations. Here are some common file operations you can perform in Node.js:\n\n1. Reading Files:\n   - `fs.readFile(path[, options], callback)`: Asynchronously reads the entire contents of a file.\n   - `fs.readFileSync(path[, options])`: Synchronously reads the entire contents of a file.\n\n2. Writing Files:\n   - `fs.writeFile(file, data[, options], callback)`: Asynchronously writes data to a file, replacing the file if it already exists.\n   - `fs.writeFileSync(file, data[, options])`: Synchronously writes data to a file, replacing the file if it already exists.\n\n3. Appending to Files:\n   - `fs.appendFile(file, data[, options], callback)`: Asynchronously appends data to a file, creating the file if it does not exist.\n   - `fs.appendFileSync(file, data[, options])`: Synchronously appends data to a file, creating the file if it does not exist.\n\n4. Renaming Files:\n   - `fs.rename(oldPath, newPath, callback)`: Asynchronously renames a file or moves it to a different location.\n   - `fs.renameSync(oldPath, newPath)`: Synchronously renames a file or moves it to a different location.\n\n5. Deleting Files:\n   - `fs.unlink(path, callback)`: Asynchronously deletes a file.\n   - `fs.unlinkSync(path)`: Synchronously deletes a file.\n\n6. Checking File or Directory Existence:\n   - `fs.exists(path, callback)`: Asynchronously checks if a file or directory exists.\n   - `fs.existsSync(path)`: Synchronously checks if a file or directory exists.\n\n7. Creating Directories:\n   - `fs.mkdir(path[, options], callback)`: Asynchronously creates a new directory.\n   - `fs.mkdirSync(path[, options])`: Synchronously creates a new directory.\n\n8. Reading Directories:\n   - `fs.readdir(path[, options], callback)`: Asynchronously reads the contents of a directory.\n   - `fs.readdirSync(path[, options])`: Synchronously reads the contents of a directory.\n\nThese are just a few examples of the file operations available in Node.js. The `fs` (file system) module provides a wide range of functionality for interacting with files and directories. You can refer to the Node.js documentation for more detailed information on each of these functions and additional file operations: https://nodejs.org/api/fs.html",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 10
    },
    {
      "subject": "node",
      "title": "how to use stream in nodejs?",
      "ques": "",
      "links": [
        {
          "name": "https://nodejs.org/api/stream.html"
        }
      ],
      "tags": [],
      "ans": "In Node.js, streams are used to handle streaming data, allowing you to efficiently process and transfer large amounts of data in chunks. Streams provide an abstraction for handling I/O operations and can be used for reading from or writing to files, network sockets, or other data sources. Here's an overview of how to use streams in Node.js:\n\n1. Creating Streams:\n   - Readable Streams: To create a readable stream, you can use the `fs.createReadStream()` method to read data from a file or `http.get()` method to read data from a web server.\n   - Writable Streams: To create a writable stream, you can use the `fs.createWriteStream()` method to write data to a file or `http.request()` method to send data to a web server.\n\n2. Piping Streams:\n   - Piping is a convenient way to transfer data between streams.\n   - You can pipe the output of a readable stream to the input of a writable stream using the `pipe()` method.\n\n   ```javascript\n   const fs = require('fs');\n\n   const readableStream = fs.createReadStream('input.txt');\n   const writableStream = fs.createWriteStream('output.txt');\n\n   readableStream.pipe(writableStream);\n   ```\n\n3. Handling Events:\n   - Streams emit various events that you can listen to and handle.\n   - Common events include `'data'` (emitted when data is available to be read), `'end'` (emitted when there is no more data to be read), and `'error'` (emitted when an error occurs).\n\n   ```javascript\n   const fs = require('fs');\n\n   const readableStream = fs.createReadStream('input.txt');\n\n   readableStream.on('data', (chunk) => {\n     console.log(`Received ${chunk.length} bytes of data.`);\n   });\n\n   readableStream.on('end', () => {\n     console.log('No more data to read.');\n   });\n\n   readableStream.on('error', (error) => {\n     console.error(`An error occurred: ${error.message}`);\n   });\n   ```\n\n4. Transform Streams:\n   - Transform streams are a type of duplex streams that allow you to modify or transform data as it passes through the stream.\n   - You can create a transform stream by extending the `Transform` class from the `stream` module and implementing the `_transform` method.\n\n   ```javascript\n   const { Transform } = require('stream');\n\n   class MyTransformStream extends Transform {\n     _transform(chunk, encoding, callback) {\n       // Transform data here\n       const transformedChunk = chunk.toString().toUpperCase();\n\n       this.push(transformedChunk); // Push transformed data to the writable stream\n       callback();\n     }\n   }\n\n   const transformStream = new MyTransformStream();\n\n   // Piping readable stream to transform stream to writable stream\n   readableStream.pipe(transformStream).pipe(writableStream);\n   ```\n\nThese are some basic concepts and usage examples of streams in Node.js. Streams provide an efficient way to handle large data sets, enabling you to process and transfer data in chunks, which is particularly useful when dealing with files, network communication, or other I/O operations. For more details and advanced usage, you can refer to the official Node.js documentation on streams: https://nodejs.org/api/stream.html",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 11
    },
    {
      "subject": "node",
      "title": "how to implement clustering in nodejs?",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "Clustering in Node.js allows you to utilize multiple processes and distribute the workload across them, taking advantage of multi-core systems and improving the performance and scalability of your Node.js applications. Here's an overview of how to implement clustering in Node.js:\n\n1. Use the `cluster` module:\n   - Node.js provides the built-in `cluster` module to enable clustering.\n   - You can require the `cluster` module in your Node.js application to utilize its functionalities.\n\n   ```javascript\n   const cluster = require('cluster');\n   ```\n\n2. Check if the current process is the master process:\n   - The master process is responsible for creating and managing the worker processes.\n   - You can use the `cluster.isMaster` property to determine if the current process is the master process.\n\n   ```javascript\n   if (cluster.isMaster) {\n     // Code for the master process\n   }\n   ```\n\n3. Fork worker processes:\n   - Inside the master process, you can use the `cluster.fork()` method to create worker processes.\n   - Each worker process runs the same Node.js application independently.\n\n   ```javascript\n   if (cluster.isMaster) {\n     const numWorkers = require('os').cpus().length;\n\n     for (let i = 0; i < numWorkers; i++) {\n       cluster.fork();\n     }\n   }\n   ```\n\n4. Handle events in the master process:\n   - You can listen to events in the master process to handle worker process-related events, such as when a worker process is forked, exits, or disconnects.\n\n   ```javascript\n   if (cluster.isMaster) {\n     cluster.on('fork', (worker) => {\n       console.log(`Worker ${worker.id} is forked.`);\n     });\n\n     cluster.on('exit', (worker, code, signal) => {\n       console.log(`Worker ${worker.id} has exited with code ${code} and signal ${signal}.`);\n     });\n\n     // ...\n   }\n   ```\n\n5. Implement the worker process logic:\n   - Inside the worker processes, you can write the logic specific to each worker process.\n   - This includes listening to network ports, handling requests, and performing the required operations.\n\n   ```javascript\n   if (!cluster.isMaster) {\n     const http = require('http');\n\n     const server = http.createServer((req, res) => {\n       res.writeHead(200);\n       res.end('Hello from worker process!');\n     });\n\n     server.listen(3000);\n   }\n   ```\n\nBy implementing clustering in your Node.js application, you can distribute the workload across multiple processes, effectively utilizing the available system resources and improving the performance and scalability of your application. The `cluster` module provides a simple way to achieve this, allowing you to create and manage worker processes for improved handling of concurrent requests.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 12
    },
    {
      "subject": "node",
      "title": "what are security concerns in nodejs?",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "When developing Node.js applications, it's important to be aware of and address various security concerns to ensure the safety and integrity of your application and its data. Here are some common security concerns in Node.js:\n\n1. Injection Attacks:\n   - SQL Injection: Improperly validated user inputs can lead to SQL injection attacks where malicious SQL queries are executed against your database.\n   - Command Injection: Similar to SQL injection, command injection occurs when user inputs are executed as commands on the underlying operating system.\n\n2. Cross-Site Scripting (XSS):\n   - XSS attacks occur when user-supplied data is rendered on the client-side without proper sanitization, allowing malicious scripts to execute in the user's browser.\n\n3. Cross-Site Request Forgery (CSRF):\n   - CSRF attacks involve tricking users into performing unwanted actions on a website without their knowledge or consent.\n   - To mitigate CSRF attacks, you can implement techniques such as CSRF tokens, checking referrer headers, or employing the SameSite attribute in cookies.\n\n4. Insecure Dependencies:\n   - Node.js applications often rely on third-party packages and libraries, which may contain vulnerabilities.\n   - Regularly update and patch your dependencies, and use tools like npm audit to identify and address known security vulnerabilities.\n\n5. Insecure Authentication and Authorization:\n   - Weak or improperly implemented authentication mechanisms can lead to unauthorized access to user accounts.\n   - Store user passwords securely using techniques like bcrypt hashing with salts.\n   - Implement proper session management and access controls to ensure that only authorized users can access sensitive resources.\n\n6. Secure Configuration:\n   - Improperly configured application settings, such as using default or weak passwords, can expose your application to security risks.\n   - Ensure that sensitive configuration data, such as database credentials or API keys, are properly secured and not exposed in source code repositories or accessible to unauthorized individuals.\n\n7. Denial of Service (DoS) Attacks:\n   - Node.js applications can be vulnerable to DoS attacks, where attackers attempt to overwhelm the system with a high volume of requests, exhausting system resources.\n   - Implement rate limiting, request validation, and other defensive mechanisms to mitigate the impact of DoS attacks.\n\n8. Error Handling and Logging:\n   - Proper error handling and logging are essential for detecting and responding to security incidents.\n   - Avoid exposing sensitive information in error messages that could be useful to attackers.\n   - Implement secure logging practices to ensure that logs are protected and accessible only to authorized personnel.\n\n9. Secure Communication:\n   - Protect sensitive data transmitted over networks by using secure protocols such as HTTPS.\n   - Implement proper SSL/TLS certificate management and configuration to ensure secure communication between clients and servers.\n\n10. Regular Security Audits and Updates:\n    - Regularly review and update your application's security practices.\n    - Stay updated with security advisories, patches, and best practices from the Node.js community and security resources.\n\nIt's important to adopt a proactive approach to security by considering these concerns and implementing appropriate security measures throughout the development lifecycle of your Node.js applications.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 13
    },
    {
      "subject": "node",
      "title": "what are ways through which we can improve performance and memory utilization in nodejs?",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "To improve performance and memory utilization in Node.js applications, you can employ various techniques and best practices. Here are some ways to achieve better performance and memory utilization:\n\n1. Optimize Code:\n   - Identify and optimize performance bottlenecks in your code by using profiling tools like Node.js built-in profiler or third-party tools like Clinic.js or New Relic.\n   - Use efficient algorithms and data structures to improve the execution time and memory usage of your code.\n   - Minimize unnecessary operations and avoid blocking or synchronous I/O calls that can degrade performance.\n\n2. Leverage Asynchronous I/O:\n   - Node.js excels in handling asynchronous I/O operations. Utilize asynchronous programming techniques, such as callbacks, Promises, or async/await, to prevent blocking the event loop and improve concurrency.\n   - Use non-blocking I/O libraries and functions to avoid thread blocking and make better use of system resources.\n\n3. Implement Caching:\n   - Introduce caching mechanisms to reduce the load on your application and improve response times.\n   - Cache frequently accessed data or expensive computations in memory or external cache stores like Redis or Memcached.\n\n4. Load Balancing and Scaling:\n   - Distribute the workload across multiple Node.js instances using load balancing techniques, such as clustering or employing a load balancer (e.g., Nginx or HAProxy) in front of your Node.js application.\n   - Scale horizontally by adding more servers or instances to handle increased traffic and load.\n\n5. Optimize Network and Database Operations:\n   - Minimize network round-trips by combining multiple requests into a single request using techniques like batching or data aggregation.\n   - Optimize database queries by creating appropriate indexes, using query optimizations, and reducing unnecessary data fetching.\n\n6. Memory Management:\n   - Use memory-efficient data structures and algorithms to minimize memory consumption.\n   - Avoid memory leaks by properly managing resources, closing database connections, and releasing unused memory.\n   - Employ tools like `heapdump` or `memwatch-next` to analyze and debug memory-related issues.\n\n7. Monitoring and Performance Tuning:\n   - Continuously monitor your application's performance using tools like Node.js Profiler, monitoring services (e.g., New Relic, Datadog), or custom monitoring solutions.\n   - Identify performance bottlenecks, memory leaks, or excessive resource consumption and apply necessary optimizations.\n\n8. Properly Configure Node.js:\n   - Adjust Node.js configuration parameters, such as the maximum heap size (`--max-old-space-size`), thread pool size, or garbage collection settings, to optimize memory usage and performance.\n   - Experiment with different configurations and benchmark your application to find the optimal settings for your specific workload.\n\n9. Use C/C++ Addons:\n   - For CPU-intensive tasks, consider implementing performance-critical parts of your application using C/C++ addons, which can be significantly faster than pure JavaScript implementations.\n\n10. Employ Caching and Content Delivery Networks (CDNs):\n    - Utilize caching mechanisms at different levels, such as in-memory caching, CDN caching, or browser caching, to serve static assets and reduce the load on your server.\n\nBy implementing these techniques, you can significantly improve the performance and memory utilization of your Node.js applications, making them more efficient and scalable. However, it's essential to analyze and profile your application's performance to identify specific areas for improvement and conduct thorough testing to ensure the optimizations don't introduce any unintended side effects.\n\n-----\n\n\nHere are some effective ways to improve performance in Node.js applications:\n\n- Use asynchronous I/O operations instead of synchronous - avoid blocking the event loop thread.\n\n- Limit synchronous CPU-intensive work using Worker threads.\n\n- Use Node clusters to distribute load across multiple processes. \n\n- Enable compression using gzip/brotli for API responses and static assets.\n\n- Use caching libraries like Redis to cache database query results, API responses etc.\n\n- Use a CDN to serve static assets - reduces server load.\n\n- Profile code using Node's built-in profiler to identify bottlenecks.\n\n- Avoid heavy computation in route handlers - delegate to services.\n\n- Use Database query optimizations - indexing, caching, clustering etc. \n\n- Limit payload size by filtering API fields, pagination etc.\n\n- Use faster data stores like MongoDB, Redis for specific use cases.\n\n- Monitor event loop latency and other metrics using tools.\n\n- Debounce high frequency events like scroll, click etc. \n\n- Use production-grade Node servers like Fastify over Express for better performance.\n\n- Enable keep-alive for HTTP requests to reduce overhead.\n\n- Distribute work across multiple machines with load balancing and horizontal scaling.\n\nIn summary, leverage Node's asynchronous IO, distribute workload efficiently, optimize data access, compression, caching and do performance analysis regularly.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 14
    },
    {
      "subject": "node",
      "title": "what are the use case in nodejs where memory leak may occur? explain with code example",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "\nMemory leaks can occur in Node.js when objects or data are unintentionally retained in memory, preventing them from being garbage-collected and leading to excessive memory consumption. Here are a few common use cases in Node.js where memory leaks may occur:\n\n1. Event listeners without proper cleanup:\n\n```javascript\nconst EventEmitter = require('events');\n\nconst emitter = new EventEmitter();\n\nfunction startProcessing() {\n  emitter.on('data', processData);\n}\n\nfunction processData(data) {\n  // Process data\n}\n\nfunction stopProcessing() {\n  emitter.off('data', processData);\n}\n\n// Start processing data\nstartProcessing();\n\n// Stop processing data\nstopProcessing();\n```\n\nIn the above example, the `startProcessing` function registers an event listener for the `'data'` event using `emitter.on()`. However, when the processing is stopped by calling `stopProcessing`, the event listener should be removed using `emitter.off()`. If the `off` call is omitted, the event listener will continue to be referenced, preventing its garbage collection and causing a memory leak.\n\n2. Caching large amounts of data:\n\n```javascript\nconst cache = {};\n\nfunction fetchData(key) {\n  if (cache[key]) {\n    return cache[key];\n  }\n\n  const data = expensiveDataFetchingOperation();\n  cache[key] = data;\n  return data;\n}\n```\n\nIn this example, data fetched from an expensive operation is stored in a cache object for subsequent retrievals. However, if the cache grows indefinitely without any mechanism for expiration or eviction, it can lead to memory leaks. This is particularly problematic if the cached data is large or the cache keys are dynamically generated and can potentially result in an unbounded memory consumption.\n\nTo avoid this, consider implementing a cache eviction strategy (e.g., using a maximum cache size, time-based expiration, or LRU algorithm) to ensure that the cache remains within reasonable memory limits.\n\n3. Streams and pipelines:\n\n```javascript\nconst fs = require('fs');\n\nfunction processFile(filePath) {\n  const stream = fs.createReadStream(filePath);\n\n  // Read stream and process data\n  stream.on('data', processData);\n  stream.on('end', () => {\n    // Clean up resources\n    stream.close();\n  });\n}\n```\n\nWhen working with streams and pipelines in Node.js, it's crucial to handle events like `'end'` or `'finish'` appropriately to ensure proper cleanup. Failing to do so can result in lingering references to streams, preventing them from being garbage-collected and leading to memory leaks.\n\nIn the above code snippet, the `'end'` event is used to signal the end of reading the stream, and the `stream.close()` method is called to clean up resources. Neglecting to call `close()` or properly handle other relevant events can result in memory leaks.\n\nTo mitigate memory leaks in these scenarios, it's important to ensure proper cleanup by removing event listeners, releasing resources, and implementing strategies like cache eviction or limiting the size of stored data. Additionally, using tools like memory profilers or heap analyzers can help identify and resolve memory leaks in more complex scenarios.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 15
    },
    {
      "subject": "node",
      "title": "How to create server in Nodejs",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "Express\n--------\n\nTo implement a simple Node.js server, you can follow these steps:\n\n1. Set up a new Node.js project: Create a new directory for your project and navigate to it in your terminal. Run `npm init` to initialize a new Node.js project and follow the prompts to set up your `package.json` file.\n\n2. Install dependencies: Install the `express` package, which is a popular framework for building web applications in Node.js. Run the following command in your project directory:\n\n   ```bash\n   npm install express\n   ```\n\n3. Create a new JavaScript file: Create a new file, such as `server.js`, in your project directory.\n\n4. Import the necessary modules: In your `server.js` file, import the required modules:\n\n   ```javascript\n   const express = require('express');\n   ```\n\n5. Create an instance of the Express application: Initialize an instance of the Express application:\n\n   ```javascript\n   const app = express();\n   ```\n\n6. Define routes and endpoints: Set up the routes and define the desired endpoints for your server. For example:\n\n   ```javascript\n   app.get('/', (req, res) => {\n     res.send('Hello, world!');\n   });\n   ```\n\n   In the above code snippet, we define a GET route for the root URL (`/`) and send a simple response of \"Hello, world!\".\n\n7. Start the server: Add the following code to start the server and listen on a specific port:\n\n   ```javascript\n   const port = 3000; // Specify the port number you want to use\n\n   app.listen(port, () => {\n     console.log(`Server is running on port ${port}`);\n   });\n   ```\n\n8. Start the server: In your terminal, run the following command to start the server:\n\n   ```bash\n   node server.js\n   ```\n\n   You should see the message \"Server is running on port 3000\" in the console.\n\n9. Test the server: Open your web browser and visit `http://localhost:3000` (or the specified port number). You should see the \"Hello, world!\" message displayed in your browser.\n\nThat's it! You have successfully implemented a simple Node.js server using Express. You can add more routes, middleware, and functionality as needed for your specific application.\n\n\nNodejs\n-------\n\nTo implement a simple Node.js server without using a framework like Express, you can utilize the built-in `http` module in Node.js. Here's a basic example:\n\n1. Create a new JavaScript file, such as `server.js`.\n\n2. Import the necessary modules:\n```javascript\nconst http = require('http');\n```\n\n3. Define the request handler function:\n```javascript\nconst requestHandler = (req, res) => {\n  res.writeHead(200, { 'Content-Type': 'text/plain' });\n  res.end('Hello, world!');\n};\n```\n\nIn the above code, we set the response status code to 200 and the content type to 'text/plain'. Then, we send the response with the message 'Hello, world!'.\n\n4. Create an HTTP server instance:\n```javascript\nconst server = http.createServer(requestHandler);\n```\n\nHere, we create an HTTP server instance using the `createServer` method and pass in the `requestHandler` function to handle incoming requests.\n\n5. Specify the port and start the server:\n```javascript\nconst port = 3000; // Specify the port number you want to use\n\nserver.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});\n```\n\nWe specify the port number (e.g., 3000) on which the server should listen, and then start the server by calling the `listen` method.\n\n6. Start the server:\nIn your terminal, navigate to the project directory and run the following command:\n```bash\nnode server.js\n```\n\nYou should see the message \"Server is running on port 3000\" in the console.\n\n7. Test the server:\nOpen your web browser and visit `http://localhost:3000` (or the specified port number). You should see the \"Hello, world!\" message displayed in your browser.\n\nThat's it! You have implemented a basic Node.js server without using Express. You can extend this code to handle different routes, handle various HTTP methods, and add additional functionality as per your requirements.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 16
    },
    {
      "subject": "node",
      "title": "what are different different http codes ?",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "HTTP status codes are three-digit numbers that are returned by a server in response to a client's request. They indicate the outcome of the request or provide information about the server's response. Here are some of the commonly encountered HTTP status codes along with their general categories:\n\n1xx - Informational\n- 100: Continue\n- 101: Switching Protocols\n- 102: Processing\n\n2xx - Success\n- 200: OK\n- 201: Created\n- 204: No Content\n- 206: Partial Content\n\n3xx - Redirection\n- 301: Moved Permanently\n- 302: Found\n- 304: Not Modified\n- 307: Temporary Redirect\n\n4xx - Client Errors\n- 400: Bad Request\n- 401: Unauthorized\n- 403: Forbidden\n- 404: Not Found\n- 405: Method Not Allowed\n- 409: Conflict\n- 429: Too Many Requests\n\n5xx - Server Errors\n- 500: Internal Server Error\n- 502: Bad Gateway\n- 503: Service Unavailable\n- 504: Gateway Timeout\n\nThese are just a few examples of the numerous HTTP status codes available. Each status code carries a specific meaning and provides information about the outcome of the request. It's important to handle these codes appropriately in your applications to provide meaningful responses to clients and handle errors gracefully.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 17
    },
    {
      "subject": "node",
      "title": "Free API course",
      "ques": "",
      "links": [
        {
          "name": "https://www.linkedin.com/feed/update/urn:li:activity:7078408639631245312/"
        }
      ],
      "tags": [],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 18
    },
    {
      "subject": "node",
      "title": "how to implement graphql in nodejs, explain in details with code example",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "To implement GraphQL in Node.js, you will need to set up a GraphQL server and define a schema that specifies the available types and operations. Here's a step-by-step guide with code examples to help you get started:\n\nStep 1: Set up a new Node.js project\nCreate a new directory for your project and initialize it as a Node.js project using npm or yarn. Open your terminal and run the following commands:\n\n```bash\nmkdir graphql-example\ncd graphql-example\nnpm init -y\n```\n\nStep 2: Install required packages\nNext, you'll need to install the necessary packages for implementing GraphQL in Node.js. In this example, we'll use the `express`, `express-graphql`, and `graphql` packages. Run the following command:\n\n```bash\nnpm install express express-graphql graphql\n```\n\nStep 3: Create an Express server\nCreate a new file called `server.js` and add the following code to set up an Express server:\n\n```javascript\nconst express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\n\nconst app = express();\n\napp.get('/', (req, res) => {\n  res.send('GraphQL Server is running');\n});\n\napp.listen(3000, () => {\n  console.log('Server started on http://localhost:3000');\n});\n```\n\nStep 4: Define the GraphQL schema\nCreate a new file called `schema.js` and define your GraphQL schema using the GraphQL Schema Definition Language (SDL). The schema defines the available types and operations in your API. Here's an example schema that defines a simple \"Hello, World!\" query:\n\n```javascript\nconst { buildSchema } = require('graphql');\n\nconst schema = buildSchema(`\n  type Query {\n    hello: String\n  }\n`);\n\nmodule.exports = schema;\n```\n\nStep 5: Implement the resolver functions\nResolver functions are responsible for fetching the data for each field defined in the schema. Create a new file called `resolvers.js` and implement the resolver function for the `hello` field:\n\n```javascript\nconst resolvers = {\n  hello: () => 'Hello, World!',\n};\n\nmodule.exports = resolvers;\n```\n\nStep 6: Integrate GraphQL with the Express server\nUpdate the `server.js` file to integrate GraphQL with the Express server. Import the schema and resolvers, and use the `graphqlHTTP` middleware to handle GraphQL requests:\n\n```javascript\nconst express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst schema = require('./schema');\nconst resolvers = require('./resolvers');\n\nconst app = express();\n\napp.use('/graphql', graphqlHTTP({\n  schema,\n  rootValue: resolvers,\n  graphiql: true,\n}));\n\napp.get('/', (req, res) => {\n  res.send('GraphQL Server is running');\n});\n\napp.listen(3000, () => {\n  console.log('Server started on http://localhost:3000');\n});\n```\n\nStep 7: Start the server\nFinally, start the server by running the following command:\n\n```bash\nnode server.js\n```\n\nYou should see a message indicating that the server has started on `http://localhost:3000`. You can now access the GraphQL API using tools like GraphiQL or GraphQL Playground.\n\nExample usage:\nNavigate to `http://localhost:3000/graphql` in your browser. You will see a GraphQL IDE where you can execute queries. Try executing the following query:\n\n```graphql\nquery {\n  hello\n}\n```\n\nYou should receive the response:\n\n```json\n{\n  \"data\": {\n    \"hello\": \"Hello, World!\"\n  }\n}\n```\n\nCongratulations! You have implemented a basic GraphQL server in Node.js. From here, you can continue building your schema",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 19
    },
    {
      "subject": "node",
      "title": "why use ORM in nodejs? explain with code example",
      "ques": "",
      "links": [
        {
          "name": "https://www.youtube.com/watch?v=Crk_5Xy8GMA&list=WL&index=15"
        },
        {
          "name": "https://www.youtube.com/watch?v=bQA8GO_pJPo"
        },
        {
          "name": "https://www.youtube.com/watch?v=eY7MttZ0gPU"
        }
      ],
      "tags": [],
      "ans": "ORM (Object-Relational Mapping) in Node.js is a technique that allows developers to interact with a relational database using an object-oriented approach. It provides a higher-level abstraction over database operations, making it easier to perform CRUD (Create, Read, Update, Delete) operations and manage database relationships.\n\nThere are several advantages to using ORM in Node.js:\n\n1. Simplified Database Interactions: ORM simplifies the process of interacting with databases by abstracting away low-level SQL queries. Instead, developers can use JavaScript code and ORM methods to perform database operations.\n\n2. Database Portability: ORM allows you to switch between different database systems (such as MySQL, PostgreSQL, SQLite) without having to change your code significantly. This portability enables flexibility and reduces the dependency on a specific database.\n\n3. Object-Oriented Approach: ORM maps database tables to JavaScript objects, allowing developers to work with data in a more familiar and intuitive way. This abstraction improves code readability and maintainability.\n\n4. Query Building and Optimization: ORM frameworks provide query builders that simplify the construction of complex SQL queries. These query builders offer methods to compose queries programmatically, helping developers avoid manual string concatenation and SQL injection vulnerabilities. Additionally, ORM frameworks often optimize the queries they generate for better performance.\n\nHere's an example using the popular ORM framework Sequelize in Node.js:\n\n```javascript\nconst { Sequelize, DataTypes } = require('sequelize');\n\n// Connect to the database\nconst sequelize = new Sequelize('database', 'username', 'password', {\n  host: 'localhost',\n  dialect: 'mysql',\n});\n\n// Define a model\nconst User = sequelize.define('User', {\n  firstName: {\n    type: DataTypes.STRING,\n    allowNull: false,\n  },\n  lastName: {\n    type: DataTypes.STRING,\n    allowNull: false,\n  },\n  email: {\n    type: DataTypes.STRING,\n    allowNull: false,\n    unique: true,\n    validate: {\n      isEmail: true,\n    },\n  },\n});\n\n// Create a new user\nasync function createUser(firstName, lastName, email) {\n  try {\n    const user = await User.create({ firstName, lastName, email });\n    console.log('User created:', user.toJSON());\n  } catch (error) {\n    console.error('Error creating user:', error);\n  }\n}\n\n// Query users\nasync function getUsers() {\n  try {\n    const users = await User.findAll();\n    console.log('Users:', users.map(user => user.toJSON()));\n  } catch (error) {\n    console.error('Error querying users:', error);\n  }\n}\n\n// Update a user\nasync function updateUser(id, firstName) {\n  try {\n    const user = await User.findByPk(id);\n    if (user) {\n      user.firstName = firstName;\n      await user.save();\n      console.log('User updated:', user.toJSON());\n    } else {\n      console.log('User not found.');\n    }\n  } catch (error) {\n    console.error('Error updating user:', error);\n  }\n}\n\n// Delete a user\nasync function deleteUser(id) {\n  try {\n    const user = await User.findByPk(id);\n    if (user) {\n      await user.destroy();\n      console.log('User deleted.');\n    } else {\n      console.log('User not found.');\n    }\n  } catch (error) {\n    console.error('Error deleting user:', error);\n  }\n}\n\n// Usage\ncreateUser('John', 'Doe', 'john.doe@example.com');\ngetUsers();\nupdateUser(1, 'Jane');\ndeleteUser(1);\n```\n\nIn the above example, Sequelize is used to define a User model and perform CRUD operations. The ORM abstracts away the SQL queries, allowing developers to focus on working with JavaScript objects. This results in cleaner and more maintainable code.\n\nOverall, using ORM in Node.js simplifies database interactions, enhances code readability, improves portability, and provides query optimization, making it a valuable tool for developers working with relational databases.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 20
    },
    {
      "subject": "node",
      "title": "how to implement unit-test in nodejs, explain with code examples",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "Implementing unit tests in Node.js involves using a testing framework, such as Jest or Mocha, to write and execute tests for your code. Here's an explanation with code examples using Jest, a popular testing framework in the Node.js ecosystem.\n\nStep 1: Set up the Testing Environment\nFirst, you need to set up your project to include the testing framework and any necessary dependencies. Assuming you have Node.js and npm (Node Package Manager) installed, follow these steps:\n\n1. Create a new directory for your project and navigate to it in the terminal.\n2. Initialize a new Node.js project by running `npm init` and following the prompts.\n3. Install the testing framework (Jest) as a development dependency by running `npm install --save-dev jest`.\n4. Create a folder named `__tests__` (double underscores) in the root directory of your project. This is where your test files will reside.\n\nStep 2: Write the Unit Test\nOnce your project is set up, you can start writing unit tests. A unit test typically focuses on testing a specific function or module in isolation. Here's an example:\n\nLet's say you have a module named `math.js` with a function `add` that adds two numbers:\n\n```javascript\n// math.js\nfunction add(a, b) {\n  return a + b;\n}\n\nmodule.exports = { add };\n```\n\nTo test the `add` function, create a test file named `math.test.js` in the `__tests__` directory:\n\n```javascript\n// __tests__/math.test.js\nconst { add } = require('../math');\n\ntest('add function should add two numbers correctly', () => {\n  expect(add(2, 3)).toBe(5);\n  expect(add(-1, 7)).toBe(6);\n  expect(add(0, 0)).toBe(0);\n});\n```\n\nIn the test file, we import the `add` function from `math.js` and use the `test` function provided by Jest to define a test case. Within the test case, we use the `expect` function to make assertions about the behavior of the `add` function. In this case, we're checking if the function returns the expected sum for different input values.\n\nStep 3: Run the Tests\nTo run the tests, execute the following command in the terminal:\n\n```bash\nnpx jest\n```\n\nJest will automatically discover and execute all the test files in the `__tests__` directory. It will report the results of each test case, including any failed assertions.\n\nThat's it! You have successfully implemented a basic unit test in Node.js using Jest.\n\nYou can expand on this approach to write more tests for different functions or modules in your project. Jest provides many powerful features for test configuration, mocking, and more. You can refer to the Jest documentation (https://jestjs.io) for more information on utilizing these features.\n\nRemember, the key to effective unit testing is to cover different scenarios and edge cases, ensuring that your code behaves as expected in a controlled environment.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 21
    },
    {
      "subject": "node",
      "title": "what are unittest libraries used in nodejs, angular , react and python, explain with detailed code example",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "In Node.js, Angular, React, and Python, there are popular unit testing libraries/frameworks available for writing and executing tests. Let's explore the commonly used ones in each of these technologies, along with detailed code examples.\n\n1. Node.js:\n   - Jest: Jest is a widely used testing framework for Node.js applications. It provides an intuitive API, powerful mocking capabilities, and supports running tests in parallel. Here's an example of how to use Jest in Node.js:\n\n```javascript\n// math.js\nfunction add(a, b) {\n  return a + b;\n}\n\nmodule.exports = { add };\n```\n\n```javascript\n// math.test.js\nconst { add } = require('./math');\n\ntest('add function should add two numbers correctly', () => {\n  expect(add(2, 3)).toBe(5);\n  expect(add(-1, 7)).toBe(6);\n  expect(add(0, 0)).toBe(0);\n});\n```\n\n2. Angular:\n   - Jasmine: Jasmine is a behavior-driven development (BDD) testing framework commonly used for testing Angular applications. It provides a rich set of matchers and spies for testing and mocking. Here's an example of how to use Jasmine in an Angular component:\n\n```typescript\n// math.ts\nexport function add(a: number, b: number): number {\n  return a + b;\n}\n```\n\n```typescript\n// math.spec.ts\nimport { add } from './math';\n\ndescribe('Math functions', () => {\n  it('should add two numbers correctly', () => {\n    expect(add(2, 3)).toBe(5);\n    expect(add(-1, 7)).toBe(6);\n    expect(add(0, 0)).toBe(0);\n  });\n});\n```\n\n3. React:\n   - React Testing Library: React Testing Library is a lightweight library that encourages testing React components by focusing on their behavior from a user's perspective. It provides utilities for rendering components and querying the rendered output. Here's an example of how to use React Testing Library in a React component:\n\n```jsx\n// Counter.jsx\nimport React, { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  const increment = () => {\n    setCount(count + 1);\n  };\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={increment}>Increment</button>\n    </div>\n  );\n}\n\nexport default Counter;\n```\n\n```jsx\n// Counter.test.jsx\nimport React from 'react';\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport Counter from './Counter';\n\ntest('increments the count when the button is clicked', () => {\n  render(<Counter />);\n\n  const incrementButton = screen.getByText('Increment');\n  fireEvent.click(incrementButton);\n\n  const countElement = screen.getByText('Count: 1');\n  expect(countElement).toBeInTheDocument();\n});\n```\n\n4. Python:\n   - unittest: The `unittest` module is part of Python's standard library and provides a framework for writing and running tests. It offers a wide range of assertions and test runners. Here's an example of how to use `unittest` in Python:\n\n```python\n# math.py\ndef add(a, b):\n    return a + b\n```\n\n```python\n# test_math.py\nimport unittest\nfrom math import add\n\nclass MathTestCase(unittest.TestCase):\n    def test_add(self):\n        self.assertEqual(add(2, 3), 5)\n        self.assertEqual(add(-1, 7), 6)\n        self.assertEqual(add(0, 0), 0)\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\nThese examples showcase the usage of the most commonly used unit testing libraries/frameworks in Node.js, Angular, React, and Python. By adopting these libraries, you can effectively write and run tests to ensure the correctness of your code and the expected behavior of your applications.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 22
    },
    {
      "subject": "node",
      "title": "what is the benefits of using Sequelize compared to other ORM?",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "Sequelize is a popular Object-Relational Mapping (ORM) library for Node.js that provides several benefits compared to other ORM options. Here are some key advantages of using Sequelize:\n\n1. Wide Database Support: Sequelize supports multiple databases, including PostgreSQL, MySQL, SQLite, and MSSQL. This flexibility allows you to work with different database systems without significant code changes, making it suitable for projects that require database portability or migration.\n\n2. Comprehensive Feature Set: Sequelize offers a comprehensive set of features for managing database interactions. It provides support for data modeling, schema migrations, data validation, query building, associations between models, transactions, and more. This feature-rich nature of Sequelize simplifies many common database-related tasks and reduces the need for writing low-level SQL queries.\n\n3. Object-Oriented Approach: Sequelize maps database tables to JavaScript objects, enabling developers to work with data using familiar object-oriented paradigms. This abstraction improves code readability and maintainability, as developers can interact with data using methods and properties rather than dealing with raw SQL statements.\n\n4. Query Building and Optimization: Sequelize provides a query builder that simplifies the construction of complex SQL queries. The query builder offers a fluent API for composing queries programmatically, which reduces the risk of SQL injection vulnerabilities and improves code robustness. Additionally, Sequelize optimizes the generated queries to improve performance by minimizing redundant database operations.\n\n5. Middleware and Hooks: Sequelize allows you to define middleware functions and hooks at various stages of the database interaction lifecycle. This feature enables you to execute custom logic before or after certain database operations, such as data validation, encryption, or logging. Middleware and hooks enhance the extensibility and customization capabilities of Sequelize.\n\n6. Active Community and Documentation: Sequelize has a vibrant community with active development and maintenance. It is widely adopted and well-documented, providing extensive resources, tutorials, and examples. The active community ensures regular updates, bug fixes, and feature enhancements, making Sequelize a reliable choice for long-term projects.\n\nWhile Sequelize offers many advantages, it's essential to consider the specific requirements of your project and evaluate alternative ORM libraries based on factors like performance, compatibility with specific databases, and community support. Some other popular ORM options in the Node.js ecosystem include TypeORM, Bookshelf.js, and Knex.js.\n\n\n\n\n==========>\n\n\nIn Sequelize, you can create migrations for all models using the Sequelize CLI (`sequelize-cli`). The CLI provides a convenient way to generate migration files for each model you have defined in your application. Here's how you can create migrations for all models:\n\n1. **Install Sequelize CLI:**\n   Make sure you have Sequelize CLI installed globally in your project. If not, you can install it using the following command:\n\n   ```bash\n   npm install -g sequelize-cli\n   ```\n\n2. **Generate Migrations for Models:**\n   You can use the Sequelize CLI to automatically generate migration files for all models. The `model:generate` command generates migration files for all models defined in your application.\n\n   ```bash\n   sequelize-cli model:generate --name user --attributes firstName:string,lastName:string,email:string\n   sequelize-cli model:generate --name post --attributes title:string,content:text\n   # Add more model:generate commands for each of your models\n   ```\n\n   Replace `user` and `post` with the names of your models, and specify the attributes for each model.\n\n3. **Edit Generated Migration Files:**\n   After generating the migration files, navigate to the `migrations` folder in your project directory. You will find individual migration files for each model you specified in the previous step.\n\n   Open each migration file and review the generated code. The generated migration files contain the `up` and `down` functions that define the changes to be made to the database schema. You might need to customize these functions based on your specific requirements.\n\n4. **Run Migrations:**\n   Once you have reviewed and customized the migration files as needed, you can run the migrations to apply the changes to the database:\n\n   ```bash\n   sequelize-cli db:migrate\n   ```\n\n   This command will execute all pending migrations in the order they were created.\n\nRemember that automating the generation of migration files is helpful, but it's important to review and customize the generated migration files to ensure they accurately reflect the changes you want to make to your database schema. Additionally, always make sure to create backups of your database before running migrations, especially in production environments.\n\n\n\n\n",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 23
    },
    {
      "subject": "node",
      "title": "How to implement zero division exception in nodejs?",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "In Node.js, you can implement a custom zero division exception by creating a custom error class that extends the built-in `Error` class. This custom exception will be thrown when a division by zero occurs in your code. Here's how you can do it:\n\n1. Create a new file for your custom exception:\n\nStart by creating a new JavaScript file (e.g., `customExceptions.js`) to define your custom exceptions.\n\n2. Define your custom exception class:\n\nIn the `customExceptions.js` file, define your custom zero division exception class by extending the built-in `Error` class.\n\n```javascript\n// customExceptions.js\nclass ZeroDivisionException extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'ZeroDivisionException'; // Set the name of the exception for easier identification\n  }\n}\n\nmodule.exports = {\n  ZeroDivisionException,\n};\n```\n\n3. Use the custom exception in your application:\n\nIn your main application file, or wherever you want to handle the custom zero division exception, require the `customExceptions.js` file and use the `ZeroDivisionException` class.\n\n```javascript\nconst { ZeroDivisionException } = require('./customExceptions.js');\n\nfunction divide(a, b) {\n  if (b === 0) {\n    throw new ZeroDivisionException('Division by zero is not allowed.');\n  }\n  return a / b;\n}\n\ntry {\n  const result = divide(10, 0);\n  console.log(\"Result:\", result);\n} catch (error) {\n  if (error instanceof ZeroDivisionException) {\n    console.error('ZeroDivisionException occurred:', error.message);\n    // Handle the custom zero division exception accordingly\n  } else {\n    // Handle other types of exceptions or rethrow the unknown error\n    throw error;\n  }\n}\n```\n\nIn this example, the `divide` function checks if the divisor `b` is zero. If it is, the function throws a new instance of the `ZeroDivisionException` class with a custom error message. The `try...catch` block is used to handle this custom zero division exception. If the exception occurs within the `try` block, it will be caught in the `catch` block, and the error message will be printed to the console.\n\nBy following these steps, you have successfully implemented a custom zero division exception in Node.js using a custom error class. Now, when a division by zero occurs in your code, the `ZeroDivisionException` will be thrown and can be caught and handled appropriately in the `try...catch` block.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 24
    },
    {
      "subject": "node",
      "title": "What is inbuilt exceptions in nodejs?",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "In Node.js, the built-in exceptions are not as standardized and organized as in Python. Node.js primarily uses the built-in JavaScript `Error` object and its subclasses to handle exceptions. JavaScript's `Error` object is the base class for all built-in exceptions and user-defined exceptions in Node.js.\n\nHere are some commonly used built-in exceptions in Node.js:\n\n1. `Error`: The base class for all errors. You can create custom error objects by extending this class.\n\n2. `TypeError`: Raised when an operation or function is applied to an object of an inappropriate type.\n\n3. `SyntaxError`: Raised when there is a syntax error in the code.\n\n4. `ReferenceError`: Raised when an invalid reference is used, such as trying to access an undefined variable.\n\n5. `RangeError`: Raised when a numeric variable or parameter is outside its valid range.\n\n6. `EvalError`: Raised when an error occurs during the `eval()` function execution.\n\n7. `URIError`: Raised when a global function, such as `decodeURI()` or `decodeURIComponent()`, is used incorrectly.\n\n8. `SystemError`: This error is not a standard JavaScript error, but it is sometimes used in Node.js to indicate a generic system-level error.\n\nNode.js also provides additional error types beyond the standard JavaScript errors. For example, when working with streams or network-related operations, you might encounter exceptions specific to those APIs.\n\nNode.js often uses the `Error` object and its subclasses to create error objects with more context, such as `SyntaxError`, `TypeError`, etc. When an exception occurs, an error object is thrown, and you can use `try...catch` blocks to handle these exceptions, just like in the Python examples mentioned earlier.\n\nHere's an example of how to use try-catch to handle an exception in Node.js:\n\n```javascript\ntry {\n  // Some code that may throw an exception\n  throw new TypeError('This is a custom TypeError.');\n} catch (error) {\n  console.error('An exception occurred:', error.message);\n  // Handle the exception here\n}\n```\n\nIn this example, we are explicitly throwing a `TypeError`, and the `catch` block will catch the exception and print an error message. You can replace `TypeError` with any other built-in error type or create your own custom error classes to handle specific use cases.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 25
    },
    {
      "subject": "node",
      "title": "How to raise exception in nodejs?",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "In Node.js, you can raise (also known as throwing) an exception using the `throw` keyword. When you encounter an error or an exceptional situation in your code, you can use the `throw` statement to signal that an exception has occurred and halt the normal flow of execution. This allows you to handle errors or exceptional cases gracefully using `try...catch` blocks.\n\nHere's how you can raise an exception in Node.js:\n\n```javascript\nfunction divide(a, b) {\n  if (b === 0) {\n    throw new Error(\"Division by zero is not allowed.\");\n  }\n  return a / b;\n}\n\ntry {\n  const result = divide(10, 0);\n  console.log(\"Result:\", result);\n} catch (error) {\n  console.error(\"An exception occurred:\", error.message);\n  // Handle the exception here\n}\n```\n\nIn this example, the `divide` function checks if the divisor `b` is zero. If it is, the function throws a new instance of the built-in `Error` class with a custom error message. The `try...catch` block is used to handle this exception. If an exception occurs within the `try` block, it will be caught in the `catch` block, and the error message will be printed to the console.\n\nYou can also create and throw custom exceptions, as discussed in the previous answer, to add more context and information to your error handling.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 26
    },
    {
      "subject": "node",
      "title": "How to implement custom exceptions in nodejs?",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "In Node.js, you can implement custom exceptions by creating your own custom error classes. JavaScript allows you to extend the built-in `Error` class to create custom error classes with additional properties and methods. Here's a step-by-step guide on how to do it:\n\n1. Create a new file for your custom exception:\n\nStart by creating a new JavaScript file (e.g., `customExceptions.js`) to define your custom exceptions.\n\n2. Define your custom exception class:\n\nIn the `customExceptions.js` file, define your custom exception class by extending the built-in `Error` class. You can add any custom properties and methods you need in your exception.\n\n```javascript\n// customExceptions.js\nclass MyCustomException extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'MyCustomException'; // Set the name of the exception for easier identification\n    // Add any custom properties or methods here\n  }\n}\n\nmodule.exports = {\n  MyCustomException,\n};\n```\n\n3. Use the custom exception in your application:\n\nIn your main application file, or wherever you want to throw the custom exception, require the `customExceptions.js` file and use the `MyCustomException` class.\n\n```javascript\nconst { MyCustomException } = require('./customExceptions.js');\n\nfunction someFunction(someValue) {\n  if (someValue !== expectedValue) {\n    throw new MyCustomException('This is a custom exception message.');\n  }\n}\n\ntry {\n  someFunction(42);\n} catch (error) {\n  if (error instanceof MyCustomException) {\n    console.error('Custom exception occurred:', error.message);\n    // Handle the custom exception accordingly\n  } else {\n    // Handle other types of exceptions or rethrow the unknown error\n    throw error;\n  }\n}\n```\n\nBy following these steps, you have successfully implemented a custom exception in Node.js using JavaScript's `Error` class inheritance. Now, when `someFunction` is called with a value that is not the expected value, it will throw the `MyCustomException`, which can be caught and handled appropriately in the `try...catch` block.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 27
    },
    {
      "subject": "node",
      "title": "how to Automatically Generate Swagger Docs in nodejs express",
      "ques": "",
      "links": [
        {
          "name": "https://www.youtube.com/watch?v=5aryMKiBEKY"
        }
      ],
      "tags": [],
      "ans": "To automatically generate Swagger documentation for your Node.js Express API, you can use the `swagger-jsdoc` and `swagger-ui-express` libraries. Here's a step-by-step guide to setting it up:\n\n1. **Install Dependencies**:\n   Open your project directory in the terminal and install the necessary packages:\n\n   ```bash\n   npm install swagger-jsdoc swagger-ui-express\n   ```\n\n2. **Create Swagger Configuration**:\n   Create a `swagger.json` or `swagger.yaml` configuration file in your project's root directory. This file will define the specifications for your API. Here's an example `swagger.json` file:\n\n   ```json\n   {\n     \"swagger\": \"2.0\",\n     \"info\": {\n       \"title\": \"Your API\",\n       \"description\": \"Your API Description\",\n       \"version\": \"1.0.0\"\n     },\n     \"basePath\": \"/\",\n     \"schemes\": [\"http\", \"https\"],\n     \"paths\": {},\n     \"definitions\": {}\n   }\n   ```\n\n3. **Add JSDoc Comments**:\n   In your Express route handlers, use JSDoc comments to describe your API endpoints. Annotate your routes with `@swagger` comments that describe the route, method, and any parameters or responses. Here's an example:\n\n   ```javascript\n   /**\n    * @swagger\n    * /hello:\n    *   get:\n    *     description: Returns a simple hello message\n    *     responses:\n    *       200:\n    *         description: A successful response\n    */\n   app.get('/hello', (req, res) => {\n     res.send('Hello, World!');\n   });\n   ```\n\n4. **Generate Swagger Docs**:\n   Create a script to generate the Swagger documentation using the `swagger-jsdoc` library. Add this script to your `package.json`:\n\n   ```json\n   \"scripts\": {\n     \"generate-swagger\": \"swagger-jsdoc -d ./path/to/swagger.json -o ./path/to/swagger-output.json\"\n   }\n   ```\n\n   Run the script using:\n\n   ```bash\n   npm run generate-swagger\n   ```\n\n5. **Add Swagger UI**:\n   Create an Express route to serve the Swagger UI documentation. Use the `swagger-ui-express` middleware to display the Swagger UI interface. Add this code to your main server file:\n\n   ```javascript\n   const swaggerUi = require('swagger-ui-express');\n   const swaggerDocument = require('./path/to/swagger-output.json');\n\n   app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerDocument));\n   ```\n\n6. **Run Your Express Server**:\n   Start your Express server:\n\n   ```bash\n   node your-server.js\n   ```\n\n7. **Access Swagger Docs**:\n   Open a web browser and navigate to `http://localhost:your-port/api-docs` (replace `your-port` with your server's port). You should see the Swagger UI interface with automatically generated API documentation based on your JSDoc comments.\n\nBy following these steps, you can automatically generate Swagger documentation for your Node.js Express API. This documentation provides a user-friendly interface for exploring and interacting with your API endpoints.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 28
    },
    {
      "subject": "node",
      "title": "how to implement pub sub in nodejs",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "Implementing the Publish-Subscribe (Pub-Sub) pattern in Node.js can be achieved using various libraries and techniques. One commonly used library is `EventEmitter`, which is built into Node.js and provides a simple way to create custom event-driven architectures. Here's how you can implement Pub-Sub using `EventEmitter`:\n\n1. **Create a Pub-Sub Module:**\n\n   Start by creating a module that uses `EventEmitter` to manage events and subscriptions.\n\n   ```javascript\n   // pubsub.js\n   const EventEmitter = require('events');\n\n   class PubSub {\n     constructor() {\n       this.eventEmitter = new EventEmitter();\n     }\n\n     publish(event, data) {\n       this.eventEmitter.emit(event, data);\n     }\n\n     subscribe(event, listener) {\n       this.eventEmitter.on(event, listener);\n     }\n\n     unsubscribe(event, listener) {\n       this.eventEmitter.removeListener(event, listener);\n     }\n   }\n\n   module.exports = new PubSub();\n   ```\n\n2. **Subscribe to an Event:**\n\n   In a module that wants to listen for events, use the `subscribe` method to listen for a specific event.\n\n   ```javascript\n   // subscriber.js\n   const pubsub = require('./pubsub');\n\n   function handleCustomEvent(data) {\n     console.log('Received custom event:', data);\n   }\n\n   pubsub.subscribe('customEvent', handleCustomEvent);\n   ```\n\n3. **Publish an Event:**\n\n   In another module that wants to publish an event, use the `publish` method.\n\n   ```javascript\n   // publisher.js\n   const pubsub = require('./pubsub');\n\n   function publishEvent() {\n     pubsub.publish('customEvent', 'Event data from Publisher');\n   }\n\n   publishEvent();\n   ```\n\n4. **Run Modules:**\n\n   Run your subscriber and publisher modules using Node.js.\n\n   ```bash\n   node subscriber.js\n   node publisher.js\n   ```\n\nWith this implementation, when you run the `publisher.js` script, it will publish the \"customEvent\", and the `subscriber.js` script will receive the event and execute the associated handler function.\n\nKeep in mind that this is a basic example using Node.js's built-in `EventEmitter`. Depending on your requirements, you might consider using more advanced libraries like `NATS`, `RabbitMQ`, or `Redis` for more sophisticated Pub-Sub implementations with features like message persistence, distributed systems support, and scalability.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 29
    }
  ],
  "eng": [
    {
      "subject": "eng",
      "title": "",
      "ques": "",
      "links": [],
      "tags": [
        {
          "name": "tech"
        }
      ],
      "ans": "* strange bugs can creep into your software\n* data flow in your program is lossy\n* But frozen objects are only superficially immutable.\n* Declarative rather than imperative code (what to do, rather than how to do it)\n* If you keep your side effects separate from the rest of your program logic, your software will be much easier to extend, refactor, debug, test, and maintain.\n* key to writing bulletproof code and being a better developer",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 1
    },
    {
      "subject": "eng",
      "title": "",
      "ques": "",
      "links": [],
      "tags": [
        {
          "name": "tongue-twister"
        }
      ],
      "ans": "exponentially\ngazil- lion\nplanning horizon\nunbelievable\nstandardise\nbreathtakingly\nReasonably - ree·zuh·nuh·blee",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 2
    },
    {
      "subject": "eng",
      "title": "",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "- I have got things to show, that no one’s ever seen\n- I have got habits that are hard to break\n- I swear each morning, when I wake today,s the day, I am coming clean\n- I have got dreams that might not come to any kind of fruition\n",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 3
    },
    {
      "subject": "eng",
      "title": "",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "- I have got cracks in my facade, I may fall between \n- “To escape and sit quietly on the beach - that’s my idea of paradise.”\n- True friends say good things behind your back and bad things to your face. .. Friends like family\n- My Heart is filled with Love and Gratitude\n- I love it when you call me Señorita, I wish I could pretend I didn't need you\n",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 4
    },
    {
      "subject": "eng",
      "title": "",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "- “Body is not stiff. Mind is stiff.”\n- So here is the Gorgeous Niti Dancing with her Gang because where is the fun without the bride \n- What should I ROB next? All your hearts are already mine\n- Beyond the crowds and city lights!\n- I had the pleasure of visiting #NYC with the spark of my fire, the light of my life, the wind under my wings and the one and only ‘Senorita’ of my love story. We also found a city in the far far west that resonated with us in so many levels.  A glimpse of us in the U.S of A!\n",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 5
    },
    {
      "subject": "eng",
      "title": "",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "- A lil party never hurt anybody. Except our parties are not lil.\n- The joy of getting back on the field. Been a long time\n- It’s a wrap! What a fun ride this has been. Much love and ounces of gratitude to the whole team of\n- A tsunami of flavours in your mouth\n- The farthest distance in the world is between how it is and how you thought it was gonna be ",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 6
    },
    {
      "subject": "eng",
      "title": "",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "1.Now thanks fully, we are the much less intimidating \n2.the accelerated velocity of terminological inexactitude.\nWhich is just my obnoxious way of saying that lies travel fast\n3.depraved behaviour \n4.indecency\n5.I hope for your sake that God has a sense of humor,\nOh I have 17 year’s worth of anecdotal proof he does\n",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 7
    },
    {
      "subject": "eng",
      "title": "",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "6.I am not nearly as smart as I think I am\n7.Great, now i an a tramp\n8.I am gonna have to get a lower back tattoo\n   and pierce something not on my face.\n9.you would testify to that?\n10.It’s a little low on grist\n",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 8
    },
    {
      "subject": "eng",
      "title": "",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "11.clever wordplay \n12.ten-story building \n13.it could find me if i was dressed as a crack on a sidewalk\n14.people hear you had sex once and, bam, you’re a bimbo\n15.but I gotta admit, I kind of liked being on the map\n",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 9
    },
    {
      "subject": "eng",
      "title": "",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "16.I am gonna throw some rhymes\n     Anson, drop me a beat\n17.big, hulking black guy\n18.is besmirched and made to wear a red A for “adulterer”\n19.perhaps you should embroider a red A on your wardrobe, abominable tramp\nPerhaps you should get a wardrobe, you abominable twat\n20.it was provocative enough to land me in the principal office\n21.A snide comment from a snotty girl in my class\n22.From the blood I saw gushing out of your nose, I thought you were bullied",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 10
    },
    {
      "subject": "eng",
      "title": "",
      "ques": "",
      "links": [
        {
          "name": "https://www.youtube.com/watch?v=h3U5TX19tXA"
        }
      ],
      "tags": [],
      "ans": "\n*MTP - Medium Term Plan\n\n*Moonshot - meant \"long shot,\" it's increasingly being used to describe a monumental effort and a lofty goal—in other words, a \"giant leap.\"\n\n*jarvis - ust A Rather Very Intelligent System\n\n*UBI - Universal Basic Income\n\n*obscure - Unclear\n\n*chaotic - in a state of complete confusion and disorder.\n\n*dystopian - relating to or denoting an imagined state or society where there is great suffering or injustice\n\n*humanoid - having an appearance or character resembling that of a human.\n\n*Technological signularity - The technological singularity is the point at which artificial intelligence will surpass human intelligence, leading to a future in which machines can learn and innovate on their own. Some experts believe that this could happen within the next few decades, while others believe it is still centuries away",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 11
    },
    {
      "subject": "eng",
      "title": "",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "\n*Vertical v/s horizontal business\n\n*discrete business problem\n\n*GBU - Global Business Unit\n\n*\n\n",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 12
    },
    {
      "subject": "eng",
      "title": "[17/July/23]how cryptocurrency can change the finance?",
      "ques": "",
      "links": [],
      "tags": [
        {
          "name": "FB"
        }
      ],
      "ans": "Cryptocurrency has the potential to change finance in a few ways. Let's explain it in simple words:\n\n1. **Digital Money for Everyone**: Cryptocurrency is like digital money that anyone can use. Just like you have physical coins and notes, cryptocurrency is a type of money that exists only in a digital form. It's stored in a special computer system called a blockchain.\n\n2. **No Banks, No Middlemen**: Normally, when you want to send money to someone, you go to a bank or use a payment service like PayPal. They act as middlemen, taking a small fee for their services. But with cryptocurrency, you can send money directly to someone else, just like sending an email. This means you can skip the middlemen and save money on fees.\n\n3. **Global Transactions Made Easier**: Cryptocurrency is not tied to any specific country or government. It works the same way no matter where you are in the world. This makes it easier for people in different countries to do business with each other, even if they use different currencies. It can also make it simpler for people without access to traditional banking services to participate in the global economy.\n\n4. **Secure and Transparent**: Cryptocurrency transactions are recorded on a blockchain, which is like a public ledger that everyone can see. This makes it very difficult to cheat or manipulate the system. It also provides a level of transparency that traditional financial systems may lack. However, the identities of people involved in the transactions are often pseudonymous or anonymous, which means their real names are not directly linked to their cryptocurrency addresses.\n\n5. **New Opportunities**: Cryptocurrency has opened up new opportunities for innovation. People can create new types of digital assets, develop decentralized applications, and explore new ways to use blockchain technology. This can lead to exciting advancements in finance, technology, and other industries.\n\nIt's important to remember that while cryptocurrency offers many potential benefits, it also comes with risks and challenges. It's still a relatively new concept, and people need to be cautious and learn how to use it safely. But with time, cryptocurrency could change the way we think about money and how we interact with financial systems.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 13
    },
    {
      "subject": "eng",
      "title": "Is procrastination good or bad?",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "Ladies and gentlemen, boys and girls,\n\nToday, I want to talk about something that we all might have experienced at some point, and it's called procrastination. But what exactly is procrastination? Well, it's when we delay or put off doing something we need to do. It's like when you have homework to complete, but you decide to play games or watch cartoons instead.\n\nNow, you might be wondering, is procrastination good or bad? Well, let me explain. Procrastination can be both good and bad, and I'll tell you why.\n\nFirst, let's talk about the not-so-good part of procrastination. When we keep delaying things, it can sometimes make us feel stressed and worried. Imagine having to prepare for a test, and you keep putting it off until the last minute. Then, you might not have enough time to study well, and that could lead to a lower grade. So, in such cases, procrastination is not helpful.\n\nBut, believe it or not, there can also be some good things about procrastination. Sometimes, when we take short breaks and do something fun, it helps us feel refreshed and more motivated. It's like taking a little rest before going back to our tasks. Also, during those breaks, our brains can come up with new and creative ideas that might actually help us do the task better.\n\nThe key is to find a balance. We can take small breaks, but we also need to make sure we get our important tasks done on time. If we keep delaying everything, it might lead to problems later on.\n\nSo, what can we do about procrastination? Well, we can try to make a schedule or a to-do list. By doing this, we can see what needs to be done and when. It can help us stay on track and finish our tasks without too much delay.\n\nRemember, it's okay to take breaks and have fun, but we also need to be responsible and get our important work done on time.\n\nIn conclusion, procrastination can be both good and bad. Taking short breaks and having fun is fine, but we should also try to complete our tasks on time. By finding a balance, we can make sure that procrastination doesn't become a big problem for us.\n\nThank you for listening, and I hope you all have a great day!",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 14
    }
  ],
  "puz": [],
  "man": [],
  "networking": [
    {
      "subject": "networking",
      "title": "OSI Model",
      "ques": "",
      "links": [
        {
          "name": "https://www.youtube.com/watch?v=vv4y_uOneC0"
        }
      ],
      "tags": [],
      "ans": "The OSI (Open Systems Interconnection) model is a conceptual framework used to understand and describe how different parts of a computer network communicate with each other. It breaks down network communication into seven distinct layers, each responsible for specific tasks. Let's explore these layers with simple real-life examples:\n\n1. **Physical Layer (Layer 1):**\n   - **Description:** The Physical Layer deals with the physical connections and transmission of raw data bits over a physical medium, such as cables or wireless signals.\n   - **Real-Life Example:** Think of this as the electrical wiring in your house. It ensures that electricity can flow from one place to another reliably and without interference.\n\n2. **Data Link Layer (Layer 2):**\n   - **Description:** The Data Link Layer manages the flow of data frames between devices on the same network. It provides error detection and correction.\n   - **Real-Life Example:** Imagine sending a letter through the postal service. The Data Link Layer is like the postal service, ensuring that your letter is correctly addressed, packaged, and sent without errors.\n\n3. **Network Layer (Layer 3):**\n   - **Description:** The Network Layer is responsible for routing data between different networks, such as the internet. It uses logical addresses (like IP addresses) to make decisions about where data should go.\n   - **Real-Life Example:** When you send a package via a courier service, the Network Layer is like the courier company's routing system, deciding which route to take to deliver your package to its destination.\n\n4. **Transport Layer (Layer 4):**\n   - **Description:** The Transport Layer ensures end-to-end communication, reliability, and data segmentation. It manages data flow between two devices and handles error recovery.\n   - **Real-Life Example:** Think of this as a conversation over the phone. The Transport Layer makes sure that both parties can talk to each other, and if a word is not understood, it asks for clarification.\n\n5. **Session Layer (Layer 5):**\n   - **Description:** The Session Layer manages and establishes sessions or connections between devices. It controls the flow of data, manages sessions, and handles synchronization.\n   - **Real-Life Example:** In a video call, the Session Layer is like the software that establishes the call, maintains it, and ensures that both participants are in sync.\n\n6. **Presentation Layer (Layer 6):**\n   - **Description:** The Presentation Layer deals with data translation, encryption, and compression. It ensures that data sent by one device can be understood by another.\n   - **Real-Life Example:** When you send an email with an attachment, the Presentation Layer is responsible for encoding the attachment in a way that the recipient's email client can decode and display.\n\n7. **Application Layer (Layer 7):**\n   - **Description:** The Application Layer is where users interact with network services and applications. It provides an interface for software to access network services.\n   - **Real-Life Example:** The Application Layer is like the various applications and programs on your computer or smartphone, such as web browsers, email clients, or social media apps.\n\nIn summary, the OSI model provides a structured way to understand how information flows through a network, from the physical cables and hardware to the software applications we use every day. Each layer has a specific role, just like different components of a real-life communication system work together to ensure that messages are delivered accurately and reliably.",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 1
    },
    {
      "subject": "networking",
      "title": "Devnet Sessions and docs",
      "ques": "",
      "links": [
        {
          "name": "https://drive.google.com/drive/folders/1zxj7endkENvDKK_dE-XbCW55eJpimOLm?usp=sharing_eip&ts=5f09db80"
        },
        {
          "name": "https://docs.google.com/document/d/1bsYarTjWPQDJUS7rNa1R5ep2mY8MSUl7/edit?usp=sharing&ouid=107951970104877310273&rtpof=true&sd=true"
        }
      ],
      "tags": [],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": "",
      "id": 2
    }
  ],
  "ds": [],
  "stat": [],
  "prob": []
}