{
  "users": [
    {
      "id": 1,
      "user": "admin@admin.com",
      "password": "admin"
    }
  ],
  "subjects": [
    {
      "id": 1,
      "name": "Algorithm",
      "key": "algo"
    },
    {
      "id": 2,
      "name": "Javascript",
      "key": "js"
    },
    {
      "id": 3,
      "name": "ES6",
      "key": "es6"
    },
    {
      "id": 4,
      "name": "Typescript",
      "key": "ts"
    },
    {
      "id": 5,
      "name": "HTML",
      "key": "html"
    },
    {
      "id": 6,
      "name": "CSS",
      "key": "css"
    },
    {
      "id": 7,
      "name": "Angular",
      "key": "ng"
    },
    {
      "id": 8,
      "name": "React",
      "key": "react"
    },
    {
      "id": 9,
      "name": "Redux",
      "key": "redux"
    },
    {
      "id": 10,
      "name": "Performance",
      "key": "performance"
    },
    {
      "id": 11,
      "name": "System Design",
      "key": "sd"
    },
    {
      "id": 12,
      "name": "Shell Scripting",
      "key": "shell"
    },
    {
      "id": 13,
      "name": "GIT",
      "key": "git"
    },
    {
      "id": 14,
      "name": "Python",
      "key": "py"
    },
    {
      "id": 13,
      "name": "Java",
      "key": "java"
    },
    {
      "id": 15,
      "name": "Others",
      "key": "oth"
    }
  ],
  "categories": [
    {
      "id": "1",
      "name": "String",
      "key": "str",
      "sub": "algo"
    },
    {
      "id": "2",
      "name": "Array",
      "key": "arr",
      "sub": "algo"
    },
    {
      "id": "3",
      "name": "Object|Hash|Mapping",
      "key": "obj",
      "sub": "algo"
    },
    {
      "id": "4",
      "name": "Search",
      "key": "search",
      "sub": "algo"
    },
    {
      "id": "5",
      "name": "Sorting",
      "key": "sort",
      "sub": "algo"
    },
    {
      "id": "51",
      "name": "Logarithms",
      "key": "log",
      "sub": "algo"
    },
    {
      "id": "6",
      "name": "Greedy",
      "key": "greed",
      "sub": "algo"
    },
    {
      "id": "61",
      "name": "Dynamic",
      "key": "dynamic",
      "sub": "algo"
    },
    {
      "id": "62",
      "name": "Recursion",
      "key": "recursion",
      "sub": "algo"
    },
    {
      "id": "7",
      "name": "Tree",
      "key": "tree",
      "sub": "algo"
    },
    {
      "id": "8",
      "name": "Date & Time",
      "key": "datetime",
      "sub": "algo"
    },
    {
      "id": "9",
      "name": "Queue & Stack",
      "key": "queueStack",
      "sub": "algo"
    },
    {
      "id": "10",
      "name": "Syllabus",
      "key": "syllabus",
      "sub": "algo"
    },
    {
      "id": "11",
      "name": "Disk",
      "key": "disk",
      "sub": "shell"
    },
    {
      "name": "Events",
      "key": "events",
      "sub": "js",
      "id": "K8hwS7H"
    },
    {
      "name": "General",
      "key": "general",
      "sub": "js",
      "id": "fLxAGlD"
    },
    {
      "name": "Async",
      "key": "async",
      "sub": "js",
      "id": "CcPDpap"
    },
    {
      "name": "DOM",
      "key": "dom",
      "sub": "js",
      "id": "VcHWFpK"
    },
    {
      "name": "Code Pattern",
      "key": "code_pattern",
      "sub": "js",
      "id": "QkRqsfU"
    },
    {
      "name": "OOPs",
      "key": "oops",
      "sub": "js",
      "id": "S9Hc3Bu"
    }
  ],
  "algo": [
    {
      "subject": "algo",
      "ques": "First non repeating character in a string",
      "links": [
        {
          "name": "https://www.youtube.com/watch?v=U7rxgP-fp8E"
        }
      ],
      "tags": [
        {
          "name": "ideserve"
        }
      ],
      "ans": "\nconst firstNonRepeat = (str) => {\n   let strMap = {};\n   for(let i = 0; i < str.length; i++){\n       let char = str[i];\n       if(char in strMap){\n           delete strMap[char];\n       } else {\n           strMap[char] = 1;\n       }\n   }\n   return Object.keys(strMap)[0];\n }\n \n const st = \"ADBCGHIEFKJLADTVDERFSWVGHQWCNOPENSMSJWIERTFB\";\n \n console.log(firstNonRepeat(st));",
      "diff": 2,
      "imp": 2,
      "cate": [
        "str"
      ],
      "id": 5
    },
    {
      "subject": "algo",
      "ques": "Anagram Pattern Search",
      "links": [
        {
          "name": "https://www.youtube.com/watch?v=h4MCwdfZZas"
        },
        {
          "name": "https://www.geeksforgeeks.org/anagram-substring-search-search-permutations/"
        }
      ],
      "tags": [
        {
          "name": "ideserve"
        }
      ],
      "ans": "const anyAnagram = (txt, pattern) => {\n       // create map for pattern\n       let pattMap = {};\n       for(let i=0; i<pattern.length; i++){\n           let ch = pattern[i];\n           pattMap[ch] = (ch in pattMap) ? ++pattMap[ch] : 1;\n       }\n \n       // method to compare two maps\n       const compareMap = (m1, m2) => {\n           // console.log(\"compareMap :: m1 : m2 ::::\", m1, \"::\", m2)\n           let keys1 = Object.keys(m1);\n           let keys2 = Object.keys(m2);\n           if(keys1.length != keys2.length){\n               return false;\n           }\n \n           for(let k of keys1){\n               if(m1[k] !== m2[k]){\n               return false;\n               }\n           }\n           return true;\n       }\n \n       let txtMap = {};\n       let insertCount = 0;\n       let firstCharIdx = 0;\n      \n       for(let i=0; i< txt.length; i++){\n           let ch = txt[i];\n           // text map\n           txtMap[ch] = (ch in txtMap) ? ++txtMap[ch] : 1;\n           ++insertCount;\n \n           // If insertion in map == pattern length\n           if(insertCount == pattern.length){\n               // compare map\n               let result = compareMap(pattMap, txtMap);\n               if(result){\n                   return \"Present\";\n               } else {\n                   // remove first ch\n                   let firstChar = txt[firstCharIdx];\n                   if(txtMap[firstChar] == 1){\n                       delete txtMap[firstChar];\n                   } else {\n                       txtMap[firstChar] = txtMap[firstChar] - 1;\n                   }\n                   // reduce insertion count\n                   insertCount = insertCount - 1;\n                   // increase firsr char index\n                   firstCharIdx = firstCharIdx + 1;\n               }\n           }\n       }\n       return \"Not Present\"\n   }\n \n   let Text = \"ideserve\";\n   let Pattern = \"veer\";\n \n   console.log(anyAnagram(Text, Pattern));",
      "diff": 1,
      "imp": 1,
      "cate": [
        "str"
      ],
      "id": 6
    },
    {
      "subject": "algo",
      "title": "In-Place Shuffle",
      "ques": "RANDOMLY Reorder Array in O(N)",
      "links": [
        {
          "name": "https://www.youtube.com/watch?v=CoI4S7z1E1Y&ab_channel=CSDojo"
        }
      ],
      "tags": [
        {
          "name": "Lynda"
        },
        {
          "name": "fisher-yates shuffle"
        },
        {
          "name": "Interview Cake"
        }
      ],
      "ans": "\nconst reorder = (arr) => {\n    for(let i=arr.length; i>0; i--){\n    \tconst randomIdx = Math.floor(Math.random() * i);\n    \t// swap\n    \tlet temp = arr[randomIdx];\n    \tarr[randomIdx] = arr[i-1];\n    \tarr[i-1] = temp;\n    }\n    return arr;\n}\n\nconsole.log(reorder([1,0,3,9,2]));",
      "diff": 1,
      "imp": 3,
      "cate": [
        "arr",
        "greed"
      ],
      "id": 7
    },
    {
      "subject": "algo",
      "title": "Top Scores",
      "ques": "Write a function that takes: an array of unsortedScores & the highestPossibleScore in the game and returns a sorted array of scores in less than O(n lg n) time.",
      "links": [],
      "tags": [
        {
          "name": "Interview Cake"
        }
      ],
      "ans": "\n/*\nconst unsortedScores = [37, 89, 41, 65, 91, 53];\nconst HIGHEST_POSSIBLE_SCORE = 100;\n\nsortScores(unsortedScores, HIGHEST_POSSIBLE_SCORE);\nreturns [91, 89, 65, 53, 41, 37]\n*/\n\nfunction sortScores(unorderedScores, highestPossibleScore) {\n\n    // Array of 0s at indices 0..highestPossibleScore\n    const scoreCounts = new Array(highestPossibleScore + 1).fill(0);\n  \n    // Populate scoreCounts\n    unorderedScores.forEach(score => {\n      scoreCounts[score]++;\n    });\n  \n    // Populate the final sorted array\n    const sortedScores = [];\n  \n    // For each item in scoreCounts\n    for (let score = highestPossibleScore; score >= 0; score--) {\n      const count = scoreCounts[score];\n  \n      // For the number of times the item occurs\n      for (let time = 0; time < count; time++) {\n        sortedScores.push(score);\n      }\n    }\n  \n    return sortedScores;\n  }",
      "diff": 2,
      "imp": 4,
      "cate": [
        "sort"
      ],
      "id": 8
    },
    {
      "subject": "algo",
      "title": "Bracket Validator",
      "ques": "Check for Balanced Brackets in an expression",
      "links": [],
      "tags": [
        {
          "name": "Interview Cake"
        }
      ],
      "ans": "\n/*\nInput: exp = “[()]{}{[()()]()}” \nOutput: true\n\nInput: exp = “[(])” \nOutput: false \n\n*/\nfunction isValid(code) {\n\n    const openersToClosers = {\n      '(': ')',\n      '[': ']',\n      '{': '}',\n    };\n  \n    const openers = new Set(['(', '[', '{']);\n    const closers = new Set([')', ']', '}']);\n  \n    const openersStack = [];\n  \n    for (let i = 0; i < code.length; i++) {\n      const char = code.charAt(i);\n  \n      if (openers.has(char)) {\n        openersStack.push(char);\n      } else if (closers.has(char)) {\n        if (!openersStack.length) {\n          return false;\n        }\n        const lastUnclosedOpener = openersStack.pop();\n  \n        // If this closer doesn't correspond to the most recently\n        // seen unclosed opener, short-circuit, returning false\n        if (openersToClosers[lastUnclosedOpener] !== char) {\n          return false;\n        }\n      }\n    }\n    return openersStack.length === 0;\n  }",
      "diff": 4,
      "imp": 4,
      "cate": [
        "queueStack"
      ],
      "id": 9
    },
    {
      "subject": "algo",
      "title": "Permutation Palindrome",
      "ques": "Write an efficient function that checks whether any permutation of an input string is a palindrome.",
      "links": [],
      "tags": [
        {
          "name": "Interview Cake"
        }
      ],
      "ans": "/**\n * \n * Write an efficient function that checks whether any permutation of an input string is a palindrome. \n\nYou can assume the input string only contains lowercase letters.\n\nExamples:\n\n\"civic\" should return true\n\"ivicc\" should return true\n\"civil\" should return false\n\"livci\" should return false\n */\n  function hasPalindromePermutation(theString) {\n\n    // Track characters we've seen an odd number of times\n    const unpairedCharacters = new Set();\n  \n    for (let char of theString) {\n      if (unpairedCharacters.has(char)) {\n        unpairedCharacters.delete(char);\n      } else {\n        unpairedCharacters.add(char);\n      }\n    }\n  \n    // The string has a palindrome permutation if it\n    // has one or zero characters without a pair\n    return unpairedCharacters.size <= 1; // If str length is odd, there will be 1\n  }",
      "diff": 3,
      "imp": 4,
      "cate": [
        "obj"
      ],
      "id": 10
    },
    {
      "subject": "algo",
      "title": "Reverse String",
      "ques": "Take an array of characters and reverse the letter",
      "links": [],
      "tags": [
        {
          "name": "Interview Cake"
        }
      ],
      "ans": "\nfunction reverse(arrayOfChars) {\n  let leftIndex = 0;\n  let rightIndex = arrayOfChars.length - 1;\n  while (leftIndex < rightIndex) {\n    // Swap characters\n    const temp = arrayOfChars[leftIndex];\n    arrayOfChars[leftIndex] = arrayOfChars[rightIndex];\n    arrayOfChars[rightIndex] = temp;\n    // Move towards middle leftIndex++; rightIndex--;\n  }\n}\n\n\n// OR\n\nconst reverse2 = (arrayOfChars) => {\n   let s = 0;\n   let m = Math.ceil(arrayOfChars.length / 2);\n\n   while(s < m){\n      let e = (arrayOfChars.length - 1) - s;\n      [arrayOfChars[s], arrayOfChars[e]] = [arrayOfChars[e], arrayOfChars[s]];\n      s = s + 1;\n   }\n   return arrayOfChars;\n}",
      "diff": 1,
      "imp": 1,
      "cate": [
        "str"
      ],
      "id": 11
    },
    {
      "subject": "algo",
      "title": "Reverse Words",
      "ques": "Takes a message as an array of characters and reverses the order of the words in place",
      "links": [],
      "tags": [
        {
          "name": "Interview Cake"
        }
      ],
      "ans": "/*\nconst message = [ 'c', 'a', 'k', 'e', ' ', 'p', 'o', 'u', 'n', 'd', ' ',\n's', 't', 'e', 'a', 'l' ]; \n\nreverseWords(message);\n\nconsole.log(message.join('')); \n// Prints: 'steal pound cake'\n*/\n\nfunction reverseWords(message) {\n  // First we reverse all the characters in the entire message reverseCharacters(message, 0, message.length - 1);\n  // This gives us the right word order\n  // but with each word backward\n  // Now we'll make the words forward again // by reversing each word's characters\n  // We hold the index of the *start* of the current word // as we look for the *end* of the current word\n  let currentWordStartIndex = 0;\n  for (let i = 0; i <= message.length; i++) {\n    // Found the end of the current word!\n    if (i === message.length || message[i] === \" \") {\n      // If we haven't exhausted the string our\n      // next word's start is one character ahead reverseCharacters(message, currentWordStartIndex, i - 1); currentWordStartIndex = i + 1;\n    }\n  }\n}\nfunction reverseCharacters(message, leftIndex, rightIndex) {\n  // Walk towards the middle, from both sides\n  while (leftIndex < rightIndex) {\n    // Swap the left char and right char const temp = message[leftIndex]; message[leftIndex] = message[rightIndex]; message[rightIndex] = temp;\n    leftIndex++;\n    rightIndex--;\n  }\n}\n",
      "diff": 1,
      "imp": 1,
      "cate": [
        "str"
      ],
      "id": 12
    },
    {
      "subject": "algo",
      "title": "Merge Sorted Arrays",
      "ques": "We have our lists of orders sorted numerically already, in arrays. Write a function to merge our arrays of orders into one sorted array",
      "links": [],
      "tags": [
        {
          "name": "Interview Cake"
        }
      ],
      "ans": "\n/* const myArray = [3, 4, 6, 10, 11, 15];\nconst alicesArray = [1, 5, 8, 12, 14, 19];\nconsole.log(mergeArrays(myArray, alicesArray));\n// logs [1, 3, 4, 5, 6, 8, 10, 11, 12, 14, 15, 19] \n*/\n\nfunction mergeArrays(myArray, alicesArray) {\n  // Set up our mergedArray const mergedArray = [];\n  let currentIndexAlices = 0;\n  let currentIndexMine = 0;\n  let currentIndexMerged = 0;\n  while (currentIndexMerged < myArray.length + alicesArray.length) {\n    const isMyArrayExhausted = currentIndexMine >= myArray.length;\n    const isAlicesArrayExhausted = currentIndexAlices >= alicesArray.length;\n    // Case: next comes from my array\n    // My array must not be exhausted, and EITHER:\n    // 1) Alice's array IS exhausted, or\n    // 2) The current element in my array is less\n    // than the current element in Alice's array\n    if (\n      !isMyArrayExhausted && (isAlicesArrayExhausted ||\n        myArray[currentIndexMine] < alicesArray[currentIndexAlices])\n    ) {\n      mergedArray[currentIndexMerged] = myArray[currentIndexMine];\n      currentIndexMine++;\n      // Case: next comes from Alice's array \n      \n    } else {\n      mergedArray[currentIndexMerged] = alicesArray[currentIndexAlices];\n      currentIndexAlices++;\n    }\n    currentIndexMerged++;\n  }\n  return mergedArray;\n}\n\n\n// OR\n\nconst mergeArrays = (arr1, arr2) => {\n    let finalArr = [];\n    let arr1Start = 0;\n    let arr2Start = 0;\n    while(arr1Start < arr1.length || arr2Start < arr2.length){\n        if(arr1[arr1Start] && arr2[arr2Start]){\n            if(arr1[arr1Start] < arr2[arr2Start]){\n                finalArr.push(arr1[arr1Start]);\n                arr1Start = arr1Start + 1;\n            } else {\n                finalArr.push(arr2[arr2Start]);\n                arr2Start = arr2Start + 1;\n            } \n        } else if(arr1[arr1Start] && !arr2[arr2Start]){\n                finalArr.push(arr1[arr1Start]);\n                arr1Start = arr1Start + 1;\n        } else if(arr2[arr2Start] && !arr1[arr1Start]){\n            finalArr.push(arr2[arr2Start]);\n            arr2Start = arr2Start + 1;\n        }\n        \n    }\n    return finalArr;\n}",
      "diff": 1,
      "imp": 1,
      "cate": [
        "arr",
        "sort"
      ],
      "id": 13
    },
    {
      "subject": "algo",
      "title": "Cafe Order Checker",
      "ques": "Given all three arrays, write a function to check that my service is first-come, first-served.\nAll food should come out in the same order customer requested it",
      "links": [],
      "tags": [
        {
          "name": "Interview Cake"
        }
      ],
      "ans": "/* As an example,\n   Take Out Orders: [1, 3, 5]\n    Dine In Orders: [2, 4, 6]\n     Served Orders: [1, 2, 4, 6, 5, 3]\nwould not be first-come, first-served, since order 3 was requested before order 5 but order 5 was served first.\n\nBut,\n    T\n    ake Out Orders: [17, 8, 24]\n    Dine In Orders: [12, 19, 2]\n     Served Orders: [17, 8, 12, 19, 24, 2]\n\nwould be first-come, first-served.\n\nNote - Order numbers are arbitrary. They do not have to be in increasing order. */\n\nfunction isFirstComeFirstServed(takeOutOrders, dineInOrders, servedOrders) {\n    var takeOutOrdersIndex = 0;\n    var dineInOrdersIndex = 0;\n    var takeOutOrdersMaxIndex = takeOutOrders.length - 1;\n    var dineInOrdersMaxIndex = dineInOrders.length - 1;\n    for (var i = 0; i < servedOrders.length; i++) {\n        var order = servedOrders[i];\n        // if we still have orders in takeOutOrders\n        // and the current order in takeOutOrders is the same // as the current order in servedOrders\n        if (takeOutOrdersIndex <= takeOutOrdersMaxIndex &&\n            order === takeOutOrders[takeOutOrdersIndex]) {\n            takeOutOrdersIndex++;\n            // if we still have orders in dineInOrders\n            // and the current order in dineInOrders is the same // as the current order in servedOrders\n        } else if (dineInOrdersIndex <= dineInOrdersMaxIndex &&\n            order === dineInOrders[dineInOrdersIndex]) {\n            dineInOrdersIndex++;\n            // if the current order in servedOrders doesn't match the current\n            // order in takeOutOrders or dineInOrders, then we're not serving first-come, // first-served\n        } else {\n            return false;\n        }\n    }\n    // check for any extra orders at the end of takeOutOrders or dineInOrders if (dineInOrdersIndex != dineInOrders.length ||\n    takeOutOrdersIndex != takeOutOrders.length) {\n    return false;\n}\n// all orders in servedOrders have been \"accounted for\" // so we're serving first-come, first-served!\nreturn true;\n}",
      "diff": 1,
      "imp": 1,
      "cate": [
        "arr",
        "sort",
        "greed"
      ],
      "id": 14
    },
    {
      "subject": "algo",
      "title": "Inflight Entertainment",
      "ques": "Write a function that takes an integer (in minutes) and an array of integers movieLengths(in minutes) and returns a boolean indicating whether there are two numbers in movieLengths whose sum equals flightLength",
      "links": [],
      "tags": [
        {
          "name": "Interview Cake"
        }
      ],
      "ans": "\nfunction canTwoMoviesFillFlight(movieLengths, flightLength) {\n    // Movie lengths we've seen so far \n    const movieLengthsSeen = new Set();\n    for (let i = 0; i < movieLengths.length; i++) {\n        const firstMovieLength = movieLengths[i];\n        const matchingSecondMovieLength = flightLength - firstMovieLength;\n        if (movieLengthsSeen.has(matchingSecondMovieLength)) {\n            return true;\n        }\n        movieLengthsSeen.add(firstMovieLength);\n    }\n    // We never found a match, so return false\n    return false;\n}",
      "diff": 1,
      "imp": 1,
      "cate": [
        "obj"
      ],
      "id": 15
    },
    {
      "subject": "algo",
      "title": "Word Cloud Data",
      "ques": "Write code that takes a long string and builds its word cloud data in a map , where the keys are words and the values are the number of times the words occurred.",
      "links": [],
      "tags": [
        {
          "name": "Interview Cake"
        }
      ],
      "ans": "\nclass WordCloudData {\n    constructor(inputString) {\n        this.wordsToCounts = new Map();\n        this.populateWordsToCounts(inputString);\n    }\n    populateWordsToCounts(inputString) {\n        // Iterates over each character in the input string, splitting \n        // words and passing them to this.addWordToMap()\n        let currentWordStartIndex = 0;\n        let currentWordLength = 0;\n        for (let i = 0; i < inputString.length; i++) {\n            const character = inputString.charAt(i);\n            // If we reached the end of the string we check if the last \n            // character is a letter and add the last word to our map \n            if (i === inputString.length - 1) {\n                if (this.isLetter(character)) {\n                    currentWordLength += 1;\n                }\n                if (currentWordLength > 0) {\n                    const word = inputString.slice(currentWordStartIndex, currentWordStartIndex + currentWordLength);\n                    this.addWordToMap(word);\n                }\n                \n            // If we reach a space or emdash we know we're at the end of a word\n            // so we add it to our map and reset our current word\n            } else if (character === ' ' || character === '\\u2014') {\n            if (currentWordLength > 0) {\n                const word = inputString.slice(currentWordStartIndex,\n                    currentWordStartIndex + currentWordLength);\n                this.addWordToMap(word);\n                currentWordLength = 0;\n            }\n            // We want to make sure we split on ellipses so if we get two periods in\n            // a row we add the current word to our map and reset our current word\n        } else if (character === '.') {\n            if (i < inputString.length - 1 && inputString.charAt(i + 1) === '.') {\n                if (currentWordLength > 0) {\n                    const word = inputString.slice(currentWordStartIndex, currentWordStartIndex + currentWordLength);\n                    this.addWordToMap(word);\n                    currentWordLength = 0;\n                    tpircSavaJ\n                }\n            }\n            // If the character is a letter or an apostrophe, we add it to our current word\n        } else if (this.isLetter(character) || character === '\\'') {\n            if (currentWordLength === 0) {\n                currentWordStartIndex = i;\n            }\n            currentWordLength += 1;\n            // If the character is a hyphen, we want to check if it's surrounded by letters\n            // if it is, we add it to our current word\n        } else if (character === '-') {\n            if (i > 0 && this.isLetter(inputString.charAt(i - 1)) && this.isLetter(inputString.charAt(i + 1))) {\n                currentWordLength += 1;\n            } else {\n                if (currentWordLength > 0) {\n                    const word = inputString.slice(currentWordStartIndex, currentWordStartIndex + currentWordLength);\n                    this.addWordToMap(word);\n                    currentWordLength = 0;\n                }\n            }\n        }\n    }\n}\naddWordToMap(word) {\n    let newCount;\n    // If the word is already in the map we increment its count if (this.wordsToCounts.has(word)) {\n    newCount = this.wordsToCounts.get(word) + 1;\n    this.wordsToCounts.set(word, newCount);\n    // If a lowercase version is in the map, we know our input word must be uppercase \n    // but we only include uppercase words if they're always uppercase\n    // so we just increment the lowercase version's count\n} else if (this.wordsToCounts.has(word.toLowerCase())) {\n    newCount = this.wordsToCounts.get(word.toLowerCase()) + 1;\n    this.wordsToCounts.set(word.toLowerCase(), newCount);\n    // If an uppercase version is in the map, we know our input word must be lowercase.\n    // since we only include uppercase words if they're always uppercase, we add the // lowercase version and give it the uppercase version's count\n} else if (this.wordsToCounts.has(this.capitalize(word))) {\n    newCount = this.wordsToCounts.get(this.capitalize(word)) + 1;\n\n    this.wordsToCounts.set(word, newCount);\n    this.wordsToCounts.delete(this.capitalize(word));\n    // Otherwise, the word is not in the map at all, lowercase or uppercase\n    // so we add it to the map\n} else {\n    this.wordsToCounts.set(word, 1);\n}\n}\ncapitalize(word) {\n    return word.charAt(0).toUpperCase() + word.slice(1);\n}\nisLetter(character) {\n    return 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.indexOf(character) >= 0;\n}\n}",
      "diff": 1,
      "imp": 1,
      "cate": [
        "obj"
      ],
      "id": 16
    },
    {
      "subject": "algo",
      "title": "Apple Stocks",
      "ques": "Write an efficient function that takes stock_prices and returns the best profit I could have made from one purchase and one sale of one share of Apple stock yesterday",
      "links": [],
      "tags": [
        {
          "name": "Interview Cake"
        }
      ],
      "ans": "/**\n * .\n\nFor example:\n\n  stock_prices = [10, 7, 5, 8, 11, 9]\n\nget_max_profit(stock_prices)\n# Returns 6 (buying for $5 and selling for $11)\n\nPython 3.6\nNo \"shorting\"—you need to buy before you can sell. Also, you can't buy and sell in the same time step—at least 1 minute has to pass.\n */\n\nfunction getMaxProfit(stockPrices) {\n    let maxProfit = 0;\n  \n    // Go through every time\n    for (let outerTime = 0; outerTime < stockPrices.length; outerTime++) {\n  \n      // For each time, go through every other time\n      for (let innerTime = 0; innerTime < stockPrices.length; innerTime++) {\n  \n        // For each pair, find the earlier and later times\n        const earlierTime = Math.min(outerTime, innerTime);\n        const laterTime = Math.max(outerTime, innerTime);\n  \n        // And use those to find the earlier and later prices\n        const earlierPrice = stockPrices[earlierTime];\n        const laterPrice = stockPrices[laterTime];\n  \n        // See what our profit would be if we bought at the\n        // min price and sold at the current price\n        const potentialProfit = laterPrice - earlierPrice;\n  \n        // Update maxProfit if we can do better\n        maxProfit = Math.max(maxProfit, potentialProfit);\n      }\n    }\n  \n    return maxProfit;\n  }\n\n\n\n\n  ",
      "diff": 1,
      "imp": 1,
      "cate": [
        "greed"
      ],
      "id": 17
    },
    {
      "subject": "algo",
      "title": "Highest Product of 3",
      "ques": "Given an array of integers, find the highest product you can get from three of the integers.",
      "links": [],
      "tags": [
        {
          "name": "Interview Cake"
        }
      ],
      "ans": "function highestProductOf3(arrayOfInts) {\n    if (arrayOfInts.length < 3) {\n        throw new Error(\"Less than 3 items!\");\n    }\n    // We're going to start at the 3rd item (at index 2)\n    // So pre-populate highests and lowests based on the first 2 items\n    // We could also start these as null and check below if they're set\n    // but this is arguably cleaner\n    let highest = Math.max(arrayOfInts[0], arrayOfInts[1]);\n    let lowest = Math.min(arrayOfInts[0], arrayOfInts[1]);\n\n    let highestProductOf2 = arrayOfInts[0] * arrayOfInts[1];\n\n    let lowestProductOf2 = arrayOfInts[0] * arrayOfInts[1];\n    // Except this one--we pre-populate it for the first *3* items\n    // This means in our first pass it'll check against itself, which is fine\n    let highestProductOf3 = arrayOfInts[0] * arrayOfInts[1] * arrayOfInts[2];\n    // Walk through items, starting at index 2\n    for (let i = 2; i < arrayOfInts.length; i++) {\n        const current = arrayOfInts[i];\n        // Do we have a new highest product of 3?\n        // It's either the current highest\n        // or the current times the highest product of two\n        // or the current times the lowest product of two\n        highestProductOf3 = Math.max(\n            highestProductOf3,\n            current * highestProductOf2,\n            current * lowestProductOf2\n        );\n        // Do we have a new highest product of two?\n        highestProductOf2 = Math.max(\n            highestProductOf2,\n            current * highest,\n            current * lowest\n        );\n        // Do we have a new lowest product of two?\n        lowestProductOf2 = Math.min(\n            lowestProductOf2,\n            current * highest,\n            current * lowest\n        );\n        // Do we have a new highest?\n\n        highest = Math.max(highest, current);\n        // Do we have a new lowest?\n        lowest = Math.min(lowest, current);\n    }\n    return highestProductOf3;\n}",
      "diff": 1,
      "imp": 1,
      "cate": [
        "greed"
      ],
      "id": 18
    },
    {
      "subject": "algo",
      "title": "Product of All Other Numbers",
      "ques": "You have an array of integers, and for each index you want to find the product of every integer except the integer at that index",
      "links": [
        {
          "name": "https://www.interviewcake.com/question/javascript/product-of-other-numbers?course=fc1&section=greedy"
        }
      ],
      "tags": [
        {
          "name": "Interview Cake"
        }
      ],
      "ans": "function getProductsOfAllIntsExceptAtIndex(intArray) {\n    if (intArray.length < 2) {\n        throw new Error('Getting the product of numbers at other indices requires at least 2 numbers');\n    }\n\n    const productsOfAllIntsExceptAtIndex = [];\n\n    // For each integer, we find the product of all the integers\n    // before it, storing the total product so far each time\n    let productSoFar = 1;\n    for (let i = 0; i < intArray.length; i++) {\n        productsOfAllIntsExceptAtIndex[i] = productSoFar;\n        productSoFar *= intArray[i];\n    }\n\n    // For each integer, we find the product of all the integers\n    // after it. since each index in products already has the\n    // product of all the integers before it, now we're storing\n    // the total product of all other integers\n    productSoFar = 1;\n    for (let j = intArray.length - 1; j >= 0; j--) {\n        productsOfAllIntsExceptAtIndex[j] *= productSoFar;\n        productSoFar *= intArray[j];\n    }\n\n    return productsOfAllIntsExceptAtIndex;\n}",
      "diff": 1,
      "imp": 1,
      "cate": [
        "greed"
      ],
      "id": 19
    },
    {
      "subject": "algo",
      "title": "Merging Meeting Times",
      "ques": "Write a function mergeRanges() that takes an array of multiple meeting time ranges and returns an array of condensed ranges.",
      "links": [],
      "tags": [
        {
          "name": "Interview Cake"
        }
      ],
      "ans": "\nfunction mergeRanges(meetings) {\n  // Create a deep copy of the meetings array\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign# \n  const meetingsCopy = JSON.parse(JSON.stringify(meetings));\n  \n  // Sort by start time\n  const sortedMeetings = meetingsCopy.sort((a, b) => {\n    return a.startTime - b.startTime;\n  });\n  \n  // Initialize mergedMeetings with the earliest meeting\n  const mergedMeetings = [sortedMeetings[0]];\n  for (let i = 1; i < sortedMeetings.length; i++) {\n    const currentMeeting = sortedMeetings[i];\n    const lastMergedMeeting = mergedMeetings[mergedMeetings.length - 1];\n    \n    // If the current meeting overlaps with the last merged meeting, use the\n    // later end time of the two\n    if (currentMeeting.startTime <= lastMergedMeeting.endTime) {\n      lastMergedMeeting.endTime = Math.max(\n        lastMergedMeeting.endTime,\n        currentMeeting.endTime\n      );\n    } else {\n      // Add the current meeting since it doesn't overlap\n      mergedMeetings.push(currentMeeting);\n    }\n  }\n  return mergedMeetings;\n}\n",
      "diff": 1,
      "imp": 1,
      "cate": [
        "arr",
        "sort",
        "datetime"
      ],
      "id": 20
    },
    {
      "subject": "algo",
      "title": "Find Rotation Point",
      "ques": "Write a function for finding the index of the \"rotation point",
      "links": [],
      "tags": [
        {
          "name": "Interview Cake"
        }
      ],
      "ans": "/*\nconst words = [\n  'ptolemaic',\n  'retrograde',\n  'supplant',\n  'undulate',\n  'xenoepist',\n  'asymptote',  // <-- rotates here!\n  'babka',\n  'banoffee',\n  'engender',\n  'karpatka',\n  'othellolagkage',\n];\n*/\n\nfunction findRotationPoint(words) {\n  const firstWord = words[0];\n  let floorIndex = 0;\n  let ceilingIndex = words.length - 1;\n  while (floorIndex < ceilingIndex) {\n    // Guess a point halfway between floor and ceiling\n    const guessIndex = Math.floor(floorIndex + (ceilingIndex - floorIndex) / 2);\n    // If guess comes after first word or is the first word\n    if (words[guessIndex] >= firstWord) {\n      // Go right\n      floorIndex = guessIndex;\n    } else {\n      // Go left\n      ceilingIndex = guessIndex;\n    }\n    // If floor and ceiling have converged\n    if (floorIndex + 1 === ceilingIndex) {\n      // Between floor and ceiling is where we flipped to the beginning\n      // so ceiling is alphabetically first\n      break;\n    }\n  }\n  return ceilingIndex;\n}\n",
      "diff": 1,
      "imp": 1,
      "cate": [
        "search"
      ],
      "id": 21
    },
    {
      "subject": "algo",
      "title": "Find Repeat, Space Edition",
      "ques": "Write a function which finds an integer that appears more than once in our array(If there are multiple duplicates, you only need to find one of them)",
      "links": [],
      "tags": [
        {
          "name": "Interview Cake"
        },
        {
          "name": "Duplicate inArray"
        }
      ],
      "ans": "function findRepeat(numbers) {\n  let floor = 1;\n  let ceiling = numbers.length - 1;\n  while (floor < ceiling) {\n    // Divide our range 1..n into an upper range and lower range\n    // (such that they don't overlap)\n    // lower range is floor..midpoint\n    // upper range is midpoint+1..ceiling\n    const midpoint = Math.floor(floor + (ceiling - floor) / 2);\n    const lowerRangeFloor = floor;\n    const lowerRangeCeiling = midpoint;\n    const upperRangeFloor = midpoint + 1;\n    const upperRangeCeiling = ceiling;\n    const distinctPossibleIntegersInLowerRange = lowerRangeCeiling - lowerRangeFloor + 1;\n\n    // Count number of items in lower range\n    let itemsInLowerRange = 0;\n    numbers.forEach((item) => {\n      // Is it in the lower range?\n      if (item >= lowerRangeFloor && item <= lowerRangeCeiling) {\n        itemsInLowerRange += 1;\n      }\n    });\n    if (itemsInLowerRange > distinctPossibleIntegersInLowerRange) {\n      // There must be a duplicate in the lower range\n      // so use the same approach iteratively on that range\n      floor = lowerRangeFloor;\n      ceiling = lowerRangeCeiling;\n    } else {\n      // There must be a duplicate in the upper range\n      // so use the same approach iteratively on that range \n      floor = upperRangeFloor;\n      ceiling = upperRangeCeiling;\n    }\n  }\n  // Floor and ceiling have converged\n  // We found a number that repeats!\n  return floor;\n}\n",
      "diff": 1,
      "imp": 1,
      "cate": [
        "search"
      ],
      "id": 22
    },
    {
      "subject": "algo",
      "title": "Recursive String Permutations",
      "ques": "Write a recursive function for generating all permutations of an input string. Return them as a set.",
      "links": [],
      "tags": [
        {
          "name": "Interview Cake"
        },
        {
          "name": "Permutations"
        }
      ],
      "ans": "function getPermutations(string) {\n  // Base case\n  if (string.length <= 1) {\n    return new Set([string]);\n  }\n  const allCharsExceptLast = string.slice(0, -1);\n  const lastChar = string[string.length - 1];\n\n  // Recursive call: get all possible permutations for all chars except last\n  const permutationsOfAllCharsExceptLast = getPermutations(allCharsExceptLast);\n\n  // Put the last char in all possible positions for each of the above permutations\n  const permutations = new Set();\n  permutationsOfAllCharsExceptLast.forEach(\n    (permutationOfAllCharsExceptLast) => {\n      for (\n        let position = 0;\n        position <= allCharsExceptLast.length;\n        position++\n      ) {\n        const permutation =\n          permutationOfAllCharsExceptLast.slice(0, position) + lastChar + pe;\n        permutations.add(permutation);\n      }\n    }\n  );\n  return permutations;\n}\n",
      "diff": 1,
      "imp": 1,
      "cate": [
        "dynamic",
        "recursion"
      ],
      "id": 23
    },
    {
      "subject": "algo",
      "title": "Syllabus :",
      "ques": "",
      "links": [],
      "tags": [
        {
          "name": "Interview Cake"
        }
      ],
      "ans": "\n1.Array and string manipulation\n    a.Merging Meeting Times\n    b.Reverse String in Place\n    c.Reverse Words\n    d.Merge Sorted Arrays\n    e.Cafe Order Checker\n    \n2.Hashing & Hash tables\n    a.Inflight Entertainment\n    b.Permutation Palindrome\n    c. Word Cloud Data\n    \n3.Greedy algorithms\n    a.Apple Stocks\n    b.Highest Product of 3\n    c.Product of All Other Numbers\n    d.Cafe Order Checker\n    e.In-place shuffle\n    \n4.Sorting, searching and logarithms\n    a.Find Rotation Point\n    b.Find Repeat, Space Edition\n    c.Top Scores\n    d.Merging Meeting Times\n    \n5.Trees and graphs\n    a.Balanced Binary Tree\n    b.Binary Search Tree Checker\n    c.2nd Largest Item in a Binary Search Tree\n    d.Graph Coloring\n    e.Mesh Message\n    f.Find Repeat, Space Edition BEAST MODE\n    \n6.Dynamic Programming and recursion\n    a.Recursive String Permutations\n    b.Compute the nth Fibonacci Number\n    c.Making Change\n    d.The Cake Thief\n    e.Balanced Binary Tree\n    f.Binary Search Tree Checker\n    g.2nd Largest Item in a Binary Search Tree\n    \n7.Queues and stacks\n    a.Largest stack\n    b.Implement a Queue with two stacks\n    c.Parenthesis Matching\n    d.Bracket Validator\n    \n8.Linked lists\n    a.Delete Node\n    b.Does this Linked List Have a cycle\n    c.Reverse a linked list\n    d.Kth to last Node in as Singly-Linked list\n    e.Find Repeat, Space Edition BEAST MODE\n    \n    \n    \n    \n    \n    \n    \n    \n    ",
      "diff": 1,
      "imp": 1,
      "cate": [
        "syllabus"
      ],
      "id": 24
    },
    {
      "subject": "algo",
      "title": "Type of array and its maximum element",
      "ques": "Given an array, it can be of 4 types. \n(a) Ascending \n(b) Descending \n(c) Ascending Rotated \n(d) Descending Rotated \nFind out which kind of array it is and return the maximum of that array.",
      "links": [
        {
          "name": "https://www.geeksforgeeks.org/type-array-maximum-element/"
        }
      ],
      "tags": [
        {
          "name": "GeeksforGeeks"
        },
        {
          "name": "Amazon"
        }
      ],
      "ans": "\n/*\nInput :  arr[] = { 2, 1, 5, 4, 3}\nOutput : Descending rotated with maximum element 5\n\nInput :  arr[] = { 3, 4, 5, 1, 2}\nOutput : Ascending rotated with maximum element 5\n*/\n\nfunction findType(arr, n) {\n  // To store the minimum and the maximum\n  // element from the array\n  let min_element = Number.MAX_VALUE,\n    max_element = Number.MIN_VALUE;\n\n  // To store the first and the last occurrences\n  // of the minimum and the maximum\n  // element from the array\n  let min_index1 = -1,\n    max_index1 = -1,\n    max_index2 = -1,\n    min_index2 = -1;\n\n  for (let i = 0; i < n; i++) {\n    // If new minimum is found\n    if (arr[i] < min_element) {\n      // Update the minimum so far\n      // and its occurrences\n      min_element = arr[i];\n      min_index1 = i;\n      min_index2 = i;\n    }\n\n    // If current element is equal the found\n    // minimum so far then update the last\n    // occurrence of the minimum element\n    else if (arr[i] == min_element){\n     // console.log(\"ELSE Min :: i :: arr[i] ::::\", i,\"::\",arr[i]);  \n      min_index2 = i;\n    } \n\n    // If new maximum is found\n    if (arr[i] > max_element) {\n      // Update the maximum so far\n      // and its occurrences\n      max_element = arr[i];\n      max_index1 = i;\n      max_index2 = i;\n    }\n\n    // If current element is equal the found\n    // maximum so far then update the last\n    // occurrence of the maximum element\n    else if (arr[i] == max_element) {\n      max_index2 = i;\n    }\n  }\n  \n  console.log(\"MIN :: min_element :: min_index1 :: min_index2 ::::\", min_element,\"::\",min_index1,\"::\",min_index2);\n  console.log(\"MAX :: max_element :: max_index1 :: max_index2 ::::\", max_element,\"::\",max_index1,\"::\",max_index2);\n\n  // First occurrence of minimum element is at the\n  // beginning of the array and the last occurrence\n  // of the maximum element is at the end of the\n  // array then the array is sorted in ascending\n  // For example, {1, 1, 1, 2, 3, 4, 5, 6, 6, 6}\n  if (min_index1 == 0 && max_index2 == n - 1) {\n    console.log(\"Ascending with maximum\" + \" element = \" + max_element);\n  }\n\n  // First occurrence of maximum element is at the\n  // beginning of the array and the last occurrence\n  // of the minimum element is at the end of the\n  // array then the array is sorted in descending\n  // For example, {6, 6, 6, 5, 4, 3, 2, 1, 1, 1}\n  else if (max_index1 == 0 && min_index2 == n - 1) {\n    console.log(\"Descending with maximum\" + \" element = \" + max_element);\n  }\n\n  // First occurrence of maximum element is equal\n  // to the last occurrence of the minimum element + 1\n  // then the array is descending and rotated\n  // For example, {3, 2, 1, 1, 1, 6, 6, 6, 5, 4}\n  else if (max_index1 == min_index2 + 1) {\n    console.log(\n      \"Descending rotated with \" + \"maximum element = \" + max_element\n    );\n  }\n\n  // First occurrence of minimum element is equal\n  // to the last occurrence of the maximum element + 1\n  // then the array is ascending and rotated\n  // For example, {4, 5, 6, 6, 6, 1, 1, 1, 2, 3}\n  else {\n    console.log(\"Ascending rotated with \" + \"maximum element = \" + max_element);\n  }\n}\n\nlet arr1 = [5,4,3,2,1];\n\nlet arr4 = [4, 5, 6, 6, 6, 1, 1, 1, 2, 3];\n\nfindType(arr1, arr1.length);\n",
      "diff": 4,
      "imp": 4,
      "cate": [
        "arr"
      ],
      "id": 25
    },
    {
      "subject": "algo",
      "title": "Rearrange characters in a string such that no two adjacent are same",
      "ques": "Given a string with repeated characters, the task is to rearrange characters in a string so that no two adjacent characters are same.\nNote : It may be assumed that the string has only lowercase English alphabets.",
      "links": [
        {
          "name": "https://www.geeksforgeeks.org/rearrange-characters-string-no-two-adjacent/"
        }
      ],
      "tags": [
        {
          "name": "GeeksforGeeks"
        },
        {
          "name": "Amazon"
        }
      ],
      "ans": "\n/*\nInput: aaabc \nOutput: abaca \n\nInput: aaabb\nOutput: ababa \n\nInput: aa \nOutput: Not Possible\n\nInput: aaaabc \nOutput: Not Possible\n*/",
      "diff": 4,
      "imp": 3,
      "cate": [
        "str"
      ],
      "id": 26
    },
    {
      "subject": "algo",
      "title": "List of problems sorted in increasing order of difficulty",
      "ques": "",
      "links": [
        {
          "name": "https://www.ideserve.co.in/learn/dynamic-programming-interview-questions"
        }
      ],
      "tags": [
        {
          "name": "ideserve"
        }
      ],
      "ans": "",
      "diff": 3,
      "imp": 4,
      "cate": [
        "dynamic"
      ],
      "id": 27
    },
    {
      "subject": "algo",
      "title": "Binary Search",
      "ques": "",
      "links": [],
      "tags": [
        {
          "name": "General"
        }
      ],
      "ans": "  function binarySearch(key, inputArray) {\r\n      var low  = 0,\r\n          high = inputArray.length - 1,\r\n          mid;\r\n\r\n      while (low <= high) {\r\n          mid = low + (high - low) / 2;\r\n          if ((mid % 1) > 0) { mid = Math.ceil(mid); }\r\n\r\n          if (key < inputArray[mid]) { high = mid - 1; }\r\n          else if (key > inputArray[mid]) { low = mid + 1; }\r\n          else { return mid; }\r\n      }\r\n\r\n      return null;\r\n  }\r\n\r\n  // run the binary search\r\n  binarySearch(3, [1,2,4]); //returns null\r\n  binarySearch(3, [2,3,5]); //returns 1",
      "diff": 1,
      "imp": 1,
      "cate": [
        "search"
      ],
      "id": 28
    },
    {
      "subject": "algo",
      "title": "Merge Sort",
      "ques": "",
      "links": [
        {
          "name": "https://stackabuse.com/merge-sort-in-javascript/"
        }
      ],
      "tags": [
        {
          "name": "General"
        }
      ],
      "ans": "function mergeSort(array) {\n  const half = array.length / 2\n  \n  // Base case or terminating case\n  if(array.length < 2){\n    return array \n  }\n  \n  const left = array.splice(0, half)\n  return merge(mergeSort(left),mergeSort(array))\n}\n\nfunction merge(left, right) {\n    let arr = []\n    // Break out of loop if any one of the array gets empty\n    while (left.length && right.length) {\n        // Pick the smaller among the smallest element of left and right sub arrays \n        if (left[0] < right[0]) {\n            arr.push(left.shift())  \n        } else {\n            arr.push(right.shift()) \n        }\n    }\n    \n    // Concatenating the leftover elements\n    // (in case we didn't go through the entire left or right array)\n    return [ ...arr, ...left, ...right ]\n}",
      "diff": 1,
      "imp": 1,
      "cate": [
        "sort"
      ],
      "id": 29
    },
    {
      "subject": "algo",
      "title": "All possible permutation of number",
      "ques": "",
      "links": [
        {
          "name": "https://medium.com/weekly-webtips/step-by-step-guide-to-array-permutation-using-recursion-in-javascript-4e76188b88ff"
        }
      ],
      "tags": [
        {
          "name": "General"
        },
        {
          "name": "Permutations"
        }
      ],
      "ans": "var permArr = [],\n  usedChars = [];\n\nfunction permute(input) {\n  var i, ch;\n  for (i = 0; i < input.length; i++) {\n    ch = input.splice(i, 1)[0];\n    usedChars.push(ch);\n    if (input.length == 0) {\n      permArr.push(usedChars.slice());\n    }\n    permute(input);\n    input.splice(i, 0, ch);\n    usedChars.pop();\n  }\n  return permArr\n};\n\n\nconsole.log(permute([5, 3, 7, 1]));",
      "diff": 1,
      "imp": 1,
      "cate": [
        "str",
        "arr"
      ],
      "id": 30
    },
    {
      "subject": "algo",
      "title": "Array Rotation",
      "ques": "",
      "links": [],
      "tags": [
        {
          "name": "General"
        }
      ],
      "ans": "function rotatedArray(arr, times){\n   times = times % arr.length;\n   for(var i=arr.length -1; i>arr.length - 1 - times; i--){\n       var pop = arr.pop();\n       arr.unshift(pop);\n   }\n   return arr;\n}\n\n\nfunction reverseArray(arr, startIndex, EndIndex){\n  /* if(startIndex === EndIndex){\n       return \"Not valid start and end Index\";\n   }*/\n\n\n   while(startIndex < EndIndex){\n       var temp = arr[startIndex];\n       arr[startIndex]  = arr[EndIndex];\n       arr[EndIndex] = temp;\n\n\n       startIndex = startIndex + 1;\n       EndIndex = EndIndex - 1;\n  }\n\n\n   return arr;\n\n\n}\n\n\nfunction rotatedArray2(arr, times){\n    times = times % arr.length;\n   var splitArrayIndex = arr.length - times - 1;\n\n\n   arr = reverseArray(arr, 0,splitArrayIndex);\n   arr = reverseArray(arr, splitArrayIndex + 1, arr.length - 1);\n   arr = reverseArray(arr, 0, arr.length - 1);\n\n\n   return arr;\n}\n\n\n\n\nvar arr = [1,2,3,4,5, 6,7,8];\nrotatedArray(arr, 3);\n\n\nvar arr = [1,2,3,4,5, 6,7,8];\nreverseArray(arr, 5,7);",
      "diff": 1,
      "imp": 1,
      "cate": [
        "arr"
      ],
      "id": 31
    },
    {
      "subject": "algo",
      "title": "Segregate 0's, 1's and 2's together in an array[O(n)](Dutch National Flag Problem)",
      "ques": "",
      "links": [
        {
          "name": "https://www.youtube.com/watch?v=BOt1DAvR0zI&ab_channel=VivekanandKhyade-AlgorithmEveryDay"
        }
      ],
      "tags": [
        {
          "name": "Dutch National Flag Problem"
        },
        {
          "name": "youtube"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": [
        "arr"
      ],
      "id": 32
    },
    {
      "subject": "algo",
      "title": "Find the missing number in the increasing sequence",
      "ques": "",
      "links": [
        {
          "name": "https://www.youtube.com/watch?v=yxYCiBja8_s&ab_channel=IDeserve"
        }
      ],
      "tags": [
        {
          "name": "ideserve"
        }
      ],
      "ans": "// total = n*(n+1)/2",
      "diff": 1,
      "imp": 1,
      "cate": [
        "arr"
      ],
      "id": 33
    },
    {
      "subject": "algo",
      "title": "Remove duplicate in Array in single loop",
      "ques": "",
      "links": [],
      "tags": [
        {
          "name": "Duplicate inArray"
        }
      ],
      "ans": "var t1 = [1,2,3,2,3];\n\nfunction duplicateInArray(){\n  for(var i=0; i<t1.length; i++){\n    if(t1[Math.abs(t1[i])] > 0){\n      t1[Math.abs(t1[i])] = -t1[Math.abs(t1[i])];\n    }else{\n      console.log('Element '+Math.abs(t1[i])+' duplicate at '+i);\n    }\n  }\n}",
      "diff": 1,
      "imp": 1,
      "cate": [
        "arr"
      ],
      "id": 34
    }
  ],
  "js": [
    {
      "subject": "js",
      "title": "Throttling and Debouncing in JavaScript",
      "ques": "",
      "links": [
        {
          "name": "https://codeburst.io/throttling-and-debouncing-in-javascript-b01cad5c8edf"
        }
      ],
      "tags": [
        {
          "name": "Debouncing and Throttling"
        }
      ],
      "ans": "-> Throttling and debouncing give us control over the rate at which a function is called. \n\n-> They are especially useful when we are dealing with event handler assignments. There are scenarios where we may invoke functions when it isn’t necessary.",
      "diff": 4,
      "imp": 4,
      "cate": [
        "Events"
      ],
      "id": 1
    },
    {
      "subject": "js",
      "title": "JS: Basics and Tricky Questions",
      "ques": "",
      "links": [
        {
          "name": "http://www.thatjsdude.com/interview/js2.html#nullVsUndefined"
        }
      ],
      "tags": [
        {
          "name": "Basics & Tricky"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": [
        "General"
      ],
      "id": 2
    },
    {
      "subject": "js",
      "title": "Practical Uses for Closures",
      "ques": "",
      "links": [
        {
          "name": "https://medium.com/@dis_is_patrick/practical-uses-for-closures-c65640ae7304#.fva9ii8od"
        }
      ],
      "tags": [
        {
          "name": "closures"
        }
      ],
      "ans": "function pam() {\n    var name = \"Pam Beesly\";\n    function displayName() {\n        alert (name);\n    }\n    displayName(); \n}\npam();\n",
      "diff": 3,
      "imp": 4,
      "cate": [
        "general"
      ],
      "id": 3
    },
    {
      "subject": "js",
      "title": "JavaScript scope",
      "ques": "Everything you wanted to know about JavaScript scope",
      "links": [
        {
          "name": "https://ultimatecourses.com/blog/everything-you-wanted-to-know-about-javascript-scope"
        }
      ],
      "tags": [
        {
          "name": "scoping"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 3,
      "cate": [
        "general"
      ],
      "id": 4
    },
    {
      "subject": "js",
      "title": "javaScript promises",
      "ques": "",
      "links": [
        {
          "name": "https://www.youtube.com/watch?v=s6SH72uAn3Q#t=6.819927&ab_channel=techsith"
        },
        {
          "name": "https://www.youtube.com/watch?v=104J7_HyaG4&ab_channel=DecypherMedia"
        }
      ],
      "tags": [
        {
          "name": "Promises"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": [
        "general",
        "Async"
      ],
      "id": 5
    },
    {
      "subject": "js",
      "title": "How new operator works ?",
      "ques": "",
      "links": [
        {
          "name": "https://ianbicking.org/blog/2013/04/new-considered-harmful.html"
        },
        {
          "name": "https://www.liip.ch/en/blog/why-i-dont-use-the-javascript-new-keyword"
        }
      ],
      "tags": [
        {
          "name": "New operator"
        }
      ],
      "ans": "\nfunction new_(constructor /* plus a variable number of arguments */) {\n  var newObject = Object.create(constructor.prototype);\n  // This gets the varargs after `constructor`:\n  var restArgs = Array.prototype.slice.call(arguments, 1);\n  var result = constructor.apply(newObject, restArgs);\n  if (typeof result == \"object\") {\n    // If the function returns something, ignore newObject\n    return result;\n  }\n  return newObject;\n}",
      "diff": 1,
      "imp": 3,
      "cate": [
        "general"
      ],
      "id": 6
    },
    {
      "subject": "js",
      "title": "Shadow Dom in HTML Introduction tutorial",
      "ques": "",
      "links": [
        {
          "name": "https://www.youtube.com/watch?v=SDs4xmMcVS4&ab_channel=techsith"
        },
        {
          "name": "https://css-tricks.com/modular-future-web-components/"
        }
      ],
      "tags": [
        {
          "name": "Shadow DOM"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": [
        "general",
        "DOM"
      ],
      "id": 7
    },
    {
      "subject": "js",
      "title": "What is Functional Programming?",
      "ques": "",
      "links": [
        {
          "name": "https://medium.com/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0"
        }
      ],
      "tags": [
        {
          "name": "Functional Programming"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 3,
      "cate": [
        "general",
        "Code Pattern"
      ],
      "id": 8
    },
    {
      "subject": "js",
      "title": "Js Eventloop",
      "ques": "",
      "links": [
        {
          "name": "https://blog.carbonfive.com/the-javascript-event-loop-explained/"
        }
      ],
      "tags": [
        {
          "name": "Eventloop"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 4,
      "cate": [
        "general",
        "async"
      ],
      "id": 9
    },
    {
      "subject": "js",
      "title": "JavaScript Design Patterns",
      "ques": "",
      "links": [
        {
          "name": "https://www.digitalocean.com/community/tutorial_series/javascript-design-patterns"
        }
      ],
      "tags": [],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": [
        "code_pattern"
      ],
      "id": 10
    },
    {
      "subject": "js",
      "title": "Javascript OOPs implementation",
      "ques": "",
      "links": [
        {
          "name": "https://www.educative.io/blog/object-oriented-programming"
        },
        {
          "name": "https://www.youtube.com/watch?v=S1dWe3f2zm0&ab_channel=Telusko"
        },
        {
          "name": "https://www.youtube.com/watch?v=vDJpGenyHaA&ab_channel=TraversyMedia"
        },
        {
          "name": "https://www.youtube.com/watch?v=PFmuCDHHpwk&ab_channel=ProgrammingwithMosh"
        }
      ],
      "tags": [
        {
          "name": "OOPs"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 4,
      "cate": [
        "general",
        "oops"
      ],
      "id": 11
    }
  ],
  "es6": [],
  "ts": [],
  "html": [],
  "css": [],
  "ng": [],
  "react": [],
  "redux": [],
  "performance": [],
  "sd": [],
  "shell": [
    {
      "subject": "shell",
      "title": "Check Disk Space",
      "ques": "How to Check Disk Space in Linux?",
      "links": [
        {
          "name": "https://phoenixnap.com/kb/linux-check-disk-space"
        }
      ],
      "tags": [
        {
          "name": "General"
        },
        {
          "name": "linux"
        }
      ],
      "ans": "\n/*\nThe df command stands for disk free, and it shows you the amount of space taken up by \ndifferent drives. By default, df displays values in 1-kilobyte blocks.\n*/\ndf\n\n\n/* Display Usage in Megabytes and Gigabytes */\ndf -h\n\n/* Understanding the Output Format */\n\nFilesystem         Size      Used     Avail    Use%    Mounted on\n\nudev               210M        0        210M     0%       /dev\n\ntmpfs              49M       1004K      48M      3%       /run\n\n/dev/sda2          7.9G       4.3G      3.2G     58%      /\n\nYour output may have more entries. The columns should be self-explanatory:-\n\nFilesystem – This is the name of each particular drive. This includes physical hard drives, \nlogical (partitioned) drives, and virtual or temporary drives.\nSize – The size of the filesystem.\nUsed – Amount of space used on each filesystem.\nAvail – The amount of unused (free) space on the filesystem.\nUse% – Shows the percent of the disk used.\nMounted on – This is the directory where the file system is located. This is also sometimes \ncalled a mount point.\n\nThe list of filesystems includes your physical hard drive, as well as virtual hard drives:-\n\n/dev/sda2 – This is your physical hard drive. It may be listed as /sda1, /sda0, or you may even have more than one. /dev stands for device.\nudev – This is a virtual directory for the /dev directory. This is part of the Linux operating \nsystem.\ntmpfs – You may have several of these. These are used by /run and other Linux processes as \ntemporary filesystems for running the operating system. For example, the tmpfs /run/lock is \nused to create lockfiles. These are the files that prevent multiple users from changing the \nsame file at the same time.\n\n\n/* Display a Specific File System */\ndf -h /dev/sda2\ndf -h /\n\n/* Display File Systems by Type */\ndf -ht ext4\n\n/* Display Size in 1000 Instead of 1024 */\ndu -H\n\n/*\nCheck Disk Space in Linux With du Command\nThe du command displays disk usage\n*/\ndu\ndu -h\ndu -hs\ndu -hs /etc\nsudo du -hs /etc\n\n\n/* HELP */\ndf --help or du --help.\n",
      "diff": 1,
      "imp": 1,
      "cate": [
        "disk"
      ],
      "id": 1
    }
  ],
  "git": [],
  "py": [],
  "java": [],
  "oth": []
}