{
  "users": [
    {
      "id": 1,
      "user": "admin@admin.com",
      "password": "admin"
    }
  ],
  "subjects": [
    {
      "id": 1,
      "name": "Algorithm",
      "key": "algo"
    },
    {
      "id": 2,
      "name": "Javascript",
      "key": "js"
    },
    {
      "id": 3,
      "name": "ES6",
      "key": "es6"
    },
    {
      "id": 16,
      "name": "Nodejs",
      "key": "node"
    },
    {
      "id": 4,
      "name": "Typescript",
      "key": "ts"
    },
    {
      "id": 5,
      "name": "HTML",
      "key": "html"
    },
    {
      "id": 6,
      "name": "CSS",
      "key": "css"
    },
    {
      "id": 7,
      "name": "Angular",
      "key": "ng"
    },
    {
      "id": 8,
      "name": "React",
      "key": "react"
    },
    {
      "id": 9,
      "name": "Redux",
      "key": "redux"
    },
    {
      "id": 10,
      "name": "Performance",
      "key": "performance"
    },
    {
      "id": 11,
      "name": "System Design",
      "key": "sd"
    },
    {
      "id": 12,
      "name": "Shell Scripting",
      "key": "shell"
    },
    {
      "id": 13,
      "name": "GIT",
      "key": "git"
    },
    {
      "id": 14,
      "name": "Python",
      "key": "py"
    },
    {
      "id": 13,
      "name": "Java",
      "key": "java"
    },
    {
      "id": 15,
      "name": "Others",
      "key": "oth"
    }
  ],
  "categories": [
    {
      "id": "1",
      "name": "String",
      "key": "str",
      "sub": "algo"
    },
    {
      "id": "2",
      "name": "Array",
      "key": "arr",
      "sub": "algo"
    },
    {
      "id": "3",
      "name": "Object|Hash|Mapping",
      "key": "obj",
      "sub": "algo"
    },
    {
      "id": "4",
      "name": "Search",
      "key": "search",
      "sub": "algo"
    },
    {
      "id": "5",
      "name": "Sorting",
      "key": "sort",
      "sub": "algo"
    },
    {
      "id": "51",
      "name": "Logarithms",
      "key": "log",
      "sub": "algo"
    },
    {
      "id": "6",
      "name": "Greedy",
      "key": "greed",
      "sub": "algo"
    },
    {
      "id": "61",
      "name": "Dynamic",
      "key": "dynamic",
      "sub": "algo"
    },
    {
      "id": "62",
      "name": "Recursion",
      "key": "recursion",
      "sub": "algo"
    },
    {
      "id": "7",
      "name": "Tree",
      "key": "tree",
      "sub": "algo"
    },
    {
      "id": "8",
      "name": "Date & Time",
      "key": "datetime",
      "sub": "algo"
    },
    {
      "id": "9",
      "name": "Queue & Stack",
      "key": "queueStack",
      "sub": "algo"
    },
    {
      "id": "10",
      "name": "Syllabus",
      "key": "syllabus",
      "sub": "algo"
    },
    {
      "id": "11",
      "name": "Disk",
      "key": "disk",
      "sub": "shell"
    },
    {
      "name": "Events",
      "key": "events",
      "sub": "js",
      "id": "K8hwS7H"
    },
    {
      "name": "General",
      "key": "general",
      "sub": "js",
      "id": "fLxAGlD"
    },
    {
      "name": "Async",
      "key": "async",
      "sub": "js",
      "id": "CcPDpap"
    },
    {
      "name": "DOM",
      "key": "dom",
      "sub": "js",
      "id": "VcHWFpK"
    },
    {
      "name": "Code Pattern",
      "key": "code_pattern",
      "sub": "js",
      "id": "QkRqsfU"
    },
    {
      "name": "OOPs",
      "key": "oops",
      "sub": "js",
      "id": "S9Hc3Bu"
    },
    {
      "name": "Linked-list",
      "key": "linked-list",
      "sub": "algo",
      "id": "O-ZdpST"
    },
    {
      "name": "Tree",
      "key": "tree",
      "sub": "algo",
      "id": "3Ss3hC0"
    },
    {
      "name": "Caching",
      "key": "caching",
      "sub": "sd",
      "id": "0bEDgF0"
    },
    {
      "name": "General",
      "key": "general",
      "sub": "sd",
      "id": "-5xn9uI"
    },
    {
      "name": "General",
      "key": "general",
      "sub": "es6",
      "id": "vAzKM_l"
    },
    {
      "name": "Numbers",
      "key": "numbers",
      "sub": "algo",
      "id": "Pfw11Yu"
    },
    {
      "name": "General",
      "key": "general",
      "sub": "git",
      "id": "i0w-jut"
    },
    {
      "name": "Framework",
      "key": "framework",
      "sub": "node",
      "id": "o8_tryU"
    },
    {
      "name": "Node Core",
      "key": "node_core",
      "sub": "node",
      "id": "CF6SBM8"
    },
    {
      "name": "Library",
      "key": "library",
      "sub": "node",
      "id": "NZSriI4"
    }
  ],
  "algo": [
    {
      "subject": "algo",
      "title": null,
      "ques": "First non repeating character in a string",
      "links": [
        {
          "name": "https://www.youtube.com/watch?v=U7rxgP-fp8E"
        }
      ],
      "tags": [
        {
          "name": "ideserve"
        }
      ],
      "ans": "\n\nconst firstNonRepeat = (str) => {\n   let strMap = {};\n   for(let i = 0; i < str.length; i++){\n       let char = str[i];\n       if(char in strMap){\n           delete strMap[char];\n       } else {\n           strMap[char] = 1;\n       }\n   }\n   return Object.keys(strMap)[0];\n }\n \n const st = \"ADBCGHIEFKJLADTVDERFSWVGHQWCNOPENSMSJWIERTFB\";\n \n console.log(firstNonRepeat(st));",
      "diff": 2,
      "imp": 2,
      "cate": [
        "str"
      ],
      "id": 5
    },
    {
      "subject": "algo",
      "ques": "Anagram Pattern Search",
      "links": [
        {
          "name": "https://www.youtube.com/watch?v=h4MCwdfZZas"
        },
        {
          "name": "https://www.geeksforgeeks.org/anagram-substring-search-search-permutations/"
        }
      ],
      "tags": [
        {
          "name": "ideserve"
        }
      ],
      "ans": "const anyAnagram = (txt, pattern) => {\n       // create map for pattern\n       let pattMap = {};\n       for(let i=0; i<pattern.length; i++){\n           let ch = pattern[i];\n           pattMap[ch] = (ch in pattMap) ? ++pattMap[ch] : 1;\n       }\n \n       // method to compare two maps\n       const compareMap = (m1, m2) => {\n           // console.log(\"compareMap :: m1 : m2 ::::\", m1, \"::\", m2)\n           let keys1 = Object.keys(m1);\n           let keys2 = Object.keys(m2);\n           if(keys1.length != keys2.length){\n               return false;\n           }\n \n           for(let k of keys1){\n               if(m1[k] !== m2[k]){\n               return false;\n               }\n           }\n           return true;\n       }\n \n       let txtMap = {};\n       let insertCount = 0;\n       let firstCharIdx = 0;\n      \n       for(let i=0; i< txt.length; i++){\n           let ch = txt[i];\n           // text map\n           txtMap[ch] = (ch in txtMap) ? ++txtMap[ch] : 1;\n           ++insertCount;\n \n           // If insertion in map == pattern length\n           if(insertCount == pattern.length){\n               // compare map\n               let result = compareMap(pattMap, txtMap);\n               if(result){\n                   return \"Present\";\n               } else {\n                   // remove first ch\n                   let firstChar = txt[firstCharIdx];\n                   if(txtMap[firstChar] == 1){\n                       delete txtMap[firstChar];\n                   } else {\n                       txtMap[firstChar] = txtMap[firstChar] - 1;\n                   }\n                   // reduce insertion count\n                   insertCount = insertCount - 1;\n                   // increase firsr char index\n                   firstCharIdx = firstCharIdx + 1;\n               }\n           }\n       }\n       return \"Not Present\"\n   }\n \n   let Text = \"ideserve\";\n   let Pattern = \"veer\";\n \n   console.log(anyAnagram(Text, Pattern));",
      "diff": 1,
      "imp": 1,
      "cate": [
        "str"
      ],
      "id": 6
    },
    {
      "subject": "algo",
      "title": "In-Place Shuffle",
      "ques": "RANDOMLY Reorder Array in O(N)",
      "links": [
        {
          "name": "https://www.youtube.com/watch?v=CoI4S7z1E1Y&ab_channel=CSDojo"
        }
      ],
      "tags": [
        {
          "name": "Lynda"
        },
        {
          "name": "fisher-yates shuffle"
        },
        {
          "name": "Interview Cake"
        }
      ],
      "ans": "\nconst reorder = (arr) => {\n    for(let i=arr.length; i>0; i--){\n    \tconst randomIdx = Math.floor(Math.random() * i);\n    \t// swap\n    \tlet temp = arr[randomIdx];\n    \tarr[randomIdx] = arr[i-1];\n    \tarr[i-1] = temp;\n    }\n    return arr;\n}\n\nconsole.log(reorder([1,0,3,9,2]));",
      "diff": 1,
      "imp": 3,
      "cate": [
        "arr",
        "greed"
      ],
      "id": 7
    },
    {
      "subject": "algo",
      "title": "Top Scores",
      "ques": "Write a function that takes: an array of unsortedScores & the highestPossibleScore in the game and returns a sorted array of scores in less than O(n lg n) time.",
      "links": [],
      "tags": [
        {
          "name": "Interview Cake"
        }
      ],
      "ans": "\n/*\nconst unsortedScores = [37, 89, 41, 65, 91, 53];\nconst HIGHEST_POSSIBLE_SCORE = 100;\n\nsortScores(unsortedScores, HIGHEST_POSSIBLE_SCORE);\nreturns [91, 89, 65, 53, 41, 37]\n*/\n\nfunction sortScores(unorderedScores, highestPossibleScore) {\n\n    // Array of 0s at indices 0..highestPossibleScore\n    const scoreCounts = new Array(highestPossibleScore + 1).fill(0);\n  \n    // Populate scoreCounts\n    unorderedScores.forEach(score => {\n      scoreCounts[score]++;\n    });\n  \n    // Populate the final sorted array\n    const sortedScores = [];\n  \n    // For each item in scoreCounts\n    for (let score = highestPossibleScore; score >= 0; score--) {\n      const count = scoreCounts[score];\n  \n      // For the number of times the item occurs\n      for (let time = 0; time < count; time++) {\n        sortedScores.push(score);\n      }\n    }\n  \n    return sortedScores;\n  }",
      "diff": 2,
      "imp": 4,
      "cate": [
        "sort"
      ],
      "id": 8
    },
    {
      "subject": "algo",
      "title": "Bracket Validator",
      "ques": "Check for Balanced Brackets in an expression",
      "links": [],
      "tags": [
        {
          "name": "Interview Cake"
        }
      ],
      "ans": "\n/*\nInput: exp = “[()]{}{[()()]()}” \nOutput: true\n\nInput: exp = “[(])” \nOutput: false \n\n*/\nfunction isValid(code) {\n\n    const openersToClosers = {\n      '(': ')',\n      '[': ']',\n      '{': '}',\n    };\n  \n    const openers = new Set(['(', '[', '{']);\n    const closers = new Set([')', ']', '}']);\n  \n    const openersStack = [];\n  \n    for (let i = 0; i < code.length; i++) {\n      const char = code.charAt(i);\n  \n      if (openers.has(char)) {\n        openersStack.push(char);\n      } else if (closers.has(char)) {\n        if (!openersStack.length) {\n          return false;\n        }\n        const lastUnclosedOpener = openersStack.pop();\n  \n        // If this closer doesn't correspond to the most recently\n        // seen unclosed opener, short-circuit, returning false\n        if (openersToClosers[lastUnclosedOpener] !== char) {\n          return false;\n        }\n      }\n    }\n    return openersStack.length === 0;\n  }",
      "diff": 4,
      "imp": 4,
      "cate": [
        "queueStack"
      ],
      "id": 9
    },
    {
      "subject": "algo",
      "title": "Permutation Palindrome",
      "ques": "Write an efficient function that checks whether any permutation of an input string is a palindrome.",
      "links": [],
      "tags": [
        {
          "name": "Interview Cake"
        }
      ],
      "ans": "/**\n * \n * Write an efficient function that checks whether any permutation of an input string is a palindrome. \n\nYou can assume the input string only contains lowercase letters.\n\nExamples:\n\n\"civic\" should return true\n\"ivicc\" should return true\n\"civil\" should return false\n\"livci\" should return false\n */\n  function hasPalindromePermutation(theString) {\n\n    // Track characters we've seen an odd number of times\n    const unpairedCharacters = new Set();\n  \n    for (let char of theString) {\n      if (unpairedCharacters.has(char)) {\n        unpairedCharacters.delete(char);\n      } else {\n        unpairedCharacters.add(char);\n      }\n    }\n  \n    // The string has a palindrome permutation if it\n    // has one or zero characters without a pair\n    return unpairedCharacters.size <= 1; // If str length is odd, there will be 1\n  }",
      "diff": 3,
      "imp": 4,
      "cate": [
        "obj"
      ],
      "id": 10
    },
    {
      "subject": "algo",
      "title": "Reverse String",
      "ques": "Take an array of characters and reverse the letter",
      "links": [],
      "tags": [
        {
          "name": "Interview Cake"
        }
      ],
      "ans": "\nfunction reverse(arrayOfChars) {\n  let leftIndex = 0;\n  let rightIndex = arrayOfChars.length - 1;\n  while (leftIndex < rightIndex) {\n    // Swap characters\n    const temp = arrayOfChars[leftIndex];\n    arrayOfChars[leftIndex] = arrayOfChars[rightIndex];\n    arrayOfChars[rightIndex] = temp;\n    // Move towards middle leftIndex++; rightIndex--;\n  }\n}\n\n\n// OR\n\nconst reverse2 = (arrayOfChars) => {\n   let s = 0;\n   let m = Math.ceil(arrayOfChars.length / 2);\n\n   while(s < m){\n      let e = (arrayOfChars.length - 1) - s;\n      [arrayOfChars[s], arrayOfChars[e]] = [arrayOfChars[e], arrayOfChars[s]];\n      s = s + 1;\n   }\n   return arrayOfChars;\n}",
      "diff": 1,
      "imp": 1,
      "cate": [
        "str"
      ],
      "id": 11
    },
    {
      "subject": "algo",
      "title": "Reverse Words",
      "ques": "Takes a message as an array of characters and reverses the order of the words in place",
      "links": [],
      "tags": [
        {
          "name": "Interview Cake"
        }
      ],
      "ans": "/*\nconst message = [ 'c', 'a', 'k', 'e', ' ', 'p', 'o', 'u', 'n', 'd', ' ',\n's', 't', 'e', 'a', 'l' ]; \n\nreverseWords(message);\n\nconsole.log(message.join('')); \n// Prints: 'steal pound cake'\n*/\n\nfunction reverseWords(message) {\n  // First we reverse all the characters in the entire message reverseCharacters(message, 0, message.length - 1);\n  // This gives us the right word order\n  // but with each word backward\n  // Now we'll make the words forward again // by reversing each word's characters\n  // We hold the index of the *start* of the current word // as we look for the *end* of the current word\n  let currentWordStartIndex = 0;\n  for (let i = 0; i <= message.length; i++) {\n    // Found the end of the current word!\n    if (i === message.length || message[i] === \" \") {\n      // If we haven't exhausted the string our\n      // next word's start is one character ahead reverseCharacters(message, currentWordStartIndex, i - 1); currentWordStartIndex = i + 1;\n    }\n  }\n}\nfunction reverseCharacters(message, leftIndex, rightIndex) {\n  // Walk towards the middle, from both sides\n  while (leftIndex < rightIndex) {\n    // Swap the left char and right char const temp = message[leftIndex]; message[leftIndex] = message[rightIndex]; message[rightIndex] = temp;\n    leftIndex++;\n    rightIndex--;\n  }\n}\n",
      "diff": 1,
      "imp": 1,
      "cate": [
        "str"
      ],
      "id": 12
    },
    {
      "subject": "algo",
      "title": "Merge Sorted Arrays",
      "ques": "We have our lists of orders sorted numerically already, in arrays. Write a function to merge our arrays of orders into one sorted array",
      "links": [],
      "tags": [
        {
          "name": "Interview Cake"
        }
      ],
      "ans": "\n/* const myArray = [3, 4, 6, 10, 11, 15];\nconst alicesArray = [1, 5, 8, 12, 14, 19];\nconsole.log(mergeArrays(myArray, alicesArray));\n// logs [1, 3, 4, 5, 6, 8, 10, 11, 12, 14, 15, 19] \n*/\n\nfunction mergeArrays(myArray, alicesArray) {\n  // Set up our mergedArray const mergedArray = [];\n  let currentIndexAlices = 0;\n  let currentIndexMine = 0;\n  let currentIndexMerged = 0;\n  while (currentIndexMerged < myArray.length + alicesArray.length) {\n    const isMyArrayExhausted = currentIndexMine >= myArray.length;\n    const isAlicesArrayExhausted = currentIndexAlices >= alicesArray.length;\n    // Case: next comes from my array\n    // My array must not be exhausted, and EITHER:\n    // 1) Alice's array IS exhausted, or\n    // 2) The current element in my array is less\n    // than the current element in Alice's array\n    if (\n      !isMyArrayExhausted && (isAlicesArrayExhausted ||\n        myArray[currentIndexMine] < alicesArray[currentIndexAlices])\n    ) {\n      mergedArray[currentIndexMerged] = myArray[currentIndexMine];\n      currentIndexMine++;\n      // Case: next comes from Alice's array \n      \n    } else {\n      mergedArray[currentIndexMerged] = alicesArray[currentIndexAlices];\n      currentIndexAlices++;\n    }\n    currentIndexMerged++;\n  }\n  return mergedArray;\n}\n\n\n// OR\n\nconst mergeArrays = (arr1, arr2) => {\n    let finalArr = [];\n    let arr1Start = 0;\n    let arr2Start = 0;\n    while(arr1Start < arr1.length || arr2Start < arr2.length){\n        if(arr1[arr1Start] && arr2[arr2Start]){\n            if(arr1[arr1Start] < arr2[arr2Start]){\n                finalArr.push(arr1[arr1Start]);\n                arr1Start = arr1Start + 1;\n            } else {\n                finalArr.push(arr2[arr2Start]);\n                arr2Start = arr2Start + 1;\n            } \n        } else if(arr1[arr1Start] && !arr2[arr2Start]){\n                finalArr.push(arr1[arr1Start]);\n                arr1Start = arr1Start + 1;\n        } else if(arr2[arr2Start] && !arr1[arr1Start]){\n            finalArr.push(arr2[arr2Start]);\n            arr2Start = arr2Start + 1;\n        }\n        \n    }\n    return finalArr;\n}",
      "diff": 1,
      "imp": 1,
      "cate": [
        "arr",
        "sort"
      ],
      "id": 13
    },
    {
      "subject": "algo",
      "title": "Cafe Order Checker",
      "ques": "Given all three arrays, write a function to check that my service is first-come, first-served.\nAll food should come out in the same order customer requested it",
      "links": [],
      "tags": [
        {
          "name": "Interview Cake"
        }
      ],
      "ans": "/* As an example,\n   Take Out Orders: [1, 3, 5]\n    Dine In Orders: [2, 4, 6]\n     Served Orders: [1, 2, 4, 6, 5, 3]\nwould not be first-come, first-served, since order 3 was requested before order 5 but order 5 was served first.\n\nBut,\n    T\n    ake Out Orders: [17, 8, 24]\n    Dine In Orders: [12, 19, 2]\n     Served Orders: [17, 8, 12, 19, 24, 2]\n\nwould be first-come, first-served.\n\nNote - Order numbers are arbitrary. They do not have to be in increasing order. */\n\nfunction isFirstComeFirstServed(takeOutOrders, dineInOrders, servedOrders) {\n    var takeOutOrdersIndex = 0;\n    var dineInOrdersIndex = 0;\n    var takeOutOrdersMaxIndex = takeOutOrders.length - 1;\n    var dineInOrdersMaxIndex = dineInOrders.length - 1;\n    for (var i = 0; i < servedOrders.length; i++) {\n        var order = servedOrders[i];\n        // if we still have orders in takeOutOrders\n        // and the current order in takeOutOrders is the same // as the current order in servedOrders\n        if (takeOutOrdersIndex <= takeOutOrdersMaxIndex &&\n            order === takeOutOrders[takeOutOrdersIndex]) {\n            takeOutOrdersIndex++;\n            // if we still have orders in dineInOrders\n            // and the current order in dineInOrders is the same // as the current order in servedOrders\n        } else if (dineInOrdersIndex <= dineInOrdersMaxIndex &&\n            order === dineInOrders[dineInOrdersIndex]) {\n            dineInOrdersIndex++;\n            // if the current order in servedOrders doesn't match the current\n            // order in takeOutOrders or dineInOrders, then we're not serving first-come, // first-served\n        } else {\n            return false;\n        }\n    }\n    // check for any extra orders at the end of takeOutOrders or dineInOrders if (dineInOrdersIndex != dineInOrders.length ||\n    takeOutOrdersIndex != takeOutOrders.length) {\n    return false;\n}\n// all orders in servedOrders have been \"accounted for\" // so we're serving first-come, first-served!\nreturn true;\n}",
      "diff": 1,
      "imp": 1,
      "cate": [
        "arr",
        "sort",
        "greed"
      ],
      "id": 14
    },
    {
      "subject": "algo",
      "title": "Inflight Entertainment",
      "ques": "Write a function that takes an integer (in minutes) and an array of integers movieLengths(in minutes) and returns a boolean indicating whether there are two numbers in movieLengths whose sum equals flightLength",
      "links": [],
      "tags": [
        {
          "name": "Interview Cake"
        }
      ],
      "ans": "\nfunction canTwoMoviesFillFlight(movieLengths, flightLength) {\n    // Movie lengths we've seen so far \n    const movieLengthsSeen = new Set();\n    for (let i = 0; i < movieLengths.length; i++) {\n        const firstMovieLength = movieLengths[i];\n        const matchingSecondMovieLength = flightLength - firstMovieLength;\n        if (movieLengthsSeen.has(matchingSecondMovieLength)) {\n            return true;\n        }\n        movieLengthsSeen.add(firstMovieLength);\n    }\n    // We never found a match, so return false\n    return false;\n}",
      "diff": 1,
      "imp": 1,
      "cate": [
        "obj"
      ],
      "id": 15
    },
    {
      "subject": "algo",
      "title": "Word Cloud Data",
      "ques": "Write code that takes a long string and builds its word cloud data in a map , where the keys are words and the values are the number of times the words occurred.",
      "links": [],
      "tags": [
        {
          "name": "Interview Cake"
        }
      ],
      "ans": "\nclass WordCloudData {\n    constructor(inputString) {\n        this.wordsToCounts = new Map();\n        this.populateWordsToCounts(inputString);\n    }\n    populateWordsToCounts(inputString) {\n        // Iterates over each character in the input string, splitting \n        // words and passing them to this.addWordToMap()\n        let currentWordStartIndex = 0;\n        let currentWordLength = 0;\n        for (let i = 0; i < inputString.length; i++) {\n            const character = inputString.charAt(i);\n            // If we reached the end of the string we check if the last \n            // character is a letter and add the last word to our map \n            if (i === inputString.length - 1) {\n                if (this.isLetter(character)) {\n                    currentWordLength += 1;\n                }\n                if (currentWordLength > 0) {\n                    const word = inputString.slice(currentWordStartIndex, currentWordStartIndex + currentWordLength);\n                    this.addWordToMap(word);\n                }\n                \n            // If we reach a space or emdash we know we're at the end of a word\n            // so we add it to our map and reset our current word\n            } else if (character === ' ' || character === '\\u2014') {\n            if (currentWordLength > 0) {\n                const word = inputString.slice(currentWordStartIndex,\n                    currentWordStartIndex + currentWordLength);\n                this.addWordToMap(word);\n                currentWordLength = 0;\n            }\n            // We want to make sure we split on ellipses so if we get two periods in\n            // a row we add the current word to our map and reset our current word\n        } else if (character === '.') {\n            if (i < inputString.length - 1 && inputString.charAt(i + 1) === '.') {\n                if (currentWordLength > 0) {\n                    const word = inputString.slice(currentWordStartIndex, currentWordStartIndex + currentWordLength);\n                    this.addWordToMap(word);\n                    currentWordLength = 0;\n                    tpircSavaJ\n                }\n            }\n            // If the character is a letter or an apostrophe, we add it to our current word\n        } else if (this.isLetter(character) || character === '\\'') {\n            if (currentWordLength === 0) {\n                currentWordStartIndex = i;\n            }\n            currentWordLength += 1;\n            // If the character is a hyphen, we want to check if it's surrounded by letters\n            // if it is, we add it to our current word\n        } else if (character === '-') {\n            if (i > 0 && this.isLetter(inputString.charAt(i - 1)) && this.isLetter(inputString.charAt(i + 1))) {\n                currentWordLength += 1;\n            } else {\n                if (currentWordLength > 0) {\n                    const word = inputString.slice(currentWordStartIndex, currentWordStartIndex + currentWordLength);\n                    this.addWordToMap(word);\n                    currentWordLength = 0;\n                }\n            }\n        }\n    }\n}\naddWordToMap(word) {\n    let newCount;\n    // If the word is already in the map we increment its count if (this.wordsToCounts.has(word)) {\n    newCount = this.wordsToCounts.get(word) + 1;\n    this.wordsToCounts.set(word, newCount);\n    // If a lowercase version is in the map, we know our input word must be uppercase \n    // but we only include uppercase words if they're always uppercase\n    // so we just increment the lowercase version's count\n} else if (this.wordsToCounts.has(word.toLowerCase())) {\n    newCount = this.wordsToCounts.get(word.toLowerCase()) + 1;\n    this.wordsToCounts.set(word.toLowerCase(), newCount);\n    // If an uppercase version is in the map, we know our input word must be lowercase.\n    // since we only include uppercase words if they're always uppercase, we add the // lowercase version and give it the uppercase version's count\n} else if (this.wordsToCounts.has(this.capitalize(word))) {\n    newCount = this.wordsToCounts.get(this.capitalize(word)) + 1;\n\n    this.wordsToCounts.set(word, newCount);\n    this.wordsToCounts.delete(this.capitalize(word));\n    // Otherwise, the word is not in the map at all, lowercase or uppercase\n    // so we add it to the map\n} else {\n    this.wordsToCounts.set(word, 1);\n}\n}\ncapitalize(word) {\n    return word.charAt(0).toUpperCase() + word.slice(1);\n}\nisLetter(character) {\n    return 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.indexOf(character) >= 0;\n}\n}",
      "diff": 1,
      "imp": 1,
      "cate": [
        "obj"
      ],
      "id": 16
    },
    {
      "subject": "algo",
      "title": "Apple Stocks",
      "ques": "Write an efficient function that takes stock_prices and returns the best profit I could have made from one purchase and one sale of one share of Apple stock yesterday",
      "links": [],
      "tags": [
        {
          "name": "Interview Cake"
        }
      ],
      "ans": "/**\n * .\n\nFor example:\n\n  stock_prices = [10, 7, 5, 8, 11, 9]\n\nget_max_profit(stock_prices)\n# Returns 6 (buying for $5 and selling for $11)\n\nPython 3.6\nNo \"shorting\"—you need to buy before you can sell. Also, you can't buy and sell in the same time step—at least 1 minute has to pass.\n */\n\nfunction getMaxProfit(stockPrices) {\n    let maxProfit = 0;\n  \n    // Go through every time\n    for (let outerTime = 0; outerTime < stockPrices.length; outerTime++) {\n  \n      // For each time, go through every other time\n      for (let innerTime = 0; innerTime < stockPrices.length; innerTime++) {\n  \n        // For each pair, find the earlier and later times\n        const earlierTime = Math.min(outerTime, innerTime);\n        const laterTime = Math.max(outerTime, innerTime);\n  \n        // And use those to find the earlier and later prices\n        const earlierPrice = stockPrices[earlierTime];\n        const laterPrice = stockPrices[laterTime];\n  \n        // See what our profit would be if we bought at the\n        // min price and sold at the current price\n        const potentialProfit = laterPrice - earlierPrice;\n  \n        // Update maxProfit if we can do better\n        maxProfit = Math.max(maxProfit, potentialProfit);\n      }\n    }\n  \n    return maxProfit;\n  }\n\n\n\n\n  ",
      "diff": 1,
      "imp": 1,
      "cate": [
        "greed"
      ],
      "id": 17
    },
    {
      "subject": "algo",
      "title": "Highest Product of 3",
      "ques": "Given an array of integers, find the highest product you can get from three of the integers.",
      "links": [],
      "tags": [
        {
          "name": "Interview Cake"
        }
      ],
      "ans": "function highestProductOf3(arrayOfInts) {\n    if (arrayOfInts.length < 3) {\n        throw new Error(\"Less than 3 items!\");\n    }\n    // We're going to start at the 3rd item (at index 2)\n    // So pre-populate highests and lowests based on the first 2 items\n    // We could also start these as null and check below if they're set\n    // but this is arguably cleaner\n    let highest = Math.max(arrayOfInts[0], arrayOfInts[1]);\n    let lowest = Math.min(arrayOfInts[0], arrayOfInts[1]);\n\n    let highestProductOf2 = arrayOfInts[0] * arrayOfInts[1];\n\n    let lowestProductOf2 = arrayOfInts[0] * arrayOfInts[1];\n    // Except this one--we pre-populate it for the first *3* items\n    // This means in our first pass it'll check against itself, which is fine\n    let highestProductOf3 = arrayOfInts[0] * arrayOfInts[1] * arrayOfInts[2];\n    // Walk through items, starting at index 2\n    for (let i = 2; i < arrayOfInts.length; i++) {\n        const current = arrayOfInts[i];\n        // Do we have a new highest product of 3?\n        // It's either the current highest\n        // or the current times the highest product of two\n        // or the current times the lowest product of two\n        highestProductOf3 = Math.max(\n            highestProductOf3,\n            current * highestProductOf2,\n            current * lowestProductOf2\n        );\n        // Do we have a new highest product of two?\n        highestProductOf2 = Math.max(\n            highestProductOf2,\n            current * highest,\n            current * lowest\n        );\n        // Do we have a new lowest product of two?\n        lowestProductOf2 = Math.min(\n            lowestProductOf2,\n            current * highest,\n            current * lowest\n        );\n        // Do we have a new highest?\n\n        highest = Math.max(highest, current);\n        // Do we have a new lowest?\n        lowest = Math.min(lowest, current);\n    }\n    return highestProductOf3;\n}",
      "diff": 1,
      "imp": 1,
      "cate": [
        "greed"
      ],
      "id": 18
    },
    {
      "subject": "algo",
      "title": "Product of All Other Numbers",
      "ques": "You have an array of integers, and for each index you want to find the product of every integer except the integer at that index",
      "links": [
        {
          "name": "https://www.interviewcake.com/question/javascript/product-of-other-numbers?course=fc1&section=greedy"
        }
      ],
      "tags": [
        {
          "name": "Interview Cake"
        }
      ],
      "ans": "function getProductsOfAllIntsExceptAtIndex(intArray) {\n    if (intArray.length < 2) {\n        throw new Error('Getting the product of numbers at other indices requires at least 2 numbers');\n    }\n\n    const productsOfAllIntsExceptAtIndex = [];\n\n    // For each integer, we find the product of all the integers\n    // before it, storing the total product so far each time\n    let productSoFar = 1;\n    for (let i = 0; i < intArray.length; i++) {\n        productsOfAllIntsExceptAtIndex[i] = productSoFar;\n        productSoFar *= intArray[i];\n    }\n\n    // For each integer, we find the product of all the integers\n    // after it. since each index in products already has the\n    // product of all the integers before it, now we're storing\n    // the total product of all other integers\n    productSoFar = 1;\n    for (let j = intArray.length - 1; j >= 0; j--) {\n        productsOfAllIntsExceptAtIndex[j] *= productSoFar;\n        productSoFar *= intArray[j];\n    }\n\n    return productsOfAllIntsExceptAtIndex;\n}",
      "diff": 1,
      "imp": 1,
      "cate": [
        "greed"
      ],
      "id": 19
    },
    {
      "subject": "algo",
      "title": "Merging Meeting Times",
      "ques": "Write a function mergeRanges() that takes an array of multiple meeting time ranges and returns an array of condensed ranges.",
      "links": [],
      "tags": [
        {
          "name": "Interview Cake"
        }
      ],
      "ans": "\nfunction mergeRanges(meetings) {\n  // Create a deep copy of the meetings array\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign# \n  const meetingsCopy = JSON.parse(JSON.stringify(meetings));\n  \n  // Sort by start time\n  const sortedMeetings = meetingsCopy.sort((a, b) => {\n    return a.startTime - b.startTime;\n  });\n  \n  // Initialize mergedMeetings with the earliest meeting\n  const mergedMeetings = [sortedMeetings[0]];\n  for (let i = 1; i < sortedMeetings.length; i++) {\n    const currentMeeting = sortedMeetings[i];\n    const lastMergedMeeting = mergedMeetings[mergedMeetings.length - 1];\n    \n    // If the current meeting overlaps with the last merged meeting, use the\n    // later end time of the two\n    if (currentMeeting.startTime <= lastMergedMeeting.endTime) {\n      lastMergedMeeting.endTime = Math.max(\n        lastMergedMeeting.endTime,\n        currentMeeting.endTime\n      );\n    } else {\n      // Add the current meeting since it doesn't overlap\n      mergedMeetings.push(currentMeeting);\n    }\n  }\n  return mergedMeetings;\n}\n",
      "diff": 1,
      "imp": 1,
      "cate": [
        "arr",
        "sort",
        "datetime"
      ],
      "id": 20
    },
    {
      "subject": "algo",
      "title": "Find Rotation Point",
      "ques": "Write a function for finding the index of the \"rotation point",
      "links": [],
      "tags": [
        {
          "name": "Interview Cake"
        }
      ],
      "ans": "/*\nconst words = [\n  'ptolemaic',\n  'retrograde',\n  'supplant',\n  'undulate',\n  'xenoepist',\n  'asymptote',  // <-- rotates here!\n  'babka',\n  'banoffee',\n  'engender',\n  'karpatka',\n  'othellolagkage',\n];\n*/\n\nfunction findRotationPoint(words) {\n  const firstWord = words[0];\n  let floorIndex = 0;\n  let ceilingIndex = words.length - 1;\n  while (floorIndex < ceilingIndex) {\n    // Guess a point halfway between floor and ceiling\n    const guessIndex = Math.floor(floorIndex + (ceilingIndex - floorIndex) / 2);\n    // If guess comes after first word or is the first word\n    if (words[guessIndex] >= firstWord) {\n      // Go right\n      floorIndex = guessIndex;\n    } else {\n      // Go left\n      ceilingIndex = guessIndex;\n    }\n    // If floor and ceiling have converged\n    if (floorIndex + 1 === ceilingIndex) {\n      // Between floor and ceiling is where we flipped to the beginning\n      // so ceiling is alphabetically first\n      break;\n    }\n  }\n  return ceilingIndex;\n}\n",
      "diff": 1,
      "imp": 1,
      "cate": [
        "search"
      ],
      "id": 21
    },
    {
      "subject": "algo",
      "title": "Find Repeat, Space Edition",
      "ques": "Write a function which finds an integer that appears more than once in our array(If there are multiple duplicates, you only need to find one of them)",
      "links": [],
      "tags": [
        {
          "name": "Interview Cake"
        },
        {
          "name": "Duplicate inArray"
        }
      ],
      "ans": "function findRepeat(numbers) {\n  let floor = 1;\n  let ceiling = numbers.length - 1;\n  while (floor < ceiling) {\n    // Divide our range 1..n into an upper range and lower range\n    // (such that they don't overlap)\n    // lower range is floor..midpoint\n    // upper range is midpoint+1..ceiling\n    const midpoint = Math.floor(floor + (ceiling - floor) / 2);\n    const lowerRangeFloor = floor;\n    const lowerRangeCeiling = midpoint;\n    const upperRangeFloor = midpoint + 1;\n    const upperRangeCeiling = ceiling;\n    const distinctPossibleIntegersInLowerRange = lowerRangeCeiling - lowerRangeFloor + 1;\n\n    // Count number of items in lower range\n    let itemsInLowerRange = 0;\n    numbers.forEach((item) => {\n      // Is it in the lower range?\n      if (item >= lowerRangeFloor && item <= lowerRangeCeiling) {\n        itemsInLowerRange += 1;\n      }\n    });\n    if (itemsInLowerRange > distinctPossibleIntegersInLowerRange) {\n      // There must be a duplicate in the lower range\n      // so use the same approach iteratively on that range\n      floor = lowerRangeFloor;\n      ceiling = lowerRangeCeiling;\n    } else {\n      // There must be a duplicate in the upper range\n      // so use the same approach iteratively on that range \n      floor = upperRangeFloor;\n      ceiling = upperRangeCeiling;\n    }\n  }\n  // Floor and ceiling have converged\n  // We found a number that repeats!\n  return floor;\n}\n",
      "diff": 1,
      "imp": 1,
      "cate": [
        "search"
      ],
      "id": 22
    },
    {
      "subject": "algo",
      "title": "Recursive String Permutations",
      "ques": "Write a recursive function for generating all permutations of an input string. Return them as a set.",
      "links": [],
      "tags": [
        {
          "name": "Interview Cake"
        },
        {
          "name": "Permutations"
        }
      ],
      "ans": "function getPermutations(string) {\n  // Base case\n  if (string.length <= 1) {\n    return new Set([string]);\n  }\n  const allCharsExceptLast = string.slice(0, -1);\n  const lastChar = string[string.length - 1];\n\n  // Recursive call: get all possible permutations for all chars except last\n  const permutationsOfAllCharsExceptLast = getPermutations(allCharsExceptLast);\n\n  // Put the last char in all possible positions for each of the above permutations\n  const permutations = new Set();\n  permutationsOfAllCharsExceptLast.forEach(\n    (permutationOfAllCharsExceptLast) => {\n      for (\n        let position = 0;\n        position <= allCharsExceptLast.length;\n        position++\n      ) {\n        const permutation =\n          permutationOfAllCharsExceptLast.slice(0, position) + lastChar + pe;\n        permutations.add(permutation);\n      }\n    }\n  );\n  return permutations;\n}\n",
      "diff": 1,
      "imp": 1,
      "cate": [
        "dynamic",
        "recursion"
      ],
      "id": 23
    },
    {
      "subject": "algo",
      "title": "Syllabus :",
      "ques": "",
      "links": [],
      "tags": [
        {
          "name": "Interview Cake"
        }
      ],
      "ans": "\n1.Array and string manipulation\n    a.Merging Meeting Times\n    b.Reverse String in Place\n    c.Reverse Words\n    d.Merge Sorted Arrays\n    e.Cafe Order Checker\n    \n2.Hashing & Hash tables\n    a.Inflight Entertainment\n    b.Permutation Palindrome\n    c. Word Cloud Data\n    \n3.Greedy algorithms\n    a.Apple Stocks\n    b.Highest Product of 3\n    c.Product of All Other Numbers\n    d.Cafe Order Checker\n    e.In-place shuffle\n    \n4.Sorting, searching and logarithms\n    a.Find Rotation Point\n    b.Find Repeat, Space Edition\n    c.Top Scores\n    d.Merging Meeting Times\n    \n5.Trees and graphs\n    a.Balanced Binary Tree\n    b.Binary Search Tree Checker\n    c.2nd Largest Item in a Binary Search Tree\n    d.Graph Coloring\n    e.Mesh Message\n    f.Find Repeat, Space Edition BEAST MODE\n    \n6.Dynamic Programming and recursion\n    a.Recursive String Permutations\n    b.Compute the nth Fibonacci Number\n    c.Making Change\n    d.The Cake Thief\n    e.Balanced Binary Tree\n    f.Binary Search Tree Checker\n    g.2nd Largest Item in a Binary Search Tree\n    \n7.Queues and stacks\n    a.Largest stack\n    b.Implement a Queue with two stacks\n    c.Parenthesis Matching\n    d.Bracket Validator\n    \n8.Linked lists\n    a.Delete Node\n    b.Does this Linked List Have a cycle\n    c.Reverse a linked list\n    d.Kth to last Node in as Singly-Linked list\n    e.Find Repeat, Space Edition BEAST MODE\n    \n    \n    \n    \n    \n    \n    \n    \n    ",
      "diff": 1,
      "imp": 1,
      "cate": [
        "syllabus"
      ],
      "id": 24
    },
    {
      "subject": "algo",
      "title": "Type of array and its maximum element",
      "ques": "Given an array, it can be of 4 types. \n(a) Ascending \n(b) Descending \n(c) Ascending Rotated \n(d) Descending Rotated \nFind out which kind of array it is and return the maximum of that array.",
      "links": [
        {
          "name": "https://www.geeksforgeeks.org/type-array-maximum-element/"
        }
      ],
      "tags": [
        {
          "name": "GeeksforGeeks"
        },
        {
          "name": "Amazon"
        }
      ],
      "ans": "\n/*\nInput :  arr[] = { 2, 1, 5, 4, 3}\nOutput : Descending rotated with maximum element 5\n\nInput :  arr[] = { 3, 4, 5, 1, 2}\nOutput : Ascending rotated with maximum element 5\n*/\n\nfunction findType(arr, n) {\n  // To store the minimum and the maximum\n  // element from the array\n  let min_element = Number.MAX_VALUE,\n    max_element = Number.MIN_VALUE;\n\n  // To store the first and the last occurrences\n  // of the minimum and the maximum\n  // element from the array\n  let min_index1 = -1,\n    max_index1 = -1,\n    max_index2 = -1,\n    min_index2 = -1;\n\n  for (let i = 0; i < n; i++) {\n    // If new minimum is found\n    if (arr[i] < min_element) {\n      // Update the minimum so far\n      // and its occurrences\n      min_element = arr[i];\n      min_index1 = i;\n      min_index2 = i;\n    }\n\n    // If current element is equal the found\n    // minimum so far then update the last\n    // occurrence of the minimum element\n    else if (arr[i] == min_element){\n     // console.log(\"ELSE Min :: i :: arr[i] ::::\", i,\"::\",arr[i]);  \n      min_index2 = i;\n    } \n\n    // If new maximum is found\n    if (arr[i] > max_element) {\n      // Update the maximum so far\n      // and its occurrences\n      max_element = arr[i];\n      max_index1 = i;\n      max_index2 = i;\n    }\n\n    // If current element is equal the found\n    // maximum so far then update the last\n    // occurrence of the maximum element\n    else if (arr[i] == max_element) {\n      max_index2 = i;\n    }\n  }\n  \n  console.log(\"MIN :: min_element :: min_index1 :: min_index2 ::::\", min_element,\"::\",min_index1,\"::\",min_index2);\n  console.log(\"MAX :: max_element :: max_index1 :: max_index2 ::::\", max_element,\"::\",max_index1,\"::\",max_index2);\n\n  // First occurrence of minimum element is at the\n  // beginning of the array and the last occurrence\n  // of the maximum element is at the end of the\n  // array then the array is sorted in ascending\n  // For example, {1, 1, 1, 2, 3, 4, 5, 6, 6, 6}\n  if (min_index1 == 0 && max_index2 == n - 1) {\n    console.log(\"Ascending with maximum\" + \" element = \" + max_element);\n  }\n\n  // First occurrence of maximum element is at the\n  // beginning of the array and the last occurrence\n  // of the minimum element is at the end of the\n  // array then the array is sorted in descending\n  // For example, {6, 6, 6, 5, 4, 3, 2, 1, 1, 1}\n  else if (max_index1 == 0 && min_index2 == n - 1) {\n    console.log(\"Descending with maximum\" + \" element = \" + max_element);\n  }\n\n  // First occurrence of maximum element is equal\n  // to the last occurrence of the minimum element + 1\n  // then the array is descending and rotated\n  // For example, {3, 2, 1, 1, 1, 6, 6, 6, 5, 4}\n  else if (max_index1 == min_index2 + 1) {\n    console.log(\n      \"Descending rotated with \" + \"maximum element = \" + max_element\n    );\n  }\n\n  // First occurrence of minimum element is equal\n  // to the last occurrence of the maximum element + 1\n  // then the array is ascending and rotated\n  // For example, {4, 5, 6, 6, 6, 1, 1, 1, 2, 3}\n  else {\n    console.log(\"Ascending rotated with \" + \"maximum element = \" + max_element);\n  }\n}\n\nlet arr1 = [5,4,3,2,1];\n\nlet arr4 = [4, 5, 6, 6, 6, 1, 1, 1, 2, 3];\n\nfindType(arr1, arr1.length);\n",
      "diff": 4,
      "imp": 4,
      "cate": [
        "arr"
      ],
      "id": 25
    },
    {
      "subject": "algo",
      "title": "Rearrange characters in a string such that no two adjacent are same",
      "ques": "Given a string with repeated characters, the task is to rearrange characters in a string so that no two adjacent characters are same.\nNote : It may be assumed that the string has only lowercase English alphabets.",
      "links": [
        {
          "name": "https://www.geeksforgeeks.org/rearrange-characters-string-no-two-adjacent/"
        }
      ],
      "tags": [
        {
          "name": "GeeksforGeeks"
        },
        {
          "name": "Amazon"
        }
      ],
      "ans": "\n/*\nInput: aaabc \nOutput: abaca \n\nInput: aaabb\nOutput: ababa \n\nInput: aa \nOutput: Not Possible\n\nInput: aaaabc \nOutput: Not Possible\n*/",
      "diff": 4,
      "imp": 3,
      "cate": [
        "str"
      ],
      "id": 26
    },
    {
      "subject": "algo",
      "title": "List of problems sorted in increasing order of difficulty",
      "ques": "",
      "links": [
        {
          "name": "https://www.ideserve.co.in/learn/dynamic-programming-interview-questions"
        }
      ],
      "tags": [
        {
          "name": "ideserve"
        }
      ],
      "ans": "",
      "diff": 3,
      "imp": 4,
      "cate": [
        "dynamic"
      ],
      "id": 27
    },
    {
      "subject": "algo",
      "title": "Binary Search",
      "ques": "",
      "links": [],
      "tags": [
        {
          "name": "General"
        }
      ],
      "ans": "  function binarySearch(key, inputArray) {\r\n      var low  = 0,\r\n          high = inputArray.length - 1,\r\n          mid;\r\n\r\n      while (low <= high) {\r\n          mid = low + (high - low) / 2;\r\n          if ((mid % 1) > 0) { mid = Math.ceil(mid); }\r\n\r\n          if (key < inputArray[mid]) { high = mid - 1; }\r\n          else if (key > inputArray[mid]) { low = mid + 1; }\r\n          else { return mid; }\r\n      }\r\n\r\n      return null;\r\n  }\r\n\r\n  // run the binary search\r\n  binarySearch(3, [1,2,4]); //returns null\r\n  binarySearch(3, [2,3,5]); //returns 1",
      "diff": 1,
      "imp": 1,
      "cate": [
        "search"
      ],
      "id": 28
    },
    {
      "subject": "algo",
      "title": "Merge Sort",
      "ques": "",
      "links": [
        {
          "name": "https://stackabuse.com/merge-sort-in-javascript/"
        }
      ],
      "tags": [
        {
          "name": "General"
        }
      ],
      "ans": "function mergeSort(array) {\n  const half = array.length / 2\n  \n  // Base case or terminating case\n  if(array.length < 2){\n    return array \n  }\n  \n  const left = array.splice(0, half)\n  return merge(mergeSort(left),mergeSort(array))\n}\n\nfunction merge(left, right) {\n    let arr = []\n    // Break out of loop if any one of the array gets empty\n    while (left.length && right.length) {\n        // Pick the smaller among the smallest element of left and right sub arrays \n        if (left[0] < right[0]) {\n            arr.push(left.shift())  \n        } else {\n            arr.push(right.shift()) \n        }\n    }\n    \n    // Concatenating the leftover elements\n    // (in case we didn't go through the entire left or right array)\n    return [ ...arr, ...left, ...right ]\n}",
      "diff": 1,
      "imp": 1,
      "cate": [
        "sort"
      ],
      "id": 29
    },
    {
      "subject": "algo",
      "title": "All possible permutation of number",
      "ques": "",
      "links": [
        {
          "name": "https://medium.com/weekly-webtips/step-by-step-guide-to-array-permutation-using-recursion-in-javascript-4e76188b88ff"
        }
      ],
      "tags": [
        {
          "name": "General"
        },
        {
          "name": "Permutations"
        }
      ],
      "ans": "var permArr = [],\n  usedChars = [];\n\nfunction permute(input) {\n  var i, ch;\n  for (i = 0; i < input.length; i++) {\n    ch = input.splice(i, 1)[0];\n    usedChars.push(ch);\n    if (input.length == 0) {\n      permArr.push(usedChars.slice());\n    }\n    permute(input);\n    input.splice(i, 0, ch);\n    usedChars.pop();\n  }\n  return permArr\n};\n\n\nconsole.log(permute([5, 3, 7, 1]));",
      "diff": 1,
      "imp": 1,
      "cate": [
        "str",
        "arr"
      ],
      "id": 30
    },
    {
      "subject": "algo",
      "title": "Array Rotation",
      "ques": "",
      "links": [],
      "tags": [
        {
          "name": "General"
        }
      ],
      "ans": "function rotatedArray(arr, times){\n   times = times % arr.length;\n   for(var i=arr.length -1; i>arr.length - 1 - times; i--){\n       var pop = arr.pop();\n       arr.unshift(pop);\n   }\n   return arr;\n}\n\n\nfunction reverseArray(arr, startIndex, EndIndex){\n  /* if(startIndex === EndIndex){\n       return \"Not valid start and end Index\";\n   }*/\n\n\n   while(startIndex < EndIndex){\n       var temp = arr[startIndex];\n       arr[startIndex]  = arr[EndIndex];\n       arr[EndIndex] = temp;\n\n\n       startIndex = startIndex + 1;\n       EndIndex = EndIndex - 1;\n  }\n\n\n   return arr;\n\n\n}\n\n\nfunction rotatedArray2(arr, times){\n    times = times % arr.length;\n   var splitArrayIndex = arr.length - times - 1;\n\n\n   arr = reverseArray(arr, 0,splitArrayIndex);\n   arr = reverseArray(arr, splitArrayIndex + 1, arr.length - 1);\n   arr = reverseArray(arr, 0, arr.length - 1);\n\n\n   return arr;\n}\n\n\n\n\nvar arr = [1,2,3,4,5, 6,7,8];\nrotatedArray(arr, 3);\n\n\nvar arr = [1,2,3,4,5, 6,7,8];\nreverseArray(arr, 5,7);",
      "diff": 1,
      "imp": 1,
      "cate": [
        "arr"
      ],
      "id": 31
    },
    {
      "subject": "algo",
      "title": "Segregate 0's, 1's and 2's together in an array[O(n)](Dutch National Flag Problem)",
      "ques": "",
      "links": [
        {
          "name": "https://www.youtube.com/watch?v=BOt1DAvR0zI&ab_channel=VivekanandKhyade-AlgorithmEveryDay"
        }
      ],
      "tags": [
        {
          "name": "Dutch National Flag Problem"
        },
        {
          "name": "youtube"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": [
        "arr"
      ],
      "id": 32
    },
    {
      "subject": "algo",
      "title": "Find the missing number in the increasing sequence",
      "ques": "",
      "links": [
        {
          "name": "https://www.youtube.com/watch?v=yxYCiBja8_s&ab_channel=IDeserve"
        }
      ],
      "tags": [
        {
          "name": "ideserve"
        }
      ],
      "ans": "// total = n*(n+1)/2",
      "diff": 1,
      "imp": 1,
      "cate": [
        "arr"
      ],
      "id": 33
    },
    {
      "subject": "algo",
      "title": "Remove duplicate in Array in single loop",
      "ques": "",
      "links": [],
      "tags": [
        {
          "name": "Duplicate inArray"
        }
      ],
      "ans": "var t1 = [1,2,3,2,3];\n\nfunction duplicateInArray(){\n  for(var i=0; i<t1.length; i++){\n    if(t1[Math.abs(t1[i])] > 0){\n      t1[Math.abs(t1[i])] = -t1[Math.abs(t1[i])];\n    }else{\n      console.log('Element '+Math.abs(t1[i])+' duplicate at '+i);\n    }\n  }\n}",
      "diff": 1,
      "imp": 1,
      "cate": [
        "arr"
      ],
      "id": 34
    },
    {
      "subject": "algo",
      "title": "Doubly linked list - basics (ES5)",
      "ques": "",
      "links": [],
      "tags": [
        {
          "name": "General"
        }
      ],
      "ans": "\nfunction LinkedList() {\n  this.head = null;\n  this.tail = null;\n}\n \nfunction Node(value, next, prev) {\n  this.value = value;\n  this.next = next;\n  this.prev = prev;\n}\n \nLinkedList.prototype.addToHead = function(value) {\n  var newNode = new Node(value, this.head, null);\n  if (this.head) this.head.prev = newNode;\n  else this.tail = newNode;\n  this.head = newNode;\n};\n \nLinkedList.prototype.addToTail = function(value) {\n  var newNode = new Node(value, null, this.tail);\n  if (this.tail) this.tail.next = newNode;\n  else this.head = newNode;\n  this.tail = newNode;\n};\n \nLinkedList.prototype.removeHead = function() {\n  if (!this.head) return null;\n  var val = this.head.value;\n  this.head = this.head.next;\n  if (this.head) this.head.prev = null;\n  else this.tail = null;\n  return val;\n};\n \nLinkedList.prototype.removeTail = function() {\n  if (!this.tail) return null;\n  var val = this.tail.value;\n  this.tail = this.tail.prev;\n  if (this.tail) this.tail.next = null;\n  else this.head = null;\n  return val;\n};\n \nLinkedList.prototype.search = function(searchValue) {\n  var currentNode = this.head;\n  while (currentNode) {\n    if (currentNode.value === searchValue) return currentNode.value;\n    currentNode = currentNode.next;\n  } \n  return null;\n};\n \nLinkedList.prototype.indexOf = function(value) {\n  var indexes = [];\n  var currentIndex = 0;\n  var currentNode = this.head;\n  while(currentNode) {\n    if (currentNode.value === value) indexes.push(currentIndex);\n    currentNode = currentNode.next;\n    currentIndex++;\n  }\n  return indexes;\n};\n \n \nvar myLL = new LinkedList();\n \nmyLL.addToHead(123);\nmyLL.addToHead(70);\nmyLL.addToHead('hello');\nmyLL.addToTail(19);\nmyLL.addToTail('world');\nmyLL.addToTail(20);",
      "diff": 1,
      "imp": 1,
      "cate": [
        "linked-list"
      ],
      "id": 35
    },
    {
      "subject": "algo",
      "title": "Basic binary tree implementation (ES5)",
      "ques": "",
      "links": [],
      "tags": [
        {
          "name": "General"
        }
      ],
      "ans": "\nfunction BST(value) {\n  this.value = value;\n  this.right = null;\n  this.left = null;\n}\n \nBST.prototype.insert = function(value) {\n  if (value <= this.value) {\n    if (!this.left) this.left = new BST(value);\n    else this.left.insert(value);\n  }\n  else if (value > this.value) {\n    if (!this.right) this.right = new BST(value);\n    else this.right.insert(value);\n  }\n};\n \nBST.prototype.contains = function(value) {\n  if (this.value === value) return true;\n  if (value < this.value) {\n    if (!this.left) return false;\n    else return this.left.contains(value);\n  }\n  else if (value > this.value) {\n    if (!this.right) return false;\n    else return this.right.contains(value);\n  }\n};\n \nBST.prototype.depthFirstTraversal = function(iteratorFunc, order) {\n  if (order === 'pre-order') iteratorFunc(this.value);\n  if (this.left) this.left.depthFirstTraversal(iteratorFunc, order);\n  if (order === 'in-order') iteratorFunc(this.value);\n  if (this.right) this.right.depthFirstTraversal(iteratorFunc, order);\n  if (order === 'post-order') iteratorFunc(this.value);\n};\n \nBST.prototype.breadthFirstTraversal = function(iteratorFunc) {\n  var queue = [this];\n  while (queue.length) {\n    var treeNode = queue.shift();\n    iteratorFunc(treeNode);\n    if (treeNode.left) queue.push(treeNode.left);\n    if (treeNode.right) queue.push(treeNode.right);\n  }\n};\n \nfunction log(value) {\n    console.log(value);\n};\n \nBST.prototype.getMinVal = function() {\n  if (this.left) return this.left.getMinVal();\n  else return this.value;\n};\n \nBST.prototype.getMaxVal = function() {\n  if (this.right) return this.right.getMaxVal();\n  else return this.value;\n};\n \n \n \nvar bst = new BST(50);\n \nbst.insert(30);\nbst.insert(70);\nbst.insert(100);\nbst.insert(60);\nbst.insert(59);\nbst.insert(20);\nbst.insert(45);\nbst.insert(35);\nbst.insert(85);\nbst.insert(105);\nbst.insert(10);\n \nfunction log(node) {\n console.log(node.value);\n}\n \nbst.breadthFirstTraversal(log);",
      "diff": 1,
      "imp": 1,
      "cate": [
        "tree"
      ],
      "id": 36
    },
    {
      "subject": "algo",
      "title": "Queue implementation using linked list",
      "ques": "",
      "links": [],
      "tags": [
        {
          "name": "General"
        }
      ],
      "ans": "\n// queue is initially empty\nvar Queue = {front: null, back: null};\n\n// we will use a node to keep track of the elements\n// in the queue which is represented by a linked list\nfunction Node(data, next) {\n  this.data = data;\n  this.next = next;\n} \n\n// add elements to queue in O(1) time\nfunction Enqueue(element) {\n  var N = new Node(element, null);\n  if (Queue.back === null) {\n    Queue.front = N;\n    Queue.back = N; \n  } else { \n    Queue.back.next = N; \n    Queue.back = Queue.back.next;\n  } \n}\n\n// remove first element from queue in O(1) time\nfunction Dequeue() {\n  if (Queue.front !== null) { \n    var first = Queue.front;\n    Queue.front = Queue.front.next; \n    return first.data;\n  } else {\n    if (Queue.back !== null) { Queue.back = null; }\n    return 'Cannot dequeue because queue is empty';\n  }\n}\n\nEnqueue('a'); \nEnqueue('b'); \nEnqueue('c');\n\n\nconsole.log(\"Queue ::\", Queue)",
      "diff": 1,
      "imp": 1,
      "cate": [
        "queueStack",
        "linked-list"
      ],
      "id": 37
    },
    {
      "subject": "algo",
      "title": "Maximum room required",
      "ques": "",
      "links": [],
      "tags": [
        {
          "name": "General"
        }
      ],
      "ans": "function maxRoom(A){\n         console.log(\"*** A ::\", A);\n         const dt = A.sort((a, b) => {\n             return a[0] - b[0]\n         });\n         console.log(\"### sorted A ::\", dt);\n         let another = [dt[0]]\n         let tot = 1;\n        for(let i=1, l=dt.length; i<l; i++){\n            let last = another[another.length - 1];\n            let current = dt[i];\n\n            if(current[0] <= last[1]){\n                //tot = tot + 1;\n                //another.push(current);\n                last[1] = Math.max(last[1], current[1]);\n            } else {\n                another.push(current);\n            }\n\n        }\n\n        return another;\n\n\t}\n\n\nlet test1 = [\n  [1, 18],\n  [18, 23],\n  [15, 29],\n  [4, 15],\n  [2, 11],\n  [5, 13]\n]\n\nlet test2 = [ [0, 30],\n            [5, 10],\n            [15, 20]\n         ];\nconsole.log(maxRoom(test1));",
      "diff": 1,
      "imp": 1,
      "cate": [
        "arr",
        "sort"
      ],
      "id": 38
    },
    {
      "subject": "algo",
      "title": "Crop String message",
      "ques": "Write a method(CropMessage) that will accept two arguments i.e. string message and size to be cropped. The final method will return a string in such a way that none of the words will be partially cropped",
      "links": [],
      "tags": [
        {
          "name": "Toptal"
        }
      ],
      "ans": "/*\n CropMessage(\"Hello World\", 8) ==> \"Hello\"\n CropMessage(\"Hello World\", 11) ===> \"Hello World\"\n*/\n\n\nfunction cropMessage(message, K) {\n    // write your code in JavaScript (Node.js 8.9.4)\n    let croppedMessage = message.slice(0, K);\n    let lastChar = croppedMessage[croppedMessage.length - 1]\n    if(lastChar === \" \" || (message[croppedMessage.length] && message[croppedMessage.length] !== \" \") ){\n        let lastSpaceIndex = croppedMessage.lastIndexOf(\" \");\n        croppedMessage = croppedMessage.slice(0, lastSpaceIndex);\n    }\n\n    return croppedMessage;\n}\n\nconsole.log(cropMessage(\"Hello World\", 10))",
      "diff": 1,
      "imp": 1,
      "cate": [
        "str"
      ],
      "id": 39
    },
    {
      "subject": "algo",
      "title": "Minimum no. of cars",
      "ques": "Write a method that accepts two arguments - totalSeatRequired and array of the car with no. of seats. It will return minimum no. of cars needed to accommodate all seats",
      "links": [],
      "tags": [
        {
          "name": "Toptal"
        }
      ],
      "ans": "/*\n  getMinSeats(6, [1,5,1]). ==> 2\n*/\n\nfunction solution2(P, S) {\n    // write your code in JavaScript (Node.js 8.9.4)\n    function maxValue(arr){\n        return arr.reduce((max, val) => max > val ? max : val);\n    }\n\n    let totalSeatRequired = P.reduce((s, p) => { return p+s;}, 0);\n    let minCarNeeded = 0;\n    while(totalSeatRequired > 0){\n        let max = maxValue(S);\n        let maxIdx = S.indexOf(max);\n        minCarNeeded += 1;\n        totalSeatRequired -= max;\n        S.splice(maxIdx, 1);\n    }\n    return minCarNeeded;\n}\n\nconsole.log(solution2([1,4,1], [1,5,1]))",
      "diff": 1,
      "imp": 1,
      "cate": [
        "greed"
      ],
      "id": 40
    },
    {
      "subject": "algo",
      "title": "Minimum no of chimney filter",
      "ques": "There is an array containing the amount of pollution released from each factory. Installing a filter will reduce the pollution by 50%. what will be minimum no. of filters required to reduce overall pollution by half",
      "links": [],
      "tags": [
        {
          "name": "Toptal"
        }
      ],
      "ans": "/*\n    getMinFilters([5, 19, 8, 1]) ===> 3\n*/\n\nfunction getMinFilters(A) {\n    function findMax(ar){\n        let max = 0, idx = 0;\n        for(let i=0; i<ar.length;i++){\n            if(ar[i]>max){\n                max=ar[i];\n                idx = i;\n            }\n        }\n        return {\"v\" : max, \"idx\": idx}\n    }\n    let totalPollution = A.reduce((s, p) => { return p+s;}, 0);\n    let minPoll = totalPollution / 2;\n    let minFilter = 0;\n\n    while(totalPollution > minPoll){\n        let maxResult = findMax(A);\n        console.log(\"maxResult ::\", maxResult);\n        A.splice(maxResult.idx, 1, ((maxResult.v)/2));\n        minFilter += 1;\n        totalPollution -= (maxResult.v)/2\n    }\n    return minFilter;\n}\n\nconsole.log(getMinFilters([5, 19, 8, 1]));",
      "diff": 1,
      "imp": 1,
      "cate": [
        "greed"
      ],
      "id": 41
    },
    {
      "subject": "algo",
      "title": "Flatten a JSON object",
      "ques": "",
      "links": [],
      "tags": [
        {
          "name": "General"
        },
        {
          "name": "Goldman sachs"
        }
      ],
      "ans": "//object 1\nvar d1 = {\n    name: 'test',\n    ar: [1,2, [3,4,[5,6, [7]]]],\n    config: { },\n    prev: { name: 'test1.1',\n        config: { },\n        prev: {\n            name: 'test1.1.1',\n            config: {  },\n            prev: { name: 'test1.1.1.1', config: { }, prev: undefined }\n        }\n    }\n};\n\nvar d2 = [1,2, [3,4,[5,6, [7]]]]\n\nfunction flattenObj(ob){\n    let finalObj = [];\n    let extractValue = (obj) => {\n        for(let p in obj){\n            if(typeof(obj[p]) == \"object\"){ // both array & object\n                extractValue(obj[p]);\n            } else {\n                if(Array.isArray(obj)){\n                   finalObj.push(obj[p]);\n                } else{\n                    let _ob = {};\n                   _ob[p] = obj[p]; \n                   finalObj.push(_ob); \n                }\n            }\n        }\n       \n    }\n\n    extractValue(ob);\n    return finalObj;\n}\n\nflattenObj(d1);",
      "diff": 1,
      "imp": 1,
      "cate": [
        "arr",
        "obj"
      ],
      "id": 42
    },
    {
      "subject": "algo",
      "title": "Check if no. is prime",
      "ques": "",
      "links": [],
      "tags": [
        {
          "name": "General"
        }
      ],
      "ans": "const isPrime = num => {\n    for(let i = 2, s = Math.sqrt(num); i <= s; i++)\n        if(num % i === 0) return false; \n    return num > 1;\n}\n\nisPrime(11)",
      "diff": 1,
      "imp": 1,
      "cate": [
        "numbers"
      ],
      "id": 43
    },
    {
      "subject": "algo",
      "title": "Possible denominaions",
      "ques": "",
      "links": [],
      "tags": [
        {
          "name": "Toptal"
        }
      ],
      "ans": "// 1c, 5c, 10c, 25c, 50c, and $1\n\n\nconst getChange = (M, P) => {\n    const denominations = [1, 5, 10, 25, 50]; \n\n    let changeAmount = (M-P).toFixed(2).split(\".\");\n    //console.log(\"changeAmount ::\", changeAmount);\n    const dollarAmt = Number(changeAmount[0]);\n    const centAmt = Number(changeAmount[1]);\n\n    console.log(\"dollarAmt :: centAmt ::\", dollarAmt, \"::\",centAmt);\n    \n    let finalalDeno = [];\n    let centLeft = centAmt;\n\n//***************************************************\n\n\n    let idx = 4;\n    while(idx >= 0){\n       let deno = denominations[idx]\n       if(deno <= centLeft && centLeft > 0){\n            let qty = Math.floor(centLeft/deno);\n            centLeft = centLeft - (deno * qty);\n            finalalDeno.unshift(qty);\n       } else {\n            finalalDeno.unshift(0); \n       }\n       idx = idx - 1;\n    }\n\n\n//********************* OR ***********************\n\n\n//     for(let i=(denominations.length - 1); i >= 0; i--){\n//             let deno = denominations[i]\n//            if(deno <= centLeft && centLeft > 0){\n//                 let qty = Math.floor(centLeft/deno);\n//                 centLeft = centLeft - (deno * qty);\n//                 finalalDeno.unshift(qty);\n//            } else {\n//                 finalalDeno.unshift(0); \n//            }\n//     }\n\n\n//***************************************************\n\n    finalalDeno.push(dollarAmt)\n    console.log(\"*** finalalDeno *** ::\", finalalDeno);\n}\n\ngetChange(5, 0.99) // should return [1,0,0,0,0,4]\ngetChange(3.14, 1.99) // should return [0,1,1,0,0,1]\ngetChange(3, 0.01) // should return [4,0,2,1,1,2]\ngetChange(4, 3.14) // should return [1,0,1,1,1,0]\ngetChange(0.45, 0.34) // should return [1,0,1,0,0,0]",
      "diff": 1,
      "imp": 1,
      "cate": [
        "greed"
      ],
      "id": 44
    },
    {
      "subject": "algo",
      "title": "Given a number, find its corresponding Roman numeral",
      "ques": "Converting Decimal Number lying between 1 to 3999 to Roman Numerals",
      "links": [
        {
          "name": "https://www.geeksforgeeks.org/converting-decimal-number-lying-between-1-to-3999-to-roman-numerals/"
        }
      ],
      "tags": [
        {
          "name": "Oracle"
        }
      ],
      "ans": "/*\nint num[] = {1,4,5,9,10,40,50,90,100,400,500,900,1000};\nstring sym[] = {\"I\",\"IV\",\"V\",\"IX\",\"X\",\"XL\",\"L\",\"XC\",\"C\",\"CD\",\"D\",\"CM\",\"M\"};\n*/",
      "diff": 1,
      "imp": 1,
      "cate": [
        "arr",
        "obj"
      ],
      "id": 45
    },
    {
      "subject": "algo",
      "title": "Trapping Rain Water between Towers Problem",
      "ques": "We have an array where each element represents height of a tower. If it starts raining, what is the amount of water that can be collected between the towers? Assumption is that the width of every tower is 1.",
      "links": [
        {
          "name": "https://www.youtube.com/watch?v=KV-Eq3wYjxI&ab_channel=IDeserve"
        }
      ],
      "tags": [
        {
          "name": "Oracle"
        }
      ],
      "ans": "/*\n[1,5,2,3,1,7,2] – then answer is 11 units.\n*/",
      "diff": 5,
      "imp": 1,
      "cate": [
        "arr"
      ],
      "id": 46
    },
    {
      "subject": "algo",
      "title": "Buildings With an Ocean View",
      "ques": "There are n buildings in a line. You are given an integer array heights of size n that represents the heights of the buildings in the line.\n\nThe ocean is to the right of the buildings. A building has an ocean view if the building can see the ocean without obstructions. Formally, a building has an ocean view if all the buildings to its right have a smaller height.\n\nReturn a list of indices (0-indexed) of buildings that have an ocean view, sorted in increasing order.",
      "links": [
        {
          "name": "https://leetcode.com/problems/buildings-with-an-ocean-view"
        }
      ],
      "tags": [
        {
          "name": "Leetcode"
        },
        {
          "name": "Microsoft"
        }
      ],
      "ans": "/*\nExample 1:\n\nInput: heights = [4,2,3,1]\nOutput: [0,2,3]\nExplanation: Building 1 (0-indexed) does not have an ocean view because building 2 is taller.\nExample 2:\n\nInput: heights = [4,3,2,1]\nOutput: [0,1,2,3]\nExplanation: All the buildings have an ocean view.\nExample 3:\n\nInput: heights = [1,3,2,4]\nOutput: [3]\nExplanation: Only building 3 has an ocean view.\n*/\n\nvar findBuildings = function(heights) {    \n    if(heights.length == 0) return [];\n    \n    let buildingIdx = [];\n    let maxSoFar = 0;\n    for(let i= (heights.length - 1); i >=0; i--){\n        if(heights[i] > maxSoFar) {\n            buildingIdx.push(i)\n            maxSoFar = heights[i];\n        };\n    }\n    \n    return buildingIdx.reverse();\n};",
      "diff": 3,
      "imp": 3,
      "cate": [
        "arr",
        "queueStack"
      ],
      "id": 47
    },
    {
      "subject": "algo",
      "title": " Minimum Add to Make Parentheses Valid",
      "ques": "A parentheses string is valid if and only if:\n\nIt is the empty string,\nIt can be written as AB (A concatenated with B), where A and B are valid strings, or\nIt can be written as (A), where A is a valid string.\nYou are given a parentheses string s. In one move, you can insert a parenthesis at any position of the string.\n\nFor example, if s = \"()))\", you can insert an opening parenthesis to be \"(()))\" or a closing parenthesis to be \"())))\".\nReturn the minimum number of moves required to make s valid.",
      "links": [
        {
          "name": "https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/"
        }
      ],
      "tags": [
        {
          "name": "Microsoft"
        },
        {
          "name": "Leetcode"
        }
      ],
      "ans": "/*\nExample 1:\n\nInput: s = \"())\"\nOutput: 1\nExample 2:\n\nInput: s = \"(((\"\nOutput: 3\n*/\n\nvar minAddToMakeValid = function(s) {\n   let open = 0, close = 0;\n   for(let i=0; i<s.length; i++){\n       if(s[i] == \"(\"){\n          open = open + 1;\n        } else {\n            if(open > 0){\n                open = open - 1;\n            } else {\n                close = close + 1;\n            } \n        }\n   }\n    \n   return open + close;\n};",
      "diff": 3,
      "imp": 3,
      "cate": [
        "str",
        "greed",
        "queueStack"
      ],
      "id": 48
    },
    {
      "subject": "algo",
      "title": "Single linked list - basics (ES6) :",
      "ques": "",
      "links": [
        {
          "name": "https://medium.com/swlh/singly-linked-list-in-javascript-a0e58d045561"
        },
        {
          "name": "https://codeburst.io/linked-lists-in-javascript-es6-code-part-1-6dd349c3dcc3"
        }
      ],
      "tags": [
        {
          "name": "General"
        }
      ],
      "ans": "\nclass LinkedList{\n\n  constructor(d){\n    this.data = d;\n    this.next = null\n  }\n\n  add(d){\n    let head = this;\n    while(head.next){\n      head = head.next;\n    }\n    head.next = new LinkedList(d);\n  }\n\n  remove(idx){\n    if(!idx){\n      let head = this.next;\n      this.data = head.data;\n      this.next = head.next;\n    } \n\n    if(idx){\n      let i=0;\n      let head = this;\n      while(i < (idx-1) && head.next){\n        head = head.next;\n        i = i + 1;\n      }\n\n      if(head && head.next){\n        if(idx > 0 ){\n          head.next = head.next.next; \n        } else{\n          head.next = head.next;\n        }\n      }\n            \n    }\n    \n  }\n\n  traverse(){\n    let idx = 0;\n    let head = this;\n    while(head.next){\n      console.log(idx +\" : \"+head.data);\n      head = head.next;\n      idx = idx + 1;\n    }\n    console.log(idx +\" : \"+head.data);\n  }\n}\n\nlet ll = new LinkedList(1);\nll.add(2);\nll.add(3);\nll.add(4);\nll.add(5);\nll.add(6);\n\n// ll.remove();\n// ll.remove();\nll.remove(2);\n\nll.traverse();\nconsole.log(ll);",
      "diff": 1,
      "imp": 1,
      "cate": [
        "linked-list"
      ],
      "id": 49
    },
    {
      "subject": "algo",
      "title": "Minimum Deletions to Make Character Frequencies Unique",
      "ques": "A string s is called good if there are no two different characters in s that have the same frequency.\n\nGiven a string s, return the minimum number of characters you need to delete to make s good.\n\nThe frequency of a character in a string is the number of times it appears in the string. For example, in the string \"aab\", the frequency of 'a' is 2, while the frequency of 'b' is 1.",
      "links": [
        {
          "name": "https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/submissions/"
        }
      ],
      "tags": [
        {
          "name": "Leetcode"
        },
        {
          "name": "Microsoft"
        }
      ],
      "ans": "/*\nExample 1:\n\nInput: s = \"aab\"\nOutput: 0\nExplanation: s is already good.\nExample 2:\n\nInput: s = \"aaabbbcc\"\nOutput: 2\nExplanation: You can delete two 'b's resulting in the good string \"aaabcc\".\nAnother way it to delete one 'b' and one 'c' resulting in the good string \"aaabbc\".\nExample 3:\n\nInput: s = \"ceabaacb\"\nOutput: 2\nExplanation: You can delete both 'c's resulting in the good string \"eabaab\".\nNote that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored).\n*/\n\n\nvar minDeletions = function(s) {\n    console.log(\"s ::\", s); \n    let sMap = {};\n    for(let i=0; i<s.length; i++){\n        sMap[s[i]] = (s[i] in sMap) ? sMap[s[i]] + 1 :  1;\n    }\n    console.log(\"sMap ::\", sMap); \n    \n   let fMap = {}; \n   let count = 0;\n    \n   const recurse = () => {\n        let fMap = {};\n         for(let key in sMap){\n              let f = sMap[key];\n              if((f in fMap)){\n                  count = count + 1;\n                  if(sMap[key] > 1){\n                     sMap[key] = sMap[key] - 1;\n                  }else {\n                      delete sMap[key];\n                  }\n                  recurse();\n                  break;\n              } else {\n                  fMap[f] = 1;\n              }\n         }  \n   }\n   \n    \n  recurse();\n  return count;\n    \n};\n",
      "diff": 1,
      "imp": 1,
      "cate": [
        "str",
        "sort"
      ],
      "id": 50
    },
    {
      "subject": "algo",
      "title": "Given an integer n, return any array containing n unique integers such that they add up to 0.",
      "ques": "",
      "links": [
        {
          "name": "https://leetcode.com/problems/find-n-unique-integers-sum-up-to-zero/"
        }
      ],
      "tags": [
        {
          "name": "Microsoft"
        },
        {
          "name": "Leetcode"
        }
      ],
      "ans": "/*\nExample 1:\n\nInput: n = 5\nOutput: [-7,-1,1,3,4]\nExplanation: These arrays also are accepted [-5,-1,1,2,3] , [-3,-1,2,-2,4].\nExample 2:\n\nInput: n = 3\nOutput: [-1,0,1]\nExample 3:\n\nInput: n = 1\nOutput: [0]\n \n*/\n\nvar sumZero = function(n) {\n    let a = [];\n\n     a.push((n % 2 == 0) ? -1 : 0); \n    \n    for(let i=1; i<n; i++){\n        a.push((a[i-1] < 0 ) ? (-(a[i-1])) : -(a[i-1] + 1));\n    }\n    \n    return a;\n};",
      "diff": 1,
      "imp": 1,
      "cate": [
        "arr"
      ],
      "id": 51
    },
    {
      "subject": "algo",
      "title": " Median of Two Sorted Arrays",
      "ques": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).\n",
      "links": [
        {
          "name": "https://leetcode.com/problems/median-of-two-sorted-arrays/"
        }
      ],
      "tags": [
        {
          "name": "Leetcode"
        }
      ],
      "ans": "/*\nExample 1:\n\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.\nExample 2:\n\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n*/\n\n/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nvar findMedianSortedArrays = function(nums1, nums2) {\n    console.log(\"nums1, nums2 ::\", nums1, \"::\",nums2);\n    let nums = [];\n    let idx1 = 0, idx2 = 0;\n    \n  while(idx1 < nums1.length || idx2 < nums2.length){\n        if(nums1[idx1] != undefined && nums2[idx2] == undefined){\n           nums.push(nums1[idx1]);\n           idx1 = idx1 + 1; \n        }\n        \n        if(nums1[idx1] == undefined && nums2[idx2] != undefined){\n           nums.push(nums2[idx2]);\n           idx2 = idx2 + 1; \n        }\n        \n        if(nums1[idx1] != undefined && nums2[idx2] != undefined){\n           if(nums1[idx1] < nums2[idx2]){\n              nums.push(nums1[idx1]);\n              idx1 = idx1 + 1; \n           } else {\n              nums.push(nums2[idx2]);\n              idx2 = idx2 + 1;  \n           }\n        }   \n    }\n    \n    console.log(\"nums ::\", nums);\n    \n    if(nums.length % 2 == 0){\n       let idx = nums.length/2;\n       return (nums[idx-1] + nums[idx])/2; \n    } else {\n        return nums[Math.floor(nums.length/2)];\n    }\n};",
      "diff": 5,
      "imp": 4,
      "cate": [
        "arr",
        "search",
        "sort"
      ],
      "id": 52
    }
  ],
  "js": [
    {
      "subject": "js",
      "title": "Throttling and Debouncing in JavaScript",
      "ques": "",
      "links": [
        {
          "name": "https://codeburst.io/throttling-and-debouncing-in-javascript-b01cad5c8edf"
        }
      ],
      "tags": [
        {
          "name": "Debouncing and Throttling"
        }
      ],
      "ans": "\n-> Throttling and debouncing give us control over the rate at which a function is called. \n\n-> They are especially useful when we are dealing with event handler assignments. There are scenarios where we may invoke functions when it isn’t necessary.",
      "diff": 4,
      "imp": 4,
      "cate": [
        "Events"
      ],
      "id": 1
    },
    {
      "subject": "js",
      "title": "JS: Basics and Tricky Questions",
      "ques": "",
      "links": [
        {
          "name": "http://www.thatjsdude.com/interview/js2.html#nullVsUndefined"
        }
      ],
      "tags": [
        {
          "name": "Basics & Tricky"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": [
        "General"
      ],
      "id": 2
    },
    {
      "subject": "js",
      "title": "Practical Uses for Closures",
      "ques": "",
      "links": [
        {
          "name": "https://medium.com/@dis_is_patrick/practical-uses-for-closures-c65640ae7304#.fva9ii8od"
        },
        {
          "name": "https://www.youtube.com/watch?v=-xqJo5VRP4A&ab_channel=techsith"
        }
      ],
      "tags": [
        {
          "name": "closures"
        }
      ],
      "ans": "function pam() {\n    var name = \"Pam Beesly\";\n    function displayName() {\n        alert (name);\n    }\n    displayName(); \n}\npam();\n",
      "diff": 3,
      "imp": 4,
      "cate": [
        "general"
      ],
      "id": 3
    },
    {
      "subject": "js",
      "title": "JavaScript scope",
      "ques": "Everything you wanted to know about JavaScript scope",
      "links": [
        {
          "name": "https://ultimatecourses.com/blog/everything-you-wanted-to-know-about-javascript-scope"
        }
      ],
      "tags": [
        {
          "name": "scoping"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 3,
      "cate": [
        "general"
      ],
      "id": 4
    },
    {
      "subject": "js",
      "title": "javaScript promises",
      "ques": "",
      "links": [
        {
          "name": "https://www.youtube.com/watch?v=s6SH72uAn3Q#t=6.819927&ab_channel=techsith"
        },
        {
          "name": "https://www.youtube.com/watch?v=104J7_HyaG4&ab_channel=DecypherMedia"
        }
      ],
      "tags": [
        {
          "name": "Promises"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": [
        "general",
        "Async"
      ],
      "id": 5
    },
    {
      "subject": "js",
      "title": "How new operator works ?",
      "ques": "",
      "links": [
        {
          "name": "https://ianbicking.org/blog/2013/04/new-considered-harmful.html"
        },
        {
          "name": "https://www.liip.ch/en/blog/why-i-dont-use-the-javascript-new-keyword"
        }
      ],
      "tags": [
        {
          "name": "New operator"
        }
      ],
      "ans": "\nfunction new_(constructor /* plus a variable number of arguments */) {\n  var newObject = Object.create(constructor.prototype);\n  // This gets the varargs after `constructor`:\n  var restArgs = Array.prototype.slice.call(arguments, 1);\n  var result = constructor.apply(newObject, restArgs);\n  if (typeof result == \"object\") {\n    // If the function returns something, ignore newObject\n    return result;\n  }\n  return newObject;\n}",
      "diff": 1,
      "imp": 3,
      "cate": [
        "general"
      ],
      "id": 6
    },
    {
      "subject": "js",
      "title": "Shadow Dom in HTML Introduction tutorial",
      "ques": "",
      "links": [
        {
          "name": "https://www.youtube.com/watch?v=SDs4xmMcVS4&ab_channel=techsith"
        },
        {
          "name": "https://css-tricks.com/modular-future-web-components/"
        }
      ],
      "tags": [
        {
          "name": "Shadow DOM"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": [
        "general",
        "DOM"
      ],
      "id": 7
    },
    {
      "subject": "js",
      "title": "What is Functional Programming?",
      "ques": "",
      "links": [
        {
          "name": "https://medium.com/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0"
        }
      ],
      "tags": [
        {
          "name": "Functional Programming"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 3,
      "cate": [
        "general",
        "Code Pattern"
      ],
      "id": 8
    },
    {
      "subject": "js",
      "title": "Js Eventloop",
      "ques": "",
      "links": [
        {
          "name": "https://blog.carbonfive.com/the-javascript-event-loop-explained/"
        }
      ],
      "tags": [
        {
          "name": "Eventloop"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 4,
      "cate": [
        "general",
        "async"
      ],
      "id": 9
    },
    {
      "subject": "js",
      "title": "JavaScript Design Patterns",
      "ques": "",
      "links": [
        {
          "name": "https://www.digitalocean.com/community/tutorial_series/javascript-design-patterns"
        }
      ],
      "tags": [],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": [
        "code_pattern"
      ],
      "id": 10
    },
    {
      "subject": "js",
      "title": "Javascript OOPs implementation",
      "ques": "",
      "links": [
        {
          "name": "https://www.educative.io/blog/object-oriented-programming"
        },
        {
          "name": "https://www.youtube.com/watch?v=S1dWe3f2zm0&ab_channel=Telusko"
        },
        {
          "name": "https://www.youtube.com/watch?v=vDJpGenyHaA&ab_channel=TraversyMedia"
        },
        {
          "name": "https://www.youtube.com/watch?v=PFmuCDHHpwk&ab_channel=ProgrammingwithMosh"
        }
      ],
      "tags": [
        {
          "name": "OOPs"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 4,
      "cate": [
        "general",
        "oops"
      ],
      "id": 11
    },
    {
      "subject": "js",
      "title": "JS Promised",
      "ques": "",
      "links": [],
      "tags": [
        {
          "name": "Promises"
        }
      ],
      "ans": "const getConfig1 = new Promise((resolve, reject) => {\n    let ser;\n    setTimeout(() => resolve(ser), 100)\n  });\n\n\nconst _f1 = () => {\n    const asyncPromise  = new Promise(async(resolve, reject) => {\n        try{\n           let data = await getConfig1;\n           resolve(data); \n        } catch(err){\n            reject(err);\n        }\n    });\n\n    return [asyncPromise];\n}\n\nconst f1 = () => {\n    const asyncPromise  = async() => {\n        try{\n           let data = 42; //await getConfig1;\n           return data; \n        } catch(err){\n            return err;\n        }\n    }\n    return [asyncPromise];\n}\n\nlet promises = _f1();\n\nPromise.all(promises).then((configPayloads)=>{\n    console.log(\"configPayloads ::\", configPayloads);\n}).catch((error)=>{\n    console.log(\"error ::\", error);\n})\n",
      "diff": 1,
      "imp": 1,
      "cate": [
        "general"
      ],
      "id": 12
    },
    {
      "subject": "js",
      "title": "Currying",
      "ques": "",
      "links": [],
      "tags": [
        {
          "name": "Currying"
        },
        {
          "name": "Walmart"
        }
      ],
      "ans": "/*\nCase 1: add(1)(2)(3)\nIt’s basically a sequence of functions with single argument. \nSo our approach is to return a function which in turn returns another function to accept next argument.\n*/\nfunction add(a){\n return function(b){\n  return function(c){\n   return a+b+c\n  }\n }\n}\n\n\n/*\nCase 2: add(1)(2)(3)…(n)()\nIt’s basically a sequence of n+1 functions with single argument except the last one. \nSo our approach is to return a function which in turn returns another function to accept \nnext argument and so on till the last argument doesn’t exist.\n*/\nfunction add(a) {\n  return function(b){\n    if(b){\n      return add(a+b)\n    }\n    return a\n  }\n}\n\n//let res = add(1)(2)(3)(4)();\n//console.log(\"res ::\", res);\n\n\n/*\nCase 3: sum(1,2)(3,4)\nSo, this is similar as above just that we are accepting two arguments in single call. \nSo, we need to add the arguments. Let’s look at the code:\n*/\nfunction sum(a,b) {\n  return function(c,d){\n    return a+b+c+d\n  }\n}\n\n/*\nCase 4: add(1,2..n)(5,6…n)…(n)()\nNow in this case, everything is infinite. We already know infinite currying, let’s focus on infinite arguments.\n*/\nfunction add(...args) {\n  let a = args.reduce((a, b) => a + b, 0)\n  return function(...args){\n    let b = args.reduce((a, b) => a + b, 0)\n    if(b){\n      return add(a+b)\n    }\n    return a\n  }\n}",
      "diff": 1,
      "imp": 1,
      "cate": [
        "general",
        "code_pattern"
      ],
      "id": 13
    },
    {
      "subject": "js",
      "title": "Predict Output",
      "ques": "",
      "links": [],
      "tags": [
        {
          "name": "Basics & Tricky"
        }
      ],
      "ans": "1.what will be the output?\nvar a = 10;\n\nfunction t(){\n    this.a = 20;\n    return a;\n}\n\nconsole.log(new t())\n\nOptions :-\nA. 10\nB. 20\nC. {a : 20}\nD. undefined\n\nAnswer - C\n---------------------------------------------------\n\n2.what will be the output?\nconsole.log(a);\nconsole.log(b);\nvar a=1;\nconst b=2;\n\n\noptions :-\nA. ReferenceError: a is not defined, ReferenceError: b is not defined\nB. undefined, ReferenceError: b is not defined\nC. 1, 2\nD. ReferenceError: a is not defined, undefined\n\nAnswer - B\n---------------------------------------------------\n\n3.what will be the output?\nlet i;\nfor(i=0; i<5; i++){\n    setTimeout(()=>{\n        console.log(i);\n    });\n}\n\noptions :-\nA. 4, 4, 4, 4, 4\nB. 5, 5, 5, 5, 5\nC. undefined\nD. 0, 1, 2, 3, 4\n\nAnswer - B\n---------------------------------------------------\n\n4.what will be output?\nconst length = 4;\nconst numbers = [];\nfor (var i = 0; i < length; i++);{\n  numbers.push(i + 1);\n}\nnumbers;\n\n\noptions :-\nA.[5]\nB.[0,1,2,3]\nC.[1,2,3,4]\nD.[]\n\nAnswer - A\n---------------------------------------------------\n\n5.What will be output?\nfunction foo() {\n  let a = b = 0;\n  a++;\n  return a;\n}\nfoo();\nconsole.log(typeof a); \nconsole.log(typeof b);\n\noptions :-\nA. undefined, number\nB. number, number\nC. boolean, boolean\nD. number, undefined\n\nAnswer - A\n\n\n\n\n",
      "diff": 1,
      "imp": 1,
      "cate": [
        "general"
      ],
      "id": 14
    },
    {
      "subject": "js",
      "title": "Factory Function vs. Constructor vs. Class",
      "ques": "",
      "links": [
        {
          "name": "https://www.youtube.com/watch?v=fbuyliXlDGI&ab_channel=ColorCode"
        }
      ],
      "tags": [
        {
          "name": "Youtube"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": [
        "general",
        "code_pattern"
      ],
      "id": 15
    },
    {
      "subject": "js",
      "title": "Implement Hashcode in Javascript",
      "ques": "",
      "links": [
        {
          "name": "https://stackoverflow.com/questions/194846/is-there-any-kind-of-hash-code-function-in-javascript"
        }
      ],
      "tags": [
        {
          "name": "Leetcode"
        }
      ],
      "ans": "String.prototype.hashCode = function(){\n    var hash = 0;\n    for (var i = 0; i < this.length; i++) {\n        var character = this.charCodeAt(i);\n        hash = ((hash<<5)-hash)+character;\n        hash = hash & hash; // Convert to 32bit integer\n    }\n    return hash;\n}",
      "diff": 1,
      "imp": 1,
      "cate": [
        "general"
      ],
      "id": 16
    },
    {
      "subject": "js",
      "title": "Polyfill for Array methods: map(), filter() and reduce() ",
      "ques": "",
      "links": [
        {
          "name": "https://medium.com/nerd-for-tech/polyfill-for-array-map-filter-and-reduce-e3e637e0d73b"
        }
      ],
      "tags": [
        {
          "name": "medium.com"
        },
        {
          "name": "Adobe"
        }
      ],
      "ans": "//MAP\nlet newArray = arr.map(callback(currentValue[, index[, array]]) {\n  // return element for newArray, after executing something\n});\n\n\nArray.prototype.myMap = function(callbackFn) {\n  var arr = [];              \n  for (var i = 0; i < this.length; i++) { \n     /* call the callback function for every value of this array and       push the returned value into our resulting array\n     */\n    arr.push(callbackFn(this[i], i, this));\n  }\n  return arr;\n}\n\n\n\n//FILTER\nlet newArray = arr.filter(callback(currentValue[, index[, array]]) {\n  // return element for newArray, if true\n});\n\nArray.prototype.myFilter = function(callbackFn) {\n  var arr = [];     \n  for (var i = 0; i < this.length; i++) {\n    if (callbackFn.call(this, this[i], i, this)) {\n      arr.push(this[i]);\n    }\n  }\n  return arr;\n}\n\n//REDUCE\narr.reduce(callback( accumulator, currentValue, [, index[, array]] )[, initialValue])\n\nArray.prototype.myReduce= function(callbackFn, initialValue) {\n  var accumulator = initialValue;\nfor (var i = 0; i < this.length; i++) {\n    if (accumulator !== undefined) {\n      accumulator = callbackFn.call(undefined, accumulator, this[i],   i, this);\n    } else {\n      accumulator = this[i];\n    }\n  }\n  return accumulator;\n}\n\n\n\n\n",
      "diff": 1,
      "imp": 1,
      "cate": [
        "general"
      ],
      "id": 17
    },
    {
      "subject": "js",
      "title": "Web Components",
      "ques": "What is web components in Js?",
      "links": [
        {
          "name": "https://kinsta.com/blog/web-components/"
        }
      ],
      "tags": [
        {
          "name": "web componet"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": [
        "general"
      ],
      "id": 18
    },
    {
      "subject": "js",
      "title": "What are web APIs?",
      "ques": "",
      "links": [
        {
          "name": "https://developer.mozilla.org/en-US/docs/Web/API"
        }
      ],
      "tags": [
        {
          "name": "web API"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": [
        "general"
      ],
      "id": 19
    },
    {
      "subject": "js",
      "title": "What is the order of inline onclick vs addeventlistener and why?",
      "ques": "",
      "links": [
        {
          "name": "https://stackoverflow.com/questions/49805942/what-is-the-order-of-inline-onclick-vs-addeventlistener-and-why#:~:text=As%20we%20can%20see%20then,second%20listener%20set%20with%20addEventListener%20."
        },
        {
          "name": "https://jsbin.com/xubajoradi/edit?html,js,console,output"
        }
      ],
      "tags": [],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": [
        "events",
        "general"
      ],
      "id": 20
    }
  ],
  "es6": [
    {
      "subject": "es6",
      "title": "Hoisting in Modern JavaScript — let, const, and var",
      "ques": "",
      "links": [
        {
          "name": "https://blog.bitsrc.io/hoisting-in-modern-javascript-let-const-and-var-b290405adfda"
        }
      ],
      "tags": [
        {
          "name": "medium.com"
        }
      ],
      "ans": "\nTo avoid possible side effects of hoisting like undefined variables or reference error, \nalways try to declare the variables at the top of their respective scopes and also \nalways try to initialize variables when you declare them.",
      "diff": 1,
      "imp": 1,
      "cate": [
        "general"
      ],
      "id": 1
    },
    {
      "subject": "es6",
      "title": "Javascript set",
      "ques": "",
      "links": [
        {
          "name": "https://bretcameron.medium.com/how-to-make-your-code-faster-using-javascript-sets-b432457a4a77#:~:text=Because%20Set.,time%20of%20O(N)."
        }
      ],
      "tags": [
        {
          "name": "set"
        },
        {
          "name": "Oracle"
        }
      ],
      "ans": "let s = new Set([1,2,3]);\n\nconsole.log(s);\ns.add(4);\nconsole.log(s);\ns.add(1);\nconsole.log(s);",
      "diff": 1,
      "imp": 1,
      "cate": [
        "general"
      ],
      "id": 2
    }
  ],
  "ts": [],
  "html": [],
  "css": [],
  "ng": [],
  "react": [],
  "redux": [],
  "performance": [],
  "sd": [
    {
      "subject": "sd",
      "title": "LRU cache implementation in Javascript",
      "ques": "",
      "links": [
        {
          "name": "https://stackoverflow.com/questions/996505/lru-cache-implementation-in-javascript"
        },
        {
          "name": "https://medium.com/dsinjs/implementing-lru-cache-in-javascript-94ba6755cda9"
        }
      ],
      "tags": [
        {
          "name": "iCloud-note"
        },
        {
          "name": "medium.com"
        }
      ],
      "ans": "\nclass LRU {\n    constructor(max = 10) {\n        this.max = max;\n        this.cache = new Map();\n    }\n\n    get(key) {\n        let item = this.cache.get(key);\n        if (item) {\n            // refresh key\n            this.cache.delete(key);\n            this.cache.set(key, item);\n        }\n        return item;\n    }\n\n    set(key, val) {\n        // refresh key\n        if (this.cache.has(key)) this.cache.delete(key);\n        // evict oldest\n        else if (this.cache.size == this.max) this.cache.delete(this.first());\n        this.cache.set(key, val);\n    }\n\n    first() {\n        return this.cache.keys().next().value;\n    }\n}",
      "diff": 1,
      "imp": 1,
      "cate": [
        "caching"
      ],
      "id": 1
    },
    {
      "subject": "sd",
      "title": "How do I create a URL shortener(JS)?",
      "ques": "",
      "links": [
        {
          "name": "https://stackoverflow.com/questions/742013/how-do-i-create-a-url-shortener"
        }
      ],
      "tags": [
        {
          "name": "iCloud-note"
        },
        {
          "name": "stackoverflow"
        }
      ],
      "ans": "How to convert the ID to a shortened URL\n-----------------------------------------\nThink of an alphabet we want to use. In your case, that's [a-zA-Z0-9]. It contains 62 letters.\nTake an auto-generated, unique numerical key (the auto-incremented id of a MySQL table for example).\n\nFor this example, I will use 12510 (125 with a base of 10).\n\nNow you have to convert 12510 to X62 (base 62).\n\n12510 = 2×621 + 1×620 = [2,1]\n\nThis requires the use of integer division and modulo. A pseudo-code example:\n\ndigits = []\n\nwhile num > 0\n  remainder = modulo(num, 62)\n  digits.push(remainder)\n  num = divide(num, 62)\n\ndigits = digits.reverse\nNow map the indices 2 and 1 to your alphabet. This is how your mapping (with an array for example) could look like:\n\n0  → a\n1  → b\n...\n25 → z\n...\n52 → 0\n61 → 9\nWith 2 → c and 1 → b, you will receive cb62 as the shortened URL.\n\nhttp://shor.ty/cb\n\n\nHow to resolve a shortened URL to the initial ID\n---------------------------------------------------\nThe reverse is even easier. You just do a reverse lookup in your alphabet.\n\ne9a62 will be resolved to \"4th, 61st, and 0th letter in the alphabet\".\n\ne9a62 = [4,61,0] = 4×622 + 61×621 + 0×620 = 1915810\n\nNow find your database-record with WHERE id = 19158 and do the redirect.",
      "diff": 1,
      "imp": 1,
      "cate": [
        "general"
      ],
      "id": 2
    },
    {
      "subject": "sd",
      "title": "Encode and Decode TinyURL(Java)",
      "ques": "TinyURL is a URL shortening service where you enter a URL such as https://leetcode.com/problems/design-tinyurl and it returns a short URL such as http://tinyurl.com/4e9iAk. Design a class to encode a URL and decode a tiny URL.\n\nThere is no restriction on how your encode/decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL.\n\nImplement the Solution class:\n\nSolution() Initializes the object of the system.\nString encode(String longUrl) Returns a tiny URL for the given longUrl.\nString decode(String shortUrl) Returns the original long URL for the given shortUrl. It is guaranteed that the given shortUrl was encoded by the same object.",
      "links": [
        {
          "name": "https://leetcode.com/problems/encode-and-decode-tinyurl/"
        }
      ],
      "tags": [
        {
          "name": "Leetcode"
        }
      ],
      "ans": "\npackage com.company;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Random;\n\n// Approach #3 Using hashcode\nclass CodecX3 {\n    Map<Integer, String> map = new HashMap<>();\n\n    public String encode(String longUrl) {\n        map.put(longUrl.hashCode(), longUrl);\n        return \"http://tinyurl.com/\" + longUrl.hashCode();\n    }\n\n    public String decode(String shortUrl) {\n        return map.get(Integer.parseInt(shortUrl.replace(\"http://tinyurl.com/\", \"\")));\n    }\n}\n\n// Approach #2 Variable-length Encoding\nclass CodecX2 {\n    String chars = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    HashMap<String, String> map = new HashMap<>();\n    int count = 1;\n\n    public String getString() {\n        int c = count;\n        StringBuilder sb = new StringBuilder();\n        while (c > 0) {\n            c--;\n            sb.append(chars.charAt(c % 62));\n            c /= 62;\n        }\n        return sb.toString();\n    }\n\n    public String encode(String longUrl) {\n        String key = getString();\n        map.put(key, longUrl);\n        count++;\n        return \"http://tinyurl.com/\" + key;\n    }\n\n    public String decode(String shortUrl) {\n        return map.get(shortUrl.replace(\"http://tinyurl.com/\", \"\"));\n    }\n}\n\n// Approach #4 Using random number\nclass CodecX4 {\n    Map<Integer, String> map = new HashMap<>();\n    Random r = new Random();\n    int key = r.nextInt(Integer.MAX_VALUE);\n\n    public String encode(String longUrl) {\n        while (map.containsKey(key)) {\n            key = r.nextInt(Integer.MAX_VALUE);\n        }\n        map.put(key, longUrl);\n        return \"http://tinyurl.com/\" + key;\n    }\n\n    public String decode(String shortUrl) {\n        return map.get(Integer.parseInt(shortUrl.replace(\"http://tinyurl.com/\", \"\")));\n    }\n}\n\n// Approach #5 Random fixed-length encoding\nclass Codec {\n    String alphabet = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    HashMap<String, String> map = new HashMap<>();\n    Random rand = new Random();\n    String key = getRand();\n\n    public String getRand() {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < 6; i++) {\n            sb.append(alphabet.charAt(rand.nextInt(62)));\n        }\n        return sb.toString();\n    }\n\n    public String encode(String longUrl) {\n        while (map.containsKey(key)) {\n            key = getRand();\n        }\n        map.put(key, longUrl);\n        return \"http://tinyurl.com/\" + key;\n    }\n\n    public String decode(String shortUrl) {\n        return map.get(shortUrl.replace(\"http://tinyurl.com/\", \"\"));\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n\n        Codec c1 = new Codec();\n        String encodeURL = c1.encode(\"https://leetcode.com/problems/design-tinyurl\");\n        System.out.println(\"encodeURL ::\" + encodeURL);\n\n        String decodeURL = c1.decode(encodeURL);\n        System.out.println(\"decodeURL ::\" + decodeURL);\n\n\n    }\n}\n",
      "diff": 1,
      "imp": 1,
      "cate": [
        "general"
      ],
      "id": 3
    }
  ],
  "shell": [
    {
      "subject": "shell",
      "title": "Check Disk Space",
      "ques": "How to Check Disk Space in Linux?",
      "links": [
        {
          "name": "https://phoenixnap.com/kb/linux-check-disk-space"
        }
      ],
      "tags": [
        {
          "name": "General"
        },
        {
          "name": "linux"
        }
      ],
      "ans": "\n/*\nThe df command stands for disk free, and it shows you the amount of space taken up by \ndifferent drives. By default, df displays values in 1-kilobyte blocks.\n*/\ndf\n\n\n/* Display Usage in Megabytes and Gigabytes */\ndf -h\n\n/* Understanding the Output Format */\n\nFilesystem         Size      Used     Avail    Use%    Mounted on\n\nudev               210M        0        210M     0%       /dev\n\ntmpfs              49M       1004K      48M      3%       /run\n\n/dev/sda2          7.9G       4.3G      3.2G     58%      /\n\nYour output may have more entries. The columns should be self-explanatory:-\n\nFilesystem – This is the name of each particular drive. This includes physical hard drives, \nlogical (partitioned) drives, and virtual or temporary drives.\nSize – The size of the filesystem.\nUsed – Amount of space used on each filesystem.\nAvail – The amount of unused (free) space on the filesystem.\nUse% – Shows the percent of the disk used.\nMounted on – This is the directory where the file system is located. This is also sometimes \ncalled a mount point.\n\nThe list of filesystems includes your physical hard drive, as well as virtual hard drives:-\n\n/dev/sda2 – This is your physical hard drive. It may be listed as /sda1, /sda0, or you may even have more than one. /dev stands for device.\nudev – This is a virtual directory for the /dev directory. This is part of the Linux operating \nsystem.\ntmpfs – You may have several of these. These are used by /run and other Linux processes as \ntemporary filesystems for running the operating system. For example, the tmpfs /run/lock is \nused to create lockfiles. These are the files that prevent multiple users from changing the \nsame file at the same time.\n\n\n/* Display a Specific File System */\ndf -h /dev/sda2\ndf -h /\n\n/* Display File Systems by Type */\ndf -ht ext4\n\n/* Display Size in 1000 Instead of 1024 */\ndu -H\n\n/*\nCheck Disk Space in Linux With du Command\nThe du command displays disk usage\n*/\ndu\ndu -h\ndu -hs\ndu -hs /etc\nsudo du -hs /etc\n\n\n/* HELP */\ndf --help or du --help.\n",
      "diff": 1,
      "imp": 1,
      "cate": [
        "disk"
      ],
      "id": 1
    }
  ],
  "git": [
    {
      "subject": "git",
      "title": "Git general commands",
      "ques": "",
      "links": [],
      "tags": [],
      "ans": "git remote -v\n\ngit push origin HEAD\n\ngit fetch --tags --force\n\ngit fetch -t\n\ngit tag\n\ngit checkout -b \"<branch_name>\" -t origin/master\n\ngit pull --rebase\n\ngit rebase -i HEAD~2 // Squash",
      "diff": 3,
      "imp": 3,
      "cate": [
        "general"
      ],
      "id": 1
    }
  ],
  "py": [],
  "java": [],
  "oth": [],
  "node": [
    {
      "subject": "node",
      "title": "Express API references",
      "ques": "",
      "links": [
        {
          "name": "https://expressjs.com/en/4x/api.html"
        }
      ],
      "tags": [
        {
          "name": "express"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": [
        "framework"
      ],
      "id": 1
    },
    {
      "subject": "node",
      "title": "Node.js buffer: A complete guide",
      "ques": "",
      "links": [
        {
          "name": "https://www.w3schools.com/nodejs/ref_buffer.asp"
        },
        {
          "name": "https://blog.logrocket.com/node-js-buffer-complete-guide/"
        }
      ],
      "tags": [
        {
          "name": "buffer"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": [
        "node_core"
      ],
      "id": 2
    },
    {
      "subject": "node",
      "title": "Node.js child process",
      "ques": "",
      "links": [
        {
          "name": "https://medium.com/@diego.coder/child-processes-in-node-js-37429fb54670"
        },
        {
          "name": "https://blog.logrocket.com/node-js-child-process-launch-external-programs/"
        },
        {
          "name": "https://www.freecodecamp.org/news/node-js-child-processes-everything-you-need-to-know-e69498fe970a/"
        }
      ],
      "tags": [
        {
          "name": "child Process"
        }
      ],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": [
        "node_core"
      ],
      "id": 3
    },
    {
      "subject": "node",
      "title": "Asyncjs",
      "ques": "",
      "links": [
        {
          "name": "http://caolan.github.io/async/v3/"
        }
      ],
      "tags": [],
      "ans": "",
      "diff": 1,
      "imp": 1,
      "cate": [
        "library"
      ],
      "id": 4
    }
  ]
}